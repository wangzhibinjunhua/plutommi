/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 * Adaptation interfaces for DLAgent application
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
 
#include "MMI_include.h"

#ifdef __MMI_DOWNLOAD_AGENT__

#include "CommonScreens.h"
#include "ProtocolEvents.h"
#include "app_mine.h"

#include "drm_def.h"                    /* DRM_PROC_RESULT_OK */
#include "drm_gprot.h"
#include "DLAgentSrvDef.h"
#include "DLAgentSrvGprot.h"
#include "DLAgentSrvIProt.h"
//#include "DLAgentResDef.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif
#include "DLAgentSrvOMA.h"
#include "DLAgentSrvWPS.h"
#include "DLAgentSrvProt.h"
#include "BrowserSrvGprot.h"
#include "das_struct.h"

//#include "SimDetectionDef.h"            /* SCR_SIM_INSERTION and SCR_SIM_BLOCK */
#include "IdleAppDef.h"                 /* IDLE_SCREEN_ID */
#include "MessagesResourceData.h"       /* IMG_NEW_MESSAGE_NOTIFICATION_MSG */
#include "FileMgr.h"
#include "FileManagerDef.h"
#include "FileMgrSrvGprot.h"
#include "SettingDefs.h"
#include "UCMGProt.h"
#include "IdleAppProt.h"                /* mmi_idle_is_on_idle_screen */
#include "Cbm_api.h"
#include "wap_ps_struct.h"
#include "wapadp.h"
#include "Conversions.h"

#ifdef __USB_IN_NORMAL_MODE__
#include "ExtDeviceDefs.h"
//#include "USBDeviceGprot.h"             /* mmi_usb_is_in_mass_storage_mode */
#include "USBSrvGProt.h"
#endif 


#include "GpioSrvGprot.h"                    /* srv_backlight_turn_on */

/****************************************************************************
 * Define
 ****************************************************************************/
#define SRV_DA_MAX_NUM_OF_JOB   10

typedef struct
{
    srv_da_job_struct   *setuping_job; /* job does not start yet, only 1 job at a time */
    srv_da_setting_struct setting;  /* the one and ONLY one setting body */
   #ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    srv_da_dl_report_callback setuping_cb;
   #endif 
    srv_da_job_struct   *curr_job;
    srv_da_job_struct   *list_job;
    MMI_BOOL            allow_to_trigger_connection;
    S32                 list_job_num;
    U32                 last_error;
    MMI_BOOL            popup_triggered;
    /* If job list updated, we should discard the information in the GUI buffe
       of job list */
    MMI_BOOL            job_list_updated;
	S32                 job_list_highlight_index;
    MMI_BOOL            cause;
    U32                 paused_num;
    MMI_BOOL            bearer_switching;


} srv_da_context_struct;

/****************************************************************************
* Global Variable
*****************************************************************************/

#ifdef BROWSER_SUPPORT
extern const srv_da_module_funcptr_table srv_da_http_module;
#endif
#ifdef __MMI_OMA_DD_DOWNLOAD__
extern const srv_da_module_funcptr_table srv_da_oma_module;
#endif  
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
extern const srv_da_module_funcptr_table srv_da_http_dl_module;
#endif
#ifdef MMI_DLA_MRE_SUPPORT
extern const srv_da_module_funcptr_table srv_da_mre_module;
#endif
#if defined(BROWSER_SUPPORT)
#ifdef PGDL_SUPPORT_YOUTUBE
/* under construction !*/
#endif
#endif
#if defined(BROWSER_SUPPORT)
extern void srv_da_recv_wap_notify_ind(void *MsgStruct, int mod_src, void *ilm_p);
#endif
extern MMI_BOOL srv_da_free_job (srv_da_job_struct *job);
#if defined(BROWSER_SUPPORT)
extern void srv_da_recv_nw_switch_ind(void *MsgStruct, int mod_src, void *ilm_p);
#endif
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
void srv_da_suspend_all_job(srv_da_error_enum cause);
extern void srv_da_adp_close_app (void);
//static void srv_da_adp_close_app_ext(void);
extern U16 srv_da_http_dl_get_job_id(const srv_da_job_struct* job);
/****************************************************************************
* Static Variable
*****************************************************************************/


#if defined(BROWSER_SUPPORT) || defined(__MMI_OMA_DD_DOWNLOAD__)
const static srv_da_module_funcptr_table* da_module_table[SRV_DA_JOB_TYPE_TOTAL]=
{
#ifdef BROWSER_SUPPORT
    &srv_da_http_module,
#endif
#ifdef __MMI_OMA_DD_DOWNLOAD__
    &srv_da_oma_module,
#endif
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	&srv_da_http_dl_module,
#endif
#ifdef PGDL_SUPPORT_YOUTUBE
#ifdef BROWSER_SUPPORT
/* under construction !*/
#endif
#endif
#ifdef MMI_DLA_MRE_SUPPORT
    &srv_da_mre_module,
#endif
};
#endif


static srv_da_context_struct g_srv_da_context;
static void srv_da_suspended_in_background_callback(srv_da_job_struct* job, U16 string_id);
#if (defined(__COSMOS_MMI_PACKAGE__) && (defined(__MMI_DLA_SLIM__) || defined(SLIM_WAP_MMS)))
static void srv_da_delete_completed_failed(void);
#endif
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_adp_show_ncenter (void *arg, U16 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_update_ncenter_event_struct  evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_UPDATE_NCENTER);
    evt.show = MMI_TRUE;
    evt.arg = arg;
    evt.type = type;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}


void srv_da_adp_hide_ncenter (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_update_ncenter_event_struct  evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_UPDATE_NCENTER);
    evt.show = MMI_FALSE;
    evt.arg = NULL;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}
#endif
void srv_da_adp_usb_app_unavailable_popup(void)
{
	srv_da_usb_available_event_struct evt;
	MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_IS_USB_AVAILABLE);
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

}
#ifdef __J2ME__
void srv_da_adp_java_receive_da_file (S32 session_id, S32 mime_type, S32 mime_subtype, S32 action, PU16 file_path, PS8 url, PS8 mime_type_string)
{

	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_receive_java_file_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_JAVA_FILE_IND);
    evt.session_id = session_id;
    evt.mime_type = mime_type;
    evt.mime_subtype = mime_subtype;
    evt.action = action;
    evt.file_path = file_path;
    evt.url = url;
    evt.mime_type_string = mime_type_string;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

}
void srv_da_adp_java_setting(
        S32	session_id,
        S32	mime_type,
        S32	mime_subtype,
        S32 action,
        U32	filesize,
        PS8	url,
        PS8	mime_type_string,
        U32	content_len,
        PS8	content,
        srv_da_setting_struct *setting)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_setting_java_file_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_JAVA_SETTING_IND);
    evt.session_id = session_id;
    evt.mime_type = mime_type;
    evt.mime_subtype = mime_subtype;
    evt.action = action;
    evt.filesize = filesize;
    evt.url = url;
    evt.mime_type_string = mime_type_string;
	evt.content_len = content_len;
	evt.content = content;
	evt.setting = setting;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

}
#endif

#ifdef __CERTMAN_SUPPORT__
void srv_da_adp_certman_install_file(
    S32 session_id,
    S32 mime_type,
    S32 mime_subtype,
    S32 action_type,
    PU16 filename,
    PS8 download_url,
    PS8 mime_type_str_string)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_certman_install_file  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_CERTMAN_SETTING_IND);
    evt.session_id = session_id;
    evt.mime_type = mime_type;
    evt.mime_subtype = mime_subtype;
    evt.action_type = action_type;
    evt.filename = filename;
    evt.download_url = download_url;
    evt.mime_type_str_string = mime_type_str_string;
	MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}
#endif
/*****************************************************************************
* FUNCTION
*  srv_wap_prof_mem_allocate
* DESCRIPTION
*  Allocates requested memory from control buffer.
* PARAMETERS
*  size        [IN]        
* RETURNS
*  void
*****************************************************************************/
void *srv_da_adp_mem_allocate(U32 size)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/
	void *result = NULL;

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	result = (void*)OslMalloc(size);

	if (NULL == result)
	{
		ASSERT(result);
		return result;
	}
	return result;
}


/*****************************************************************************
* FUNCTION
*  srv_srv_da_adpf_mem_free
* DESCRIPTION
*  Releases memory pointed by ptr.
* PARAMETERS
*  ptr     [?]     
* RETURNS
*  void
*****************************************************************************/
void srv_srv_da_adp_mem_free(void *ptr)
{
	/*----------------------------------------------------------------*/
	/* Local Variables                                                */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body                                                      */
	/*----------------------------------------------------------------*/
	if (NULL == ptr)
	{
		ASSERT(ptr);
		return;
	}
	OslMfree(ptr);
}



void srv_da_adp_handle_push_move(void *arg, S32 error_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_push_process_event_struct  evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_CLICK_JOB);
    evt.error_code = error_code;
    evt.arg = arg;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}

void srv_da_adp_show_progressing(
    srv_da_action_scr_enum screen_id,
    U16 title_string_id,
    U16 title_icon_id,
    U16 message_id,
    MMI_BOOL cancel_rsk, /* Show RSK "Cancel" */
    void *arg,
    void (*cancel_callback)(void *arg, MMI_BOOL is_deleted))
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_show_progressing_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SHOW_PROGRESS);
    evt.screen_id = screen_id;
    evt.title_string_id = title_string_id;
    evt.title_icon_id = title_icon_id;
    evt.message_id = message_id;
    evt.cancel_rsk = cancel_rsk;
    evt.arg = arg;
    evt.cancel_callback = cancel_callback;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}

MMI_BOOL srv_da_adp_popup_for_job_msg(srv_da_job_struct *job, srv_da_popup_message_struct *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_popup_for_job_msg_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* Don't popup during reporting */
    if (job->reporting)
    {
        if (msg->free_string_after_popup &&
            msg->string != NULL)
        {
            srv_srv_da_adp_mem_free(msg->string);
            msg->string = NULL;
        }
        if (msg->info != NULL)
        {
            srv_srv_da_adp_mem_free(msg->info);
            msg->info = NULL;
        }
        msg->type = SRV_DA_POPUP_TYPE_NONE;
        return MMI_TRUE;
    }

    if (msg != &(job->pending_popup))
    {
        srv_da_discard_pending_popup(job);
    }
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

    if (srv_da_is_popup_allowed())
    {
        if (msg->type == SRV_DA_POPUP_TYPE_LONG_MESSAGE)
        {
            g_srv_da_context.curr_job = job;
        }
    
        goto POPUP;
    }
    else if (msg != &(job->pending_popup))
    {
        memcpy(&(job->pending_popup), msg, sizeof(srv_da_popup_message_struct));
        msg->type = SRV_DA_POPUP_TYPE_NONE;
    }
    
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    if (srv_da_is_popup_allowed())
    {
        if (msg->type == SRV_DA_POPUP_TYPE_LONG_MESSAGE)
        {
            g_srv_da_context.curr_job = job;
        }
    
        goto POPUP;
    }

#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

POPUP:
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP_FOR_JOB_MSG);
    evt.job = job;
    evt.msg = msg;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    return MMI_TRUE;
}




void srv_da_adp_popup(U32 string_id, S32 cause, srv_da_popup_type_enum type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_popup_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP);
    evt.string_id = string_id;
    evt.type = type;
	evt.cause = cause;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}



/*
 * If set instance in true it will set active instance otherwise not needed
 * Set parameter instance will be passed to application and if it is true application need
 * to call API  mmi_da_set_active_select_storage_instance(select_storage_instance) where
 * variable select_storage_instance
 * is returned instance from API mmi_da_scr_select_storage
 */
void srv_da_adp_select_storage_and_set_instance (
    srv_da_scr_storage_callback_type callback,
    const srv_da_storage_parameter_struct* parameter,
    U32 arg,
    U16 title_icon_id,
    MMI_BOOL set_instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    //srv_da_select_storage_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
}


void srv_da_adp_set_active_select_storage_instance (void *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_set_active_select_storage_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SET_STORAGE_INSTANCE);
    evt.instance = instance;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}

#ifndef MMI_DA_PLUTO_SLIM
void srv_da_adp_display_job_list(srv_da_job_struct* job, MMI_BOOL check_complete)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_display_job_list_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_DISPLAY_JOB_LIST);
    evt.job = job;
    evt.check_complete = check_complete;

    if ((job) && (job->state == SRV_DA_JOB_STATE_COMPLETED))
    {
        evt.list_type = SRV_DA_LIST_TYPE_COMPLETED;
    }
    else
    {
        evt.list_type = SRV_DA_LIST_TYPE_DOWNLOADED;
    }
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}
#endif

void srv_da_adp_display_job_detail(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_display_job_detail_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_DISPLAY_JOB_DETAIL);
    evt.job = job;
    //evt.str_id = str_id;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}


void srv_da_adp_scr_progressing_close(U16 screen_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_progressing_close_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_PROGRESSING_CLOSE);
    evt.screen_id = screen_id;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}


void srv_da_adp_popup_for_error_code_with_callback (U16 error_code, mmi_proc_func callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_popup_for_error_code_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP_ERRORCODE_WITH_CALLBACK);
    evt.error_code = error_code;
    evt.callback = callback;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* this need to be handled in APP part API mmi_da_srvif_popup_for_error_code_with_callback in DlAgentmmisrvinterface.c */
}



/*
 * If set instance in true it will set active instance otherwise not needed
 * Set parameter instance will be passed to application and if it is true application need
 * to call API  mmi_da_set_active_download_confirm_screen(job, choice_instance_id) where
 * variable select_storage_instance
 * is returned instance from API mmi_da_scr_select_storage
 */
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_adp_show_choice_screen (
    MMI_BOOL show_cancel_ask,
    void *arg,
    U16  arg_size,
    void (*lsk_hdlr)(void *arg, U16 *filepath),
    void (*rsk_hdlr)(void *arg),
    void (*delete_hdlr)(void *arg),
    MMI_BOOL set_instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_show_choice_screen_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SHOW_NEW_DOWNLOAD_CONFIRM_SCREEN);
    evt.show_cancel_ask = show_cancel_ask;
    evt.arg = arg;
    evt.arg_size = arg_size;
    evt.lsk_hdlr = lsk_hdlr;
    evt.rsk_hdlr = rsk_hdlr;
    evt.delete_hdlr = delete_hdlr;
    evt.set_instance = set_instance;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}

void srv_da_adp_set_active_download_confirm_screen(srv_da_job_struct *job, U16 instance_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_set_active_download_confirm_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SET_ACTIVE_DOWNLOAD_CONFIRM_SCREEN);
    evt.job = job;
    evt.instance_id = instance_id;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* POST event to invoke void mmi_da_set_active_download_confirm_screen(srv_da_job_struct *job, U16 instance_id)*/
}


void srv_da_adp_handle_wps_http_response_callback (U32 job, U16 status, MMI_BOOL is_error)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_wps_http_response_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_WPS_HTTP_RSP_CALLBACK);
    evt.job = job;
    evt.status = status;
    evt.is_error = is_error;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* Execute API mmi_da_srvif_handle_wps_http_response_callback in app part */
}
#endif



#if defined (__MMI_OMA_DD_DOWNLOAD__)
void srv_da_adp_confirm_oma_download (U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_confirm_oma_download_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_da_oma_extract_dd_content_string((srv_da_job_struct*)arg))
    {
 #ifndef MMI_DA_PLUTO_SLIM
        srv_da_adp_show_choice_screen(
            MMI_FALSE,
            (void*)arg,
            sizeof (srv_da_job_struct),
            srv_da_oma_confirm_download_callback,
            srv_da_oma_download_cancel_callback,
            srv_da_oma_delete_screen_callback, 
            MMI_TRUE);
 #endif
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
    }

    //MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_CONFIRM_OMA_DOWNLOAD);
    //evt.arg = arg;
    //MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* need to execute MMI API mmi_da_oma_confirm_download (arg); */
}
void srv_da_adp_display_oma_download_options(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_confirm_oma_download_event_struct  evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_CONFIRM_OMA_DOWNLOAD);
    evt.arg = arg;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* need to execute MMI API mmi_da_oma_confirm_download (arg); */
}
#endif


srv_da_scr_select_storage_cause_enum srv_da_decide_location_auto (srv_da_storage_parameter_struct *para, U32 arg)
{
    if (para->storage == SRV_DA_STORAGE_AUTO ||
        para->storage == SRV_DA_STORAGE_PUSH_TEMP)
    {
        srv_da_storage_enum storage;
        U16 drv;
    
        if (srv_da_util_decide_drive_to_save_file(
            para->original_filepath,
            para->filesize, 
            &(drv),
            &(storage)) )
        {
            /* Ok. We got an available drive. */
        }
        else if (para->storage == SRV_DA_STORAGE_PUSH_TEMP &&
            para->original_filepath != NULL)
        {
            /* Dispatch from the original path directly */
            //TODO: for pushed object srv_da_scr_storage_callback(cntx, para->original_filepath, MMI_FALSE, MMI_TRUE);
			srv_da_push_filename_done(arg, (U16*)para->original_filepath, MMI_FALSE, MMI_TRUE, NULL);
			return SRV_DA_SCR_SELECT_STORAGE_CAUSE_DONE;
        }
        else if (srv_da_get_number_of_available_drives() > 0)
        {
            srv_da_adp_popup(SRV_DA_GLOBAL_NOT_ENOUGH_MEMORY, 0,  SRV_DA_POPUP_TYPE_ERROR);
            return SRV_DA_SCR_SELECT_STORAGE_CAUSE_INSUFFICIENT_MEMORY;
        }
        else
        {
            srv_da_adp_popup(SRV_DA_GLOBAL_INSERT_MEMORY_CARD, 0, SRV_DA_POPUP_TYPE_ERROR);
            return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NO_AVAILABLE_STORAGE;
        }

        para->drv = (S32)drv;
    }
    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
}


srv_da_scr_select_storage_cause_enum srv_da_select_storage_final(srv_da_storage_parameter_struct *para, U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *full_filename;
    S32 result;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (para->original_filepath != NULL &&
        !srv_da_util_does_file_exist(para->original_filepath))
    {
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_ORIGINAL_FILE_LOST;
    }

    /*
     * Decide storage again after filename is decided for AUTO.
     * Consider the case of after filename is inputed but drive is removed.
     */
    if (!para->select_storage)
    {
        if (para->storage == SRV_DA_STORAGE_AUTO ||
            para->storage == SRV_DA_STORAGE_PUSH_TEMP)
        {
            srv_da_storage_enum storage;
            U16 drv;
        
            if (!srv_da_util_decide_drive_to_save_file(
                para->original_filepath,
                para->filesize, 
                &(drv),
                &(storage)) )
            {
                if (srv_da_get_number_of_available_drives() > 0)
                {
                    srv_da_adp_popup(SRV_DA_GLOBAL_NOT_ENOUGH_MEMORY, 0,  SRV_DA_POPUP_TYPE_ERROR);
                    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_INSUFFICIENT_MEMORY;
                }
                else
                {
                    srv_da_adp_popup(SRV_DA_GLOBAL_INSERT_MEMORY_CARD, 0, SRV_DA_POPUP_TYPE_ERROR);
                    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NO_AVAILABLE_STORAGE;
                }
                //return;
            }

            para->drv = (S32)drv;
        }
    }

    full_filename = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) * sizeof(U16));
    
    if (para->fileext[0] != L'\0')
    {
        kal_wsprintf(full_filename, "%w.%w", para->filename, para->fileext);
    }
    else
    {
        mmi_wcscpy(full_filename, para->filename);
    }

    /* If filename is invalid, we assign a temp filename here */
    if (!srv_fmgr_path_is_filename_valid(full_filename))
    {
        U16 *folder_path;

        folder_path = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 1) * sizeof(U16));
        kal_wsprintf(folder_path, "%c:\\%w", para->drv, para->folder);
        srv_da_util_get_temp_filename(folder_path, filepath, SRV_FMGR_PATH_MAX_LEN);
        mmi_wcscpy(para->filename, srv_da_util_get_filename(filepath));
        srv_srv_da_adp_mem_free(folder_path);
    }

    srv_srv_da_adp_mem_free(full_filename);

    /* complete full path */
    if(para->fileext[0] != L'\0')
    {
        kal_wsprintf(filepath, "%c:\\%w%w.%w", 
                     para->drv, 
                     para->folder, 
                     para->filename,
                     para->fileext);
    }
    else
    {
        /* no ext */
        kal_wsprintf(filepath, "%c:\\%w%w",
                     para->drv, 
                     para->folder, 
                     para->filename);
    }

    if (para->original_filepath != NULL &&
        mmi_wcsicmp(filepath, para->original_filepath) == 0)
    {
        /* Path is not changed, following checkings are unnecessary */
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
    }
    
    /* Create folder for the file */
    result = srv_da_util_create_file_dir(filepath, MMI_TRUE);
    if (result < 0)
    {
        srv_da_adp_popup(0, result, SRV_DA_POPUP_TYPE_FS_ERROR);
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_FS_ERROR;
    }

    if (para->filecheck_func != NULL &&
        para->filecheck_func(filepath, MMI_FALSE))
    {
        /* User did not choose the name, decide a new name automatically */
        srv_da_util_get_clear_filepath(filepath, para->filecheck_func);
    }

    /* if all ok, call back to User */
    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
}

srv_da_scr_select_storage_cause_enum srv_da_select_storage_final_ext(srv_da_storage_parameter_struct *para, U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 *full_filename;
    S32 result;
	srv_da_storage_enum storage;
    U16 drv;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (para->original_filepath != NULL &&
        !srv_da_util_does_file_exist(para->original_filepath))
    {
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_ORIGINAL_FILE_LOST;
    }

    /*
     * Decide storage again after filename is decided for AUTO.
     * Consider the case of after filename is inputed but drive is removed.
     */
    if (!para->select_storage)
    {
        if (para->storage == SRV_DA_STORAGE_AUTO ||
            para->storage == SRV_DA_STORAGE_PUSH_TEMP)
        {
			

			
				if (!srv_da_util_decide_drive_yt_save_file(
                para->original_filepath,
                para->filesize, 
                &(drv),
                &(storage)))
				{
                if (srv_da_get_number_of_available_drives() >= 1)
                {
                    srv_da_adp_popup(SRV_DA_GLOBAL_NOT_ENOUGH_MEMORY, 0,  SRV_DA_POPUP_TYPE_ERROR);
						
                    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_INSUFFICIENT_MEMORY;
                }
                else
                {
                    srv_da_adp_popup(SRV_DA_INSERT_MEMORY_CARD, 0, SRV_DA_POPUP_TYPE_ERROR);
                    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NO_AVAILABLE_STORAGE;
                }
					
            }

            para->drv = (S32)drv;
        }
	}
    

    full_filename = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_FILE_NAME_LEN + 1) * sizeof(U16));
    
    if (para->fileext[0] != L'\0')
    {
        kal_wsprintf(full_filename, "%w.%w", para->filename, para->fileext);
    }
    else
    {
        mmi_wcscpy(full_filename, para->filename);
    }

    /* If filename is invalid, we assign a temp filename here */
    if (!srv_fmgr_path_is_filename_valid(full_filename))
    {
        U16 *folder_path;

        folder_path = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 1) * sizeof(U16));
        kal_wsprintf(folder_path, "%c:\\%w", para->drv, para->folder);
        srv_da_util_get_temp_filename(folder_path, filepath, SRV_FMGR_PATH_MAX_LEN);
        mmi_wcscpy(para->filename, srv_da_util_get_filename(filepath));
        srv_srv_da_adp_mem_free(folder_path);
    }

    srv_srv_da_adp_mem_free(full_filename);

    /* complete full path */
    if(para->fileext[0] != L'\0')
    {
        kal_wsprintf(filepath, "%c:\\%w%w.%w", 
                     para->drv, 
                     para->folder, 
                     para->filename,
                     para->fileext);
    }
    else
    {
        /* no ext */
        kal_wsprintf(filepath, "%c:\\%w%w",
                     para->drv, 
                     para->folder, 
                     para->filename);
    }

    if (para->original_filepath != NULL &&
        mmi_wcsicmp(filepath, para->original_filepath) == 0)
    {
        /* Path is not changed, following checkings are unnecessary */
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
    }
    
    /* Create folder for the file */
	
		
		result = srv_da_util_create_yt_file_dir(filepath, MMI_TRUE);
	
    if (result < 0)
    {
        srv_da_adp_popup(0, result, SRV_DA_POPUP_TYPE_FS_ERROR);
        return SRV_DA_SCR_SELECT_STORAGE_CAUSE_FS_ERROR;
    }

    if (para->filecheck_func != NULL &&
        para->filecheck_func(filepath, MMI_FALSE))
    {
        /* User did not choose the name, decide a new name automatically */
        srv_da_util_get_clear_filepath(filepath, para->filecheck_func);
    }

    /* if all ok, call back to User */
    return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
}

#ifndef MMI_DA_PLUTO_SLIM
void srv_da_decide_yt_filepath (U32 arg, srv_da_storage_parameter_struct *para, srv_da_action_enum job_type, srv_da_scr_storage_callback_type callback)
{
    U16 filepath[SRV_FMGR_PATH_MAX_LEN + 1] ={0, };
   
        if (srv_da_select_storage_final_ext (para, filepath) == SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE)
        {
			callback (arg, filepath, MMI_FALSE, MMI_TRUE, NULL);
        }
        else
        {
			return;
        }
   
}
#endif
srv_da_scr_select_storage_cause_enum srv_da_decide_filepath_auto (U32 arg, srv_da_storage_parameter_struct *para, srv_da_action_enum job_type, srv_da_scr_storage_callback_type callback)
{
    U16 filepath[SRV_FMGR_PATH_MAX_LEN + 1] ={0, };
	srv_da_scr_select_storage_cause_enum storage_error = SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
	storage_error = srv_da_decide_location_auto (para, arg);
    if (storage_error == SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE)
    {
		storage_error = srv_da_select_storage_final (para, filepath);
        if (storage_error == SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE)
        {
			callback (arg, filepath, MMI_FALSE, MMI_TRUE, NULL);
			return SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE;
        }
        else
        {
			return storage_error;
        }
    }
    else
    {
		return storage_error;
    }
}


void srv_da_adp_display_select_storage (U32 arg, srv_da_storage_parameter_struct *para, srv_da_action_enum job_type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_display_select_storage_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SELECT_STORAGE);
    evt.arg = arg;
    evt.para = para;
    evt.job_type = job_type;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* need to execute mmi_da_display_select_storage in MMI */
}

#ifndef MMI_DA_PLUTO_SLIM
void srv_da_adp_oma_handle_http_rsp (U32 arg, U16 status)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_oma_handle_http_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_OMA_HANDLE_HTTP_RSP);
    evt.arg = arg;
    evt.status = status;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* need to execute API void mmi_da_oma_ui_handle_http_rsp (U32 arg, U16 status) in mmi */
}

void srv_da_adp_show_user_auth_screen (U32 arg, srv_da_auth_callback_type auth_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_show_user_auth_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_SHOW_USER_AUTH_SCREEN);
    evt.arg = arg;
    evt.auth_callback = auth_callback;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* Need bypass to mmi void mmi_da_oma_show_auth_screen(void *arg) */
}
#endif

void srv_da_adp_push_process_item (srv_da_push_item_struct *item, srv_da_setting_struct *setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_push_process_item_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_PUSH_PROCESS_ITEM);
    evt.item = item;
    evt.setting = setting;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /*POST event to invoke api mmi_da_srvif_push_process_item (srv_da_push_item_struct *item, srv_da_setting_struct *setting)*/
}


void srv_da_update_job_status(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_update_job_event_struct  evt;
    //srv_da_item_progress_struct info;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_UPDATE_JOB_STATUS);
    evt.job = job;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
/* POST event to invoke mmi_da_update_job_status */
}

#ifdef __DRM_SUPPORT__
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_drm_save_as
 * DESCRIPTION
 *  Show Save screen to save the result of DRM processing.
 * PARAMETERS
 *  job         [IN] Job
 *  drm_method  [IN] Method of the DRM object
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_job_drm_save_as(srv_da_job_struct *job, drm_method_enum drm_method)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_drm_save_as_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_DRM_SAVE_AS);
    evt.job = job;
    evt.drm_method = drm_method;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
/* POST event to invoke mmi_da_job_drm_save_as */
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_popup_drm_error_and_terminate_job
 * DESCRIPTION
 *  
 * PARAMETERS
 *  job             [IN] Job
 *  action          [IN] Download source
 *  result          [IN] Processing result
 *  info            [IN] Resule info
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_popup_drm_error_and_terminate_job(
    srv_da_job_struct *job,
    S32 result,
    const srv_da_drm_result_info_struct *info,
    srv_da_action_enum action)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_discard_pending_popup(job);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if (!srv_da_is_popup_allowed())
    {
        srv_da_drm_popup_info *drm_popup_info;
    
        drm_popup_info = (srv_da_drm_popup_info*)srv_da_adp_mem_allocate(sizeof(srv_da_drm_popup_info));
        drm_popup_info->result = result;
        drm_popup_info->mime_type = job->mime_type;
        drm_popup_info->action = action;
        drm_popup_info->result_info = *info; /* Structure member-wise copy */

        srv_da_adp_popup_for_job(job, SRV_DA_POPUP_TYPE_DRM_PROCESSING_INFO, NULL, MMI_FALSE, drm_popup_info);

        job->state = SRV_DA_JOB_STATE_FAILED;
    }
    else
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
    {
        srv_da_drm_show_process_info(result, job->mime_type, info, action);
        job->state = SRV_DA_JOB_STATE_ABORTED;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_update_content_by_drm_processing_result
 * DESCRIPTION
 *  Update the content of the job by DRM processing result.
 * PARAMETERS
 *  job             [IN] Job
 *  action          [IN] Download source
 *  result          [IN] Processing result
 *  new_filepath    [IN] Result path
 *  new_mime_type   [IN] The MIME type extracted from the DRM file
 *  info            [IN] Resule info
 * RETURNS
 *  FS error code.
 *****************************************************************************/
MMI_BOOL srv_da_job_update_content_by_drm_processing_result(
    srv_da_job_struct *job,
    srv_da_action_enum action,
    S32 result,
    const U16 *new_filepath,
    const applib_mime_type_struct *new_mime_type,
    const srv_da_drm_result_info_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 error_str_id;
    MMI_BOOL terminate_job_right_now;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    terminate_job_right_now = MMI_FALSE;
    error_str_id = 0;

    if (srv_da_is_drm_right(job->mime_type) || srv_da_is_drm_roap(job->mime_type))
    {
        terminate_job_right_now = MMI_TRUE;
    }
    
    if (result != DRM_RESULT_OK)
    {
        if (terminate_job_right_now)
        {
            if (srv_da_is_popup_allowed())
            {
                srv_da_drm_show_process_info(result, job->mime_type, info, action);
            }
        }
        else
        {
            srv_da_popup_drm_error_and_terminate_job(job, result, info, action);
            error_str_id = 0;
        }
        
        goto srv_da_job_drm_processing_failed;
    }
    else
    {
        if (!srv_da_is_drm_content(job->mime_type) && srv_da_is_popup_allowed())
        {
            /* Popup "Rights received" */
            srv_da_drm_show_process_info(result, job->mime_type, info, action);
        }
    }

    /* update mime_type & type_handler */
    if (info->is_archive)
    {
        job->type_handler = srv_da_get_default_mime_type_handler();
    }
    else
    {
        job->mime_type = new_mime_type;
        job->type_handler = srv_da_search_mime_type_handler(job->mime_type);

        if (srv_da_is_drm_file(job->mime_type))
        {
            /* we do not support drm + drm + drm ..... now */
            error_str_id = SRV_DA_GLOBAL_DRM_INVALID_FORMAT;
            goto srv_da_job_drm_processing_failed;
        }
    }

    if (terminate_job_right_now)
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
        srv_da_util_file_delete(new_filepath);
        return MMI_FALSE;
    }

    return MMI_TRUE;

srv_da_job_drm_processing_failed:

    if (error_str_id > 0)
    {
        if (terminate_job_right_now)
        {
            srv_da_adp_popup(error_str_id, 0, SRV_DA_POPUP_TYPE_ERROR);
            job->state = SRV_DA_JOB_STATE_ABORTED;
        }
        else
        {
            srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, error_str_id, MMI_TRUE);
        }    
    }
    else
    {
        if (job->state != SRV_DA_JOB_STATE_ABORTED &&
            job->state != SRV_DA_JOB_STATE_FAILED)
        {
            job->state = SRV_DA_JOB_STATE_ABORTED;
        }
    }

    if (new_filepath != NULL)
    {
        srv_da_util_file_delete(new_filepath);
    }

    return MMI_FALSE;
}
#endif /* __DRM_SUPPORT__ */


void srv_da_adp_click_job(srv_da_job_struct *job)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job);
    switch(job->state)
    {
        case SRV_DA_JOB_STATE_DOWNLOADING:
        case SRV_DA_JOB_STATE_ABORTING:
        case SRV_DA_JOB_STATE_PROCESSING:
        case SRV_DA_JOB_STATE_COMPLETED:
        case SRV_DA_JOB_STATE_FAILED:
            srv_da_adp_display_job_list(job, MMI_FALSE);
	        break;
        case SRV_DA_JOB_STATE_PAUSED:
        
        #ifdef __MMI_DA_RESUME__
            /* Resume then display */
            srv_da_adp_display_job_list(job, MMI_FALSE);

            if(srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) + 
                srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
            {
                break;
            }
            
            /* job may be removed after display */
            if(srv_da_is_job_valid(job))
            {
                //job->reporting = MMI_FALSE;
                srv_da_job_resume(job);
            }
        #endif /* __MMI_DA_RESUME__ */

            break;
		case SRV_DA_JOB_STATE_RESUMING: /*Vikas*/
			break;

        default:
            MMI_ASSERT(0);
            break;
    }
    
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
}


void srv_da_adp_curr_job_aborted_callback (srv_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_curr_job_aborted_event_struct  evt;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_send_download_info_ind();

    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_JOB_ABORTED_CALLBACK);
    evt.job = job;
    evt.string_id = string_id;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /*POST EVENT TO INVOKE void mmi_da_curr_job_aborted_callback(srv_da_job_struct* job, U16 string_id) */
}



MMI_BOOL srv_da_free_job_and_remove_screens (srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret;
    srv_da_remove_scr_event_struct  evt;
	S32 index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	index = srv_da_get_job_index(job);
    ret = srv_da_free_job(job);
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_REMOVE_JOB_SCREENS);
    evt.job = job;
	evt.is_in_job_screen = ret;
	evt.index = index;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* POST event to invoke remove screen in MMI */
    return ret;
}





srv_da_job_struct * srv_da_get_list_job(void)
{
	return g_srv_da_context.list_job;
}
/*****************************************************************************
 * FUNCTION
 *  srv_da_shutdown_proc
 * DESCRIPTION
 *  To deinit job for shutdown
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_da_shutdown_proc(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16 *filepath;
    srv_da_job_struct *job;
    S32 result;
	S8 buf_filepath[(SRV_FMGR_PATH_MAX_LEN + 1) * ENCODING_LENGTH];
	U16 *ptr;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	
    for (job = g_srv_da_context.list_job; job != NULL; job = job->next_job)
    {
        switch (job->state)
        {
            case SRV_DA_JOB_STATE_INIT:
            case SRV_DA_JOB_STATE_COMPLETED:
                /* Ignore */

            case SRV_DA_JOB_STATE_ABORTING:
            case SRV_DA_JOB_STATE_DOWNLOADING:
            case SRV_DA_JOB_STATE_RESUMING:
                /* The file is locked by DAS or WPS */
				if (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
				{
					filepath = job->op->get_filepath(job);

					if (filepath != NULL)
					{
						mmi_ucs2cpy((PS8) buf_filepath, (PS8) filepath);
						ptr = srv_da_util_get_filename((U16*)buf_filepath);
						*ptr = 0;
						result = FS_Delete(filepath);
						result = FS_XDelete((UI_string_type) buf_filepath,
											FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE,
											NULL,
											0);
						MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_SHUTDOWN_CLEAN, job->state, 'Y', result);
					 }
					else
					{
                    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_SHUTDOWN_CLEAN, job->state, 'N', -10000);
					}

				}

                MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_SHUTDOWN_CLEAN, job->state, 'N', 0);
                
                break;

            default:
                filepath = job->op->get_filepath(job);

                if (filepath != NULL)
                {
					if (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
					{
						mmi_ucs2cpy((PS8) buf_filepath, (PS8) filepath);
						ptr = srv_da_util_get_filename((U16*)buf_filepath);
						*ptr = 0;
						result = FS_XDelete((UI_string_type) buf_filepath,
											FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE,
											NULL,
											0);
					}
					else
                    result = FS_Delete(filepath);
                    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_SHUTDOWN_CLEAN, job->state, 'Y', result);
                }
                else
                {
                    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_SHUTDOWN_CLEAN, job->state, 'N', -10000);
                }
            
                break;
        }
    }

    return MMI_RET_OK;
}



/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
mmi_ret srv_da_usb_mode_on(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_usb_mode_on);

    /* The g_mmi_da_context.setuping_job will be cancelled when the confirm is deleted */

    srv_da_suspend_all_job(SRV_DA_ERROR_FILE_ACCESS);
	return MMI_RET_OK;
}

/* PDP Switch Begin */
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
mmi_ret srv_da_bearer_available(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //sahil to do later DA_TRACE_FUNC(srv_da_bearer_available);

    /* The g_mmi_da_context.setuping_job will be cancelled when the confirm is deleted */
#ifndef MMI_DA_PLUTO_SLIM
    srv_da_suspend_and_resume_all_download();
	srv_da_pdp_switch_cause(MMI_TRUE);
#endif
	return MMI_RET_OK;
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
mmi_ret srv_da_bearer_unavailable(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //sahil to doDA_TRACE_FUNC(srv_da_bearer_unavailable);
#ifndef MMI_DA_PLUTO_SLIM
    /* PDP Switch from One SIM-->second SIM */
	g_srv_da_context.cause = MMI_TRUE;   
#endif
	return MMI_RET_OK;

}
#ifndef MMI_DA_PLUTO_SLIM
MMI_BOOL srv_da_is_pdp_switching(void)
{
	return g_srv_da_context.cause;
}

void srv_da_pdp_switch_cause(MMI_BOOL flag)
{
	g_srv_da_context.cause = flag;
}
#endif
/* PDP Switch END */

/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_title_icon
 * DESCRIPTION
 *  Get the title icon of a download.
 * PARAMETERS
 *  job     [IN] Download job. If NULL, returns a general icon.
 * RETURNS
 *  Icon ID.
 *****************************************************************************/
U16 srv_da_job_get_title_icon(const srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_BROWSER_2__
    return GetRootTitleIcon(SERVICES_WAP_MENU_ID);
#else
    return 0;
#endif
}

srv_da_setting_struct* srv_da_get_setting_buffer(void)
{
    return &g_srv_da_context.setting;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_copy_setting
 * DESCRIPTION
 *  Copy setting to the job.
 * PARAMETERS
 *  job     [IN] Job
 *  setting [IN] Setting
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_copy_setting(srv_da_job_struct* job, const srv_da_setting_struct* setting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP,
        MMI_DA_TRC_SETTING,
        setting->storage,
        (char)setting->drv,
        setting->confirm_push,
        setting->confirm_dispatch,
        setting->do_dispatch);

    job->setting_info.confirm_dispatch = setting->confirm_dispatch;
    job->setting_info.confirm_push = setting->confirm_push;
    job->setting_info.can_minimize = setting->can_minimize;
    job->setting_info.do_dispatch = setting->do_dispatch;
    job->setting_info.filepath_hdlr= setting->filepath_hdlr;
    job->setting_info.report_hdlr= setting->report_hdlr;
}

#ifdef __DRM_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  srv_da_move_as_new_type
 * DESCRIPTION
 *  Move the file of the job to appropriate folder by the MIME type.
 * PARAMETERS
 *  src_filepath            [IN] Source filepath
 *  new_folder              [IN] Folder to move to.
 *  filename_and_ori_ext    [IN] Filename and original extension.
 *  mime_type               [IN] New MIME type
 *  new_filepath_after_moved [OUT] ]New filepath after moved
 * RETURNS
 *  FS error code.
 *****************************************************************************/
S32 srv_da_move_as_new_type(
    const U16 *src_filepath,
    const U16 *new_folder,
    const U16 *filename_and_ori_ext, /* contains extension name */
    const applib_mime_type_struct *mime_type,
    U16 *new_filepath_after_moved)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fs_error;
    U16 *filename;
    U16 *ori_ext;
    U16 *path_to_move;
 
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    fs_error = FS_NO_ERROR;

    path_to_move = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 1) * sizeof(U16));
    filename = (U16*)srv_da_adp_mem_allocate((mmi_wcslen(filename_and_ori_ext) + 1) * sizeof(U16));
    mmi_wcscpy(filename, filename_and_ori_ext);
    ori_ext = srv_da_util_get_extension(filename);
    if (ori_ext != NULL && *(ori_ext - 1) == L'.')
    {
        *(ori_ext - 1) = L'\0';
    }
    
    if (mime_type != NULL && mime_type->file_ext[0] != '\0')
    {
        kal_wsprintf(path_to_move,
            "%c:\\%w%w.%s",
            (S8)src_filepath[0],
            new_folder,
            filename,
            mime_type->file_ext);
    }
    else if (ori_ext != NULL)
    {
        kal_wsprintf(path_to_move,
            "%c:\\%w%w.%w",
            (S8)src_filepath[0],
            new_folder,
            filename,
            ori_ext);
    }
    else /* No extension name */
    {
        kal_wsprintf(path_to_move,
            "%c:\\%w%w",
            (S8)src_filepath[0],
            new_folder,
            filename);
    }

    if (mmi_wcsicmp(src_filepath, path_to_move) != 0)
    {
        /* make sure folder exist */
        fs_error = srv_da_util_create_file_dir(path_to_move, MMI_TRUE);
        
        if(fs_error >= 0)
        {
            srv_da_util_get_clear_filepath(path_to_move, srv_da_does_job_with_filepath_exist);
            fs_error = srv_da_util_file_move(src_filepath, path_to_move, FS_MOVE_KILL);
        }

        if (fs_error == FS_NO_ERROR)
        {
            mmi_wcscpy(new_filepath_after_moved, path_to_move);
        }
    }
    else /* same path */
    {
        mmi_wcscpy(new_filepath_after_moved, src_filepath);
    }


    srv_srv_da_adp_mem_free(filename);
    srv_srv_da_adp_mem_free(path_to_move);

    return fs_error;
}
#endif /* #ifdef __DRM_SUPPORT__ */



/*****************************************************************************
 * FUNCTION
 *  srv_da_set_allow_to_trigger_connection
 * DESCRIPTION
 *  Set the flag of allow_to_trigger_connection.
 *  If current condition disallows to trigger new connection, set the flag
 *  as MMI_FALSE.
 * PARAMETERS
 *  allow       [IN] MMI_TRUE if allowed; otherwise set as MMI_FALSE.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_set_allow_to_trigger_connection(MMI_BOOL allow)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_ALLOW_TO_TRIGGER_CONNECTION, allow);
    
    g_srv_da_context.allow_to_trigger_connection = allow;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_is_allowed_to_trigger_connection
 * DESCRIPTION
 *  To query current condition about whether it is allowed to trigger new connection.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if new connection is allowed.
 *****************************************************************************/
MMI_BOOL srv_da_is_allowed_to_trigger_connection(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_srv_da_context.allow_to_trigger_connection;
}





/*****************************************************************************
 * FUNCTION
 *  srv_da_send_download_info_ind
 * DESCRIPTION
 *  Update the status of DLAgent to WAP by sending DOWNLOAD_INFO_IND
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_send_download_info_ind(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   // U16                                 i = 0;
    srv_da_job_struct                   *job;
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(BROWSER_SUPPORT)
    static S32                          job_count = 0;
    static S32                          active_job_count = 0;
#endif
    S32                                 n_downloading, n_processing;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* calculate active job count */
    n_downloading = n_processing = 0;
    
    for (job = g_srv_da_context.list_job; job != NULL; job = job->next_job)
    {
        if(job->state == SRV_DA_JOB_STATE_DOWNLOADING)
        {
            n_downloading++;
        }
        else if (job->state == SRV_DA_JOB_STATE_PROCESSING)
        {
            n_processing++;
        }
    }

#if defined(__MMI_DA_WPS_UTIL__) && defined(__HTTP_INTERFACE__)
    srv_da_wps_notify_active_downloads((MMI_BOOL)((n_downloading + n_processing) > 0));
#endif

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(BROWSER_SUPPORT)
    /* if either of them is changed */
    if(job_count != g_srv_da_context.list_job_num || active_job_count != n_downloading)
    {
        mmi_da_download_info_ind_struct     *msg;
    
        job_count = g_srv_da_context.list_job_num;
        active_job_count = n_downloading;

        msg = (mmi_da_download_info_ind_struct*) construct_local_para(sizeof(mmi_da_download_info_ind_struct), TD_CTRL);
        msg->job_count = job_count;
        msg->active_job_count = active_job_count;

        srv_da_send_ilm_to_wap(msg, NULL, MSG_ID_MMI_DA_DOWNLOAD_INFO_IND);
    }
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(BROWSER_SUPPORT) */
}


mmi_ret srv_da__fmgr_async_create_folder_result_proc(mmi_event_struct *param)
{
			
	return MMI_RET_OK;
}



void srv_da_adp_init (void)
{
    U16 i;
	S8 buf_createpath[128];
    memset(&g_srv_da_context, 0, sizeof(g_srv_da_context));
    g_srv_da_context.list_job_num = -1;   /* -1 means not initialized */

#if defined(__MMI_DA_WPS_UTIL__)
    srv_da_wps_init();
#endif
    srv_da_push_init();
    srv_da_util_init();
	srv_da_msg_init();
#if defined(BROWSER_SUPPORT) || defined(__MMI_OMA_DD_DOWNLOAD__)
    /* init each module */
    for(i=0;i<SRV_DA_JOB_TYPE_TOTAL;i++)
    {
		if(da_module_table[i])
	        da_module_table[i]->init();
    }
#endif
    /* make sure there is download folder */
    kal_wsprintf((unsigned short*)buf_createpath, "%c:\\%w",SRV_FMGR_PUBLIC_DRV, FMGR_DEFAULT_FOLDER_TEMP);
    FS_XDelete((unsigned short*)buf_createpath,
       FS_FILE_TYPE | FS_DIR_TYPE | FS_RECURSIVE_TYPE,
       NULL,
       0);
srv_fmgr_async_create_folder((const WCHAR*)buf_createpath, 0, srv_da__fmgr_async_create_folder_result_proc, NULL);		

}




/*****************************************************************************
 * FUNCTION
 *  srv_da_is_popup_allowed
 * DESCRIPTION
 *  In some conditions, popup is not allowed. This function is used to determine
 *  this condition.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if popup is allowed
 *****************************************************************************/
MMI_BOOL srv_da_is_popup_allowed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL allowed;
    MMI_BOOL is_incoming_call, is_outgoing_call;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    is_incoming_call = (MMI_BOOL)(srv_ucm_query_call_count(SRV_UCM_INCOMING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) > 0);
    is_outgoing_call = (MMI_BOOL)(srv_ucm_query_call_count(SRV_UCM_OUTGOING_STATE, SRV_UCM_CALL_TYPE_ALL, NULL) > 0);    
    allowed = (MMI_BOOL)(!is_incoming_call && !is_outgoing_call);
    
    return allowed;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_is_new_screen_allowed
 * DESCRIPTION
 *  In some situation it is disallowed to entry a new screen (e.g. in-call).
 *  The screen is not only a timing-constraint notification popup and may interact with user.
 *  This function is used to check this situation.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if popup is allowed.
 *****************************************************************************/
MMI_BOOL srv_da_is_new_screen_allowed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifndef __OP01__
#if defined(__MMI_BACKGROUND_CALL__)
    if (srv_da_is_in_voice_call() && !srv_ucm_is_background_call())
    {
        return MMI_FALSE;
    }
#else
    if (srv_da_is_in_voice_call())
    {
        return MMI_FALSE;
    }
#endif
#endif
    return srv_da_is_popup_allowed();
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_can_receive_file
 * DESCRIPTION
 *  In some situation receiving a file should be blocked. (e.g. 2G voice call)
 *  This function is used to check this situation.
 * PARAMETERS
 *  void
 * RETURNS
 *  MMI_TRUE if receiving a file is allowed.
 *****************************************************************************/
MMI_BOOL srv_da_can_receive_file(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL new_screen_allowed, no_download_in_init = MMI_FALSE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    new_screen_allowed = srv_da_is_new_screen_allowed();
   if (g_srv_da_context.setuping_job == NULL);
		no_download_in_init = MMI_TRUE;
    if (!no_download_in_init)
    {
        srv_da_adp_popup_for_error_code_with_callback (SRV_DA_IERROR_ANOTHER_JOB, NULL);
    }

	if (!new_screen_allowed)
    {
        srv_da_adp_popup_for_error_code_with_callback (SRV_DA_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL, NULL);
    }

    DA_TRACE_FUNC2(srv_da_can_receive_file, new_screen_allowed, no_download_in_init);

	if (new_screen_allowed && no_download_in_init)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
void srv_da_job_set_notify_callback(srv_da_job_struct* job, srv_da_dl_report_callback cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!g_srv_da_context.setuping_job)
        return;
    if(job != g_srv_da_context.setuping_job)
    {
        MMI_ASSERT(0);
        return;
    }

    g_srv_da_context.setuping_cb = cb;
}
#endif

#define ____EXPORTED_API____


#define JOB_CONTROL

/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_new_unique_id
 * DESCRIPTION
 *  Allocate a unique ID
 * PARAMETERS
 *  void
 * RETURNS
 *  An unique ID
 *****************************************************************************/
U16 srv_da_job_get_new_unique_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    static U16 next_id = 0;
    U16 return_id;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    return_id = next_id;
    next_id = (next_id + 1) & 0x7fff;

    return return_id;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_init_job_list
 * DESCRIPTION
 *  Initialize job list struct.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_init_job_list(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* lazy init job list */
    if(g_srv_da_context.list_job_num == -1)
    {
        /* read job list from NVRAM */

        g_srv_da_context.list_job_num = 0;
    }
}


S32 srv_da_get_curr_job_count (void)
{
    srv_da_init_job_list();
    return g_srv_da_context.list_job_num;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_create
 * DESCRIPTION
 *  Create a job. If a job is created, g_srv_da_context.setuping_job will be assigned.
 *  Be sure to call srv_da_job_start() or srv_da_job_cancel() after a job
 *  is created.
 * PARAMETERS
 *  type    [IN] Job type
 *  obj     [IN] Value of job->data_ptr
 * RETURNS
 *  An empty job structure
 *****************************************************************************/
srv_da_job_struct* srv_da_job_create(srv_da_job_type_enum type, void *obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job = NULL;
    U32 job_count;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_init_job_list();

    if(g_srv_da_context.setuping_job)
    {
        g_srv_da_context.last_error = SRV_DA_IERROR_ANOTHER_JOB;
        goto end_create;
    }

#if (defined(__COSMOS_MMI_PACKAGE__) && (defined(__MMI_DLA_SLIM__) || defined(SLIM_WAP_MMS)))
	
		srv_da_delete_completed_failed();
	
#endif
    if(g_srv_da_context.list_job_num >= MMI_DA_MAX_JOB)
    {
        g_srv_da_context.last_error = SRV_DA_IERROR_EXCEED_MAX_JOB;
        goto end_create;
    }

    job_count = srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) +
                srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PROCESSING) + 
                srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PAUSED) +
				srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_FAILED) +
				srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_RESUMING);
    if(job_count >= MMI_DA_MAX_DL)
    {
        g_srv_da_context.last_error = SRV_DA_IERROR_EXCEED_MAX_DL;
        goto end_create;
    }


    return srv_da_job_create_ex(type, obj);

end_create:
    DA_TRACE_FUNC3(srv_da_job_create, type, (U32)job, g_srv_da_context.last_error);
    return job;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_create_ex
 * DESCRIPTION
 *  Create a job. If a job is created, g_srv_da_context.setuping_job will be assigned.
 *  Be sure to call srv_da_job_start() or srv_da_job_cancel() after a job
 *  is created. This function will not check max job number.
 * PARAMETERS
 *  type    [IN] Job type
 *  obj     [IN] Value of job->data_ptr
 * RETURNS
 *  An empty job structure
 *****************************************************************************/
srv_da_job_struct* srv_da_job_create_ex(srv_da_job_type_enum type, void *obj)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job = NULL;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_init_job_list();

#if defined(BROWSER_SUPPORT) || defined(__MMI_OMA_DD_DOWNLOAD__)
    
    if(g_srv_da_context.setuping_job)
    {
        g_srv_da_context.last_error = SRV_DA_IERROR_ANOTHER_JOB;
        goto end_create;
    }
    
    job = (srv_da_job_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_job_struct));
    if(!job)
    {
        g_srv_da_context.last_error = SRV_DA_IERROR_NO_MEMORY;
        goto end_create;
    }
    
    memset(job, 0, sizeof(srv_da_job_struct));
    job->data_ptr = obj;
    job->type = type;
    //job->state = SRV_DA_JOB_STATE_INIT;
    job->notified = SRV_DA_NOTIFIED_NONE;
    job->pending_popup.type = SRV_DA_POPUP_TYPE_NONE;
    job->pending_popup.string = NULL;
    job->pending_popup.free_string_after_popup = MMI_FALSE;
#if defined (__MMI_NCENTER_SUPPORT__)
	job->notify_handle = NULL;
#endif
    job->op = da_module_table[job->type];
#ifdef __MMI_DA_USER_SELECT_DOWNLOAD_LOCATION__
    job->saved_to_my_fav = MMI_FALSE;
#endif
    if (type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD || type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
	{
		//g_srv_da_context.setuping_job = NULL;
		job->state = SRV_DA_JOB_STATE_CREATED;
	}
else
	{

		job->state = SRV_DA_JOB_STATE_INIT;
	}
    g_srv_da_context.setuping_job = job;
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    g_srv_da_context.setuping_cb = NULL;
#endif

#if defined(__MMI_DA_WPS_UTIL__) && defined(__HTTP_INTERFACE__)
    srv_da_wps_notify_active_downloads(MMI_TRUE);
#endif

end_create:
    DA_TRACE_FUNC3(srv_da_job_create, type, (U32)job, g_srv_da_context.last_error);

#endif /*defined(BROWSER_SUPPORT) || defined(__MMI_OMA_DD_DOWNLOAD__) */

    return job;
}



#ifdef __MMI_VIDEO_PDL__
/*****************************************************************************
 * FUNCTION
 *  srv_da_stop_pdl
 * DESCRIPTION
 *  Stop reporting.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  SRV_DA_SUCCESS / SRV_DA_ERROR_FAIL
 *****************************************************************************/
S32 srv_da_stop_pdl(S32 session_id)
{
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    /* only stop notification */
    job = g_srv_da_context.list_job;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_STOP_PDL, session_id);

    while (job != NULL)
    {
        if(DA_JOB_UNIQUE_ID(job) == session_id)
        {
            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_API_JOB_STATE, session_id, job->state);
        
            /* Stop notification */
            job->reporting = MMI_FALSE;
			if (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
			{
				if (job->state == SRV_DA_JOB_STATE_DOWNLOADING)
				{
				job->state = SRV_DA_JOB_STATE_ABORTING;
				job->op->stop(job, 
                         SRV_DA_JOB_STATE_DOWNLOADING,
                         MMI_FALSE,
                         srv_da_suspended_in_background_callback);
			}
			}
            return SRV_DA_SUCCESS;
        }
        
        job = job->next_job;
    }
    
    DA_TRACE_FUNC2(srv_da_stop_pdl, session_id, 0);
    
    return SRV_DA_ERROR_FAIL;    
   

#else

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_STOP_PDL, session_id);

    return srv_da_stop_dl(session_id);
    
#endif
}
#endif



/*****************************************************************************
 * FUNCTION
 *  srv_da_stop_dl
 * DESCRIPTION
 *  Stop download. This function is only useful for
 *  DOWNLOADING, COMPLETED and PAUSED job. Once a job is stopped, it is removed
 *  from the job list permanently.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  SRV_DA_SUCCESS / SRV_DA_ERROR_FAIL
 *****************************************************************************/
S32 srv_da_stop_dl(S32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_STOP_DL, session_id);

    job = g_srv_da_context.list_job;
    while(job)
    {
        if(DA_JOB_UNIQUE_ID(job) == session_id)
        {
            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_API_JOB_STATE, session_id, job->state);
            job->reporting = MMI_FALSE;
        
            switch (job->state)
            {
                case SRV_DA_JOB_STATE_DOWNLOADING:
                    srv_da_curr_job_do_abort(job);
                    return SRV_DA_SUCCESS;
                    
                case SRV_DA_JOB_STATE_COMPLETED:
                case SRV_DA_JOB_STATE_PAUSED:
				case SRV_DA_JOB_STATE_RESUMING:
                case SRV_DA_JOB_STATE_FAILED:
                    srv_da_free_job_and_remove_screens(job);
                    return SRV_DA_SUCCESS;

                default:
                    break;
            }
            
            break;
        }
        job = job->next_job;
    }
    
    DA_TRACE_FUNC2(srv_da_stop_dl, 0, session_id);
    return SRV_DA_ERROR_FAIL;    
}

#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_remove_dl
 * DESCRIPTION
 *  Remove a completed item from download list.
 *  For some settings, the item will stay on the list after download completed.
 *  This function is provided for the applications who want to remove it from
 *  the list.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  SRV_DA_SUCCESS / SRV_DA_ERROR_FAIL
 *****************************************************************************/
S32 srv_da_remove_dl(S32 session_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_REMOVE_DL, session_id);

    job = g_srv_da_context.list_job;
    while (job != NULL)
    {
        if (DA_JOB_UNIQUE_ID(job) == session_id)
        {
            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_API_JOB_STATE, session_id, job->state);

            switch (job->state)
            {
                case SRV_DA_JOB_STATE_DOWNLOADING:
                    srv_da_curr_job_do_abort(job);
                    return SRV_DA_SUCCESS;
                    
                case SRV_DA_JOB_STATE_COMPLETED:
                case SRV_DA_JOB_STATE_PAUSED:
                case SRV_DA_JOB_STATE_FAILED:
				case SRV_DA_JOB_STATE_RESUMING:
                    srv_da_free_job_and_remove_screens(job);
                    return SRV_DA_SUCCESS;

                default:
                    break;
            }
            
            break;
        }
        
        job = job->next_job;
    }
    
    DA_TRACE_FUNC2(srv_da_remove_dl, session_id, 0);
    
    return SRV_DA_ERROR_FAIL;
}
#endif

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__


/*****************************************************************************
 * FUNCTION
 *  srv_da_resume_dl
 * DESCRIPTION
 *  Resume a download. NOTE that it will show "Please wait" screen!
 *  We recommend DO NOT USE THIS FUNCTION.
 * PARAMETERS
 *  session_id      [IN] Session ID
 * RETURNS
 *  SRV_DA_SUCCESS / SRV_DA_ERROR_FAIL
 *****************************************************************************/
S32 srv_da_resume_dl(S32 session_id)
{
#ifdef __MMI_DA_RESUME__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_RESUME_DL, session_id);

    job = g_srv_da_context.list_job;
    while(job)
    {
        if(DA_JOB_UNIQUE_ID(job) == session_id)
        {
            MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_API_JOB_STATE, session_id, job->state);
        
            if(job->state == SRV_DA_JOB_STATE_PAUSED && job->op->resume != NULL)
            {
                if((srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) + srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_RESUMING)) < MMI_DA_MAX_DL) /*Vikas*/
                {
                    DA_TRACE_FUNC2(srv_da_resume_dl, session_id, 1);
                    srv_da_job_resume(job);
                    return SRV_DA_SUCCESS;
                }
            }
            break;
        }
        job = job->next_job;
    }
    
    DA_TRACE_FUNC2(srv_da_resume_dl, session_id, 0);
    
#endif /* __MMI_DA_RESUME__ */

    return SRV_DA_ERROR_FAIL;    
}
#endif



MMI_BOOL srv_da_dispatch_http_job(srv_da_job_struct *job)
{
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
if (job->type ==SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
{
	srv_da_normal_dl_job_struct *job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	if (job_data->dispatch_callback)
	{
		return MMI_TRUE;
	}
	return MMI_FALSE;
}
	else
		return MMI_FALSE;
#else
	return MMI_FALSE;
#endif
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_start
 * DESCRIPTION
 *  Insert a job in INIT to the download list.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  Succeed
 *****************************************************************************/
MMI_BOOL srv_da_job_start(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *i_job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_job_start);

    /* Put current setupping job into Job List */
    
    if(!g_srv_da_context.setuping_job)
        return MMI_FALSE;
    if(job != g_srv_da_context.setuping_job)
    {
        MMI_ASSERT(0);
        return MMI_FALSE;
    }

    MMI_ASSERT((job->state == SRV_DA_JOB_STATE_DOWNLOADING) || (job->state == SRV_DA_JOB_STATE_WAITING));

    if(!g_srv_da_context.list_job)
    {
        MMI_ASSERT(g_srv_da_context.list_job_num == 0);
        g_srv_da_context.list_job = job;
    }
    else
    {
        /* check if job exist, and find the tail */
        i_job = g_srv_da_context.list_job;
        while(1)
        {
            if(i_job == job)
            {
                /* exist, leave */
                goto end;
            }
            if(!i_job->next_job)
                break;
            i_job = i_job->next_job;
        }

        /* not exist */
        MMI_ASSERT(!job->next_job);
        MMI_ASSERT(!job->prev_job);

        /* add to tail */
        job->prev_job = i_job;
        i_job->next_job = job;
    }
if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)

{	g_srv_da_context.list_job_num++;
    g_srv_da_context.job_list_updated = MMI_TRUE;
}

    /* send download info indication */
    srv_da_send_download_info_ind();

    if (job->setting_info.report_hdlr != NULL)
		job->reporting = MMI_TRUE;

end:
#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if(g_srv_da_context.setuping_cb)
        g_srv_da_context.setuping_cb(MMI_TRUE);
    g_srv_da_context.setuping_cb = NULL;
#endif

    g_srv_da_context.setuping_job = NULL;

    job->was_stopped_by_upper_layer = MMI_FALSE;
    
    return MMI_TRUE;
}


#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_resume
 * DESCRIPTION
 *  Resume a paused download.
 * PARAMETERS
 *  job     [IN] The target job.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_job_resume(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16*  filepath = NULL;
    FS_HANDLE   filehandle = 0;
	//U16 error_id = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    filepath = job->op->get_filepath(job);
    filehandle = FS_Open((U16*)filepath, FS_READ_ONLY);
    
    if(filehandle >= 0)
    {      

        FS_Close(filehandle);
        
    }
	else
	{
		//error_id = srv_fmgr_fs_error_get_string(filehandle);
		srv_da_adp_popup(0, filehandle, SRV_DA_POPUP_TYPE_FS_ERROR);
		return;
	}

	if (job->state == SRV_DA_JOB_STATE_RESUMING)
		return;
    if ((job->state == SRV_DA_JOB_STATE_PAUSED) || (job->state == SRV_DA_JOB_STATE_FAILED) || (job->state == SRV_DA_JOB_STATE_PAUSED_WAITING))
    {
        if (job->op->resume != NULL)
        {
            job->was_stopped_by_upper_layer = MMI_FALSE;
			job->state = SRV_DA_JOB_STATE_RESUMING;
            job->op->resume(job);
        }
    }
}
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_destroy
 * DESCRIPTION
 *  Destroy a job.
 * PARAMETERS
 *  job     [IN] The target job.
 * RETURNS
 *  Successfully destroyed.
 *****************************************************************************/
MMI_BOOL srv_da_job_destroy(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_EXT_ASSERT(job->state != SRV_DA_JOB_STATE_DOWNLOADING, job->state, 0, 0);
    
    DA_TRACE_FUNC1(srv_da_job_destroy, job->state);

    return srv_da_free_job_and_remove_screens(job);
}





/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_job_by_type_and_id
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_job_get_job_by_id(U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(id == DA_JOB_GET_ID(job))
            return job;

        job = job->next_job;
    }
    return NULL;
}
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_job_by_type_and_id
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
U32  srv_da_get_job_acc_id(U32 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = g_srv_da_context.list_job;
    while(job)
    {
        if(job->type == type)
		{
			job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;          
			return job_data->acc_id;
		}

        job = job->next_job;
    }
    return NULL;
}
#endif
#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_job_by_type_and_id
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_job_get_job_by_type_and_id(U32 id, U32 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if((job->type == type) && (id == DA_JOB_GET_ID(job)))
            return job;

        job = job->next_job;
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_get_job_by_type_and_index
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_job_get_job_by_type_and_index(U32 index, U32 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    U16 i = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(job->type == type)
        {
            if (index == i)
            {
                return job;
            }
            i++;
        }

        job = job->next_job;
    }
    return NULL;
}

/*****************************************************************************
 * FUNCTION
 *  srv_da_find_job
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
MMI_BOOL srv_da_find_java_job(applib_mime_subtype_enum criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
	applib_mime_subtype_enum mime_subtype;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
	
    while(job)
    {
		if (job->mime_type != NULL)
		{
			mime_subtype = job->mime_type->mime_subtype;
			if (mime_subtype == MIME_SUBTYPE_JAD || mime_subtype == MIME_SUBTYPE_JAR)
			{
			if(criteria  == MIME_SUBTYPE_JAD || criteria == MIME_SUBTYPE_JAR)
            return MMI_TRUE;
			}
		}
		 job = job->next_job;
	}
    return MMI_FALSE;
}

#endif
/*****************************************************************************
 * FUNCTION
 *  srv_da_find_job
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_find_job(srv_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(func(job, criteria))
            return job;

        job = job->next_job;
    }
    return NULL;
}

#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_find_all_job
 * DESCRIPTION
 *  Find a job by the dicision function & the criteria.
 * PARAMETERS
 *  func        [IN] Decision function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_find_all_job(srv_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct  *job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(func(job, criteria))
            return job;

        job = job->next_job;
    }
    return NULL;
}
#endif

#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_find_job_by_filepath
 * DESCRIPTION
 *  Find a job by the filepath.
 * PARAMETERS
 *  filepath    [IN] Filepath
 *  bpopup      [IN] Popup error if found.
 * RETURNS
 *  The job. NULL if not found.
 *****************************************************************************/
srv_da_job_struct* srv_da_find_job_by_filepath(const U16* filepath, MMI_BOOL bpopup)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    
    while(job != NULL)
    {
        if(mmi_wcsicmp(filepath, job->op->get_filepath(job)) == 0)
        {
            if(bpopup)
            {
                srv_da_adp_popup(SRV_DA_JOB_EXIST, 0, SRV_DA_POPUP_TYPE_ERROR);
            }
            
            return job;
        }

        job = job->next_job;
    }
    return NULL;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  srv_da_job_match_filepath_func
 * DESCRIPTION
 *  Check whether the job's filepath is the same to given.
 * PARAMETERS
 *  job         [IN] Job to be determined
 *  criteria    [IN] Filepath
 * RETURNS
 *  MMI_TRUE if the same.
 *****************************************************************************/
static MMI_BOOL srv_da_job_match_filepath_func(const srv_da_job_struct *job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16 *job_filepath;
    const U16 *cmp_filepath;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_filepath = job->op->get_filepath(job);

    if (job_filepath != NULL)
    {
        cmp_filepath = (const U16*)criteria;

        if (mmi_wcsicmp(job_filepath, cmp_filepath) == 0)
        {
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_does_job_with_filepath_exist
 * DESCRIPTION
 *  Check whether the job with given filepath exists
 * PARAMETERS
 *  filepath        [IN] Filepath
 *  can_popup_msg   [IN] Popup error if found.
 * RETURNS
 *  Found
 *****************************************************************************/
MMI_BOOL srv_da_does_job_with_filepath_exist(const U16 *filepath, MMI_BOOL can_popup_msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = srv_da_find_job(srv_da_job_match_filepath_func, (U32)filepath);

    if (job == NULL && g_srv_da_context.setuping_job != NULL)
    {
        if (srv_da_job_match_filepath_func(g_srv_da_context.setuping_job, (U32)filepath))
        {
            job = g_srv_da_context.setuping_job;
        }
    }

    if (job != NULL && can_popup_msg)
    {
        srv_da_adp_popup(SRV_DA_JOB_EXIST, 0, SRV_DA_POPUP_TYPE_ERROR);
    }

	if (job != NULL)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_count_job
 * DESCRIPTION
 *  Count the number of jobs match the condition.
 * PARAMETERS
 *  func        [IN] Condition function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The number of jobs match.
 *****************************************************************************/
U32 srv_da_count_job(srv_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;
    U32                 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
		{
        if(func(job, criteria))
		{
            count++;

		}
		}

        job = job->next_job;
    }
    return count;
}
#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_count_job
 * DESCRIPTION
 *  Count the number of jobs match the condition.
 * PARAMETERS
 *  func        [IN] Condition function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The number of jobs match.
 *****************************************************************************/
U32 srv_da_count_special_job(srv_da_job_match_funcptr_type func, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;
    U32                 count = 0;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(func(job, criteria))
		{
			if (criteria == SRV_DA_JOB_STATE_DOWNLOADING)
			{				
				if (job->setting_info.can_minimize)
				{
					count++;
				}
			}
			else
            count++;

		}

        job = job->next_job;
    }
    return count;
}

#endif
/*****************************************************************************
 * FUNCTION
 *  srv_da_is_job_valid
 * DESCRIPTION
 *  Check whether the job in init or in download list.
 * PARAMETERS
 *  comp_job    [IN] Job
 * RETURNS
 *  MMI_TRUE if valid.
 *****************************************************************************/
MMI_BOOL srv_da_is_job_valid(const srv_da_job_struct* comp_job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!comp_job)
        return MMI_FALSE;
    
    if(g_srv_da_context.setuping_job == comp_job)
        return MMI_TRUE;
    
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(comp_job == job)
            return MMI_TRUE;

        job = job->next_job;
    }
    return MMI_FALSE;
}


#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_is_job_valid
 * DESCRIPTION
 *  Check whether the job in init or in download list.
 * PARAMETERS
 *  comp_job    [IN] Job
 * RETURNS
 *  MMI_TRUE if valid.
 *****************************************************************************/
MMI_BOOL srv_da_does_job_exist(const srv_da_job_struct* comp_job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(!comp_job)
        return MMI_FALSE;
    
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(comp_job == job)
            return MMI_TRUE;

        job = job->next_job;
    }
    return MMI_FALSE;
}
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_da_get_last_error
 * DESCRIPTION
 *  Get last error code. This code is only used for erros of job creation currently.
 * PARAMETERS
 *  void
 * RETURNS
 *  Error code
 *****************************************************************************/
U32 srv_da_get_last_error(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return g_srv_da_context.last_error;
}

#ifndef MMI_DA_PLUTO_SLIM
srv_da_job_struct* srv_da_get_nth_job_in_downloading_list(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    U16 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(index >= g_srv_da_context.list_job_num || index < 0)
        return NULL;
    job = g_srv_da_context.list_job;
    while (job)
    {
        if (job->state != SRV_DA_JOB_STATE_COMPLETED && job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
        {
            if (index == i)
            {
                return job;
            }
            i++;
        }
        job = job->next_job;
    }
    return NULL;
}


srv_da_job_struct* srv_da_get_nth_job_in_completed_list(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    U16 i = 0;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(index >= g_srv_da_context.list_job_num || index < 0)
        return NULL;
    job = g_srv_da_context.list_job;
    while (job)
    {
        if (job->state == SRV_DA_JOB_STATE_COMPLETED && job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
        {
            if (index == i)
            {
                return job;
            }
            i++;
        }
        job = job->next_job;
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_get_nth_job
 * DESCRIPTION
 *  Get job by index.
 * PARAMETERS
 *  index   [IN] Index
 * RETURNS
 *  The job. NULL if not found or bad index.
 *****************************************************************************/
srv_da_job_struct* srv_da_get_nth_job(S32 index)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(index >= g_srv_da_context.list_job_num || index < 0)
        return NULL;
    
    job = g_srv_da_context.list_job;
    while(index > 0 && job)
    {
		if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
        index --;
        job = job->next_job;
    }
    //MMI_ASSERT(job);
    return job;
}
#endif
S32 srv_da_get_job_highlight_index(void)
{
	return g_srv_da_context.job_list_highlight_index;
}

MMI_BOOL srv_da_job_list_updated(void)
{
	return g_srv_da_context.job_list_updated;
}

S32 srv_da_get_job_list_num(void)
{
	return g_srv_da_context.list_job_num;
}

MMI_BOOL srv_da_get_popup_triggere(void)
{
	return g_srv_da_context.popup_triggered;
}

void srv_da_job_set_list_updated(MMI_BOOL flag)
{
	g_srv_da_context.job_list_updated = flag;
}



void srv_da_set_curr_job(srv_da_job_struct* para)
{
	g_srv_da_context.curr_job = para;
}
srv_da_job_struct* srv_da_get_curr_job(void)
{
	return g_srv_da_context.curr_job;
}

void srv_da_set_popup_triggerr(MMI_BOOL flag)
{
	g_srv_da_context.popup_triggered = flag;
}

srv_da_job_struct* srv_da_get_first_job_of_type_in_state (U16 state, U16 job_type)
{
    srv_da_job_struct *job = NULL;
    if(!g_srv_da_context.list_job_num)
        return NULL;
    job = g_srv_da_context.list_job;
    while (job)
    {
        if (job->state == state)
        {
            if (job->type == job_type)
            {
                return job;
            }
        }
        job = job->next_job;
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_get_job_index
 * DESCRIPTION
 *  Get the index of given job.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  Index. -1 if the job is not in the list.
 *****************************************************************************/
S32 srv_da_get_job_index(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 index = -1;
    srv_da_job_struct* job_in;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job_in = g_srv_da_context.list_job;
    while(job_in)
    {
        index ++;
        if(job_in == job)
            return index;
        job_in = job_in->next_job;
    }
    return -1;
}

U32 srv_da_get_current_job_data_size(U32 arg)
{
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	if (job->type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
	{
	srv_da_normal_dl_job_struct *job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	return job_data->curr_size;
	}
	else
		return 0;
	

}

srv_da_job_struct* srv_da_get_first_job (void)
{
    return g_srv_da_context.list_job;
}

srv_da_job_struct* srv_da_get_current_job (U32 arg)
{
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	return job;
}

U32 srv_da_get_current_job_state (U32 arg)
{
    srv_da_job_struct *job = (srv_da_job_struct *)arg;
	return job->state;
}
U32 srv_da_get_current_job_type (U32 arg)
{
    srv_da_job_struct *job = (srv_da_job_struct *)arg;
	return job->type;
}
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
MMI_BOOL srv_da_get_current_job_need_sent (U32 arg)
{
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	return job_data->need_sent;
}

void srv_da_set_current_job_need_sent(U32 arg, MMI_BOOL flag)
{
	
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	job_data->need_sent = flag;
}

void srv_da_set_http_flag(U32 arg, MMI_BOOL flag)
{
	
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	job_data->http_flag = flag;
}

MMI_BOOL srv_da_get_http_flag(U32 arg)
{
	
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	return job_data->http_flag;
}

void srv_da_set_job_data_length(srv_da_job_struct * job, U32 len)
{

	srv_da_normal_dl_job_struct *job_data;
	
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	job_data->content_len = len;
}


void srv_da_set_job_content(srv_da_job_struct * job, S8 *buffer)
{
	
	srv_da_normal_dl_job_struct *job_data;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	//job_data->content = (S8*)get_ctrl_buffer(job_data->content_len+1);
    //memcpy(job_data->content, buffer, job_data->content_len);
    //job_data->content[job_data->content_len] = 0;
	job_data->content = buffer;
}

void srv_da_job_set_reporting(srv_da_job_struct * job, MMI_BOOL flag)
{
	job->reporting = flag;
	
}
void srv_da_http_dl_inform_app(srv_da_job_struct *arg)
{
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT   
    srv_da_setting_struct       *setting_data;
	srv_da_normal_dl_job_struct *job_data;
	setting_data = srv_da_get_setting_buffer();
	job_data = (srv_da_normal_dl_job_struct *)arg->data_ptr;
	srv_da_http_dl_get_setting_ext(arg, setting_data);
	srv_da_copy_setting(arg, setting_data);
	if(arg->setting_info.filepath_hdlr)
    {
        S32 job_id = DA_MAKE_UNIQUE_ID(arg, (S32)srv_da_get_job_id(arg));
        srv_da_job_set_reporting(arg, MMI_TRUE);
        MMI_ASSERT(arg->mime_type);

        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);
        
        arg->setting_info.filepath_hdlr(
            job_id,
            arg->mime_type->mime_type,
            arg->mime_type->mime_subtype,
            job_data->filepath);
#endif
    }
}

U32 srv_da_get_current_job_acc_id (U32 arg)
{
    
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	return job_data->acc_id;
}


#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
void srv_da_save_session_info(U32 arg, srv_da_wps_session_struct *session_handle, U8 seq_num, U8 status)
{
	srv_da_normal_dl_job_struct *job_data;
	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	job_data->session_handle = session_handle;
	job_data->seq_num = seq_num;
	job_data->status = status;

	
}
srv_da_wps_session_handle srv_da_get_job_data_session(U32 arg)
{
	
	srv_da_normal_dl_job_struct *job_data;

	srv_da_job_struct *job = (srv_da_job_struct *)arg;
	job_data = (srv_da_normal_dl_job_struct *)job->data_ptr;
	return job_data->session;

}
#endif
#endif
void srv_da_set_current_job (srv_da_job_struct *job)
{
	if (g_srv_da_context.curr_job)
	{
		 g_srv_da_context.curr_job = NULL;
	}
    g_srv_da_context.curr_job = job;
}



MMI_BOOL srv_da_reset_job_list_updated (void)
{
    if (g_srv_da_context.job_list_updated)
    {
        g_srv_da_context.job_list_updated = MMI_FALSE;
        return MMI_TRUE;
    }
    return MMI_FALSE;
}

/*****************************************************************************
 * FUNCTION
 *  srv_da_count_job
 * DESCRIPTION
 *  Count the number of jobs match the condition.
 * PARAMETERS
 *  func        [IN] Condition function
 *  criteria    [IN] Criteria
 * RETURNS
 *  The number of jobs match.
 *****************************************************************************/
srv_da_job_struct *srv_da_search_job(U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if (job->type == criteria)
		{
			return job;
		}

        job = job->next_job;
    }
    return NULL;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_discard_pending_popup
 * DESCRIPTION
 *  Discard the pending popup of a job
 * PARAMETERS
 *  job         [IN] The job
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_discard_pending_popup(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (job->pending_popup.type != SRV_DA_POPUP_TYPE_NONE)
    {
        if (job->pending_popup.free_string_after_popup &&
            job->pending_popup.string != NULL)
        {
            srv_srv_da_adp_mem_free(job->pending_popup.string);
            job->pending_popup.free_string_after_popup = MMI_FALSE;
            job->pending_popup.string = NULL;
        }
        
        if (job->pending_popup.info != NULL)
        {
            srv_srv_da_adp_mem_free(job->pending_popup.info);
            job->pending_popup.info = NULL;
        }
    }

    job->pending_popup.type = SRV_DA_POPUP_TYPE_NONE;
}


MMI_BOOL srv_da_free_job (srv_da_job_struct *job)
{

    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL            ret;
   // S32                 old_num;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* abort first */
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_INIT ||
           job->state == SRV_DA_JOB_STATE_ABORTED ||
           job->state == SRV_DA_JOB_STATE_PAUSED ||
           job->state == SRV_DA_JOB_STATE_FAILED ||
           job->state == SRV_DA_JOB_STATE_COMPLETED ||
		   job->state == SRV_DA_JOB_STATE_RESUMING ||
		   job->state == SRV_DA_JOB_STATE_CREATED);

    /* cache current job count */
    //old_num = g_srv_da_context.list_job_num;

     
    //is_in_job_specific_screen = MMI_FALSE;
    if(g_srv_da_context.curr_job == job)
    {
        g_srv_da_context.curr_job = NULL;
        //is_in_job_specific_screen = MMI_TRUE;
    }
   
    /* check if job is in list, if yes, remove it first */
    if(job->prev_job || job->next_job || job == g_srv_da_context.list_job)
    {
		if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
		{
        g_srv_da_context.list_job_num--;
        g_srv_da_context.job_list_updated = MMI_TRUE;
    }
    }
    if(job->prev_job)
        job->prev_job->next_job = job->next_job;
    if(job->next_job)
        job->next_job->prev_job = job->prev_job;
    if(job == g_srv_da_context.list_job)
        g_srv_da_context.list_job = job->next_job;

    if (job->pending_popup.type != SRV_DA_POPUP_TYPE_NONE)
    {
        srv_da_discard_pending_popup(job);
    }

    /* call free func */
    MMI_ASSERT(job->type < SRV_DA_JOB_TYPE_TOTAL);
    MMI_ASSERT(job->op->free);
    ret = job->op->free(job);
#if defined (__MMI_NCENTER_SUPPORT__)
	if (job->notify_handle)
		vsrv_ncenter_close_notification(job->notify_handle);
#endif


if (job)
    srv_srv_da_adp_mem_free(job);
    srv_da_send_download_info_ind();
    return ret;
}





#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
MMI_BOOL srv_da_job_match_need_complete_notify_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (job->state == SRV_DA_JOB_STATE_COMPLETED && 
            job->notified_complete == MMI_FALSE)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


void srv_da_resume_all_jobs (void)
{
#ifdef __MMI_DA_RESUME__    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while (job != NULL)
    {
        if((job->state == SRV_DA_JOB_STATE_PAUSED) || (job->state == SRV_DA_JOB_STATE_FAILED)) 
        {
            srv_da_job_resume (job);
        }
        job = job->next_job;
    }
#endif
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_remove_all_completed
 * DESCRIPTION
 *  Remove all completed items from list.
 * PARAMETERS
 *  void
 * RETURNS
 *  Number of items removed.
 *****************************************************************************/
U32 srv_da_remove_all_completed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U32 n_removed;
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    n_removed = 0;
    job = g_srv_da_context.list_job;
    
    while (job != NULL)
    {
        srv_da_job_struct *next_job = job->next_job;
        
        if(job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
			/*Need to move in App*/
#ifndef __COSMOS_MMI_PACKAGE__			
#if defined (__MMI_NCENTER_SUPPORT__)
				if (job->notify_handle != NULL)
					vsrv_ncenter_close_notification(job->notify_handle);
			
#endif
#endif

            if (job->prev_job != NULL)
            {
                job->prev_job->next_job = job->next_job;
            }
            if (job->next_job != NULL)
            {
                job->next_job->prev_job = job->prev_job;
            }
            if (job == g_srv_da_context.list_job)
            {
                g_srv_da_context.list_job = job->next_job;
            }

            job->op->free(job);
            srv_srv_da_adp_mem_free(job);

            g_srv_da_context.list_job_num--;
            n_removed++;
        }
        
        job = next_job;
    }
    srv_da_send_download_info_ind();
    if (n_removed > 0)
    {
        g_srv_da_context.job_list_updated = MMI_TRUE;
    }

    return n_removed;
}

#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */




/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
static void srv_da_suspended_in_background_callback(srv_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTED);

#ifndef __COSMOS_MMI_PACKAGE__		
#ifndef MMI_DA_PLUTO_SLIM	
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif
#endif

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    if(job->setting_info.can_minimize)
    {
        job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_update_job_status(job);
        job->reporting = MMI_FALSE;
    }
    else
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */
    {
        srv_da_update_job_status(job);
    }
}

/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
MMI_BOOL srv_da_job_match_job_type_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (job->type == (srv_da_job_type_enum)criteria)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}



/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
MMI_BOOL srv_da_job_match_state_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (job->state == (srv_da_job_state_enum)criteria)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}


MMI_BOOL srv_da_job_is_pgdl(U32 arg)
{
#if defined PGDL_SUPPORT_YOUTUBE
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#else
	return MMI_FALSE;
#endif

}
/*****************************************************************************
* FUNCTION
* DESCRIPTION
* PARAMETERS
* RETURNS
*****************************************************************************/
MMI_BOOL srv_da_job_match_id_func(const srv_da_job_struct* job, U32 id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if(DA_JOB_UNIQUE_ID(job) == (S32)id)
    {
        return MMI_TRUE;
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_suspend_all_job
 * DESCRIPTION
 *  Suspend all downloading jobs. Not include jobs in processing.
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_suspend_all_job(srv_da_error_enum cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job, *next_job;
    S32                 prev_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    DA_TRACE_FUNC(srv_da_suspend_all_job);
    
    next_job = srv_da_get_first_job();
    while (next_job != NULL)
    {
        job = next_job;
        next_job = job->next_job;

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
        /* Allow the download not initiated by WAP to be continued. */
        if (job->dl_flag & DA_DL_FLAG_SPECIAL)
        {
            continue;
        }
#endif

        if (!job->setting_info.can_minimize && job->type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
        {
			/* No need to pause the job which can not be
			   minimized */
            if (job->state == SRV_DA_JOB_STATE_COMPLETED ||
                job->state == SRV_DA_JOB_STATE_FAILED)
            {
                srv_da_free_job_and_remove_screens(job);
            }
            else if (job->state == SRV_DA_JOB_STATE_PROCESSING ||
                    job->state == SRV_DA_JOB_STATE_DOWNLOADING)
            {
                prev_state = job->state;
                job->state = SRV_DA_JOB_STATE_ABORTING;
                job->error_cause = cause;
                job->was_stopped_by_upper_layer = MMI_TRUE;
                job->op->stop(job, 
                         prev_state,
                         MMI_FALSE,
                         srv_da_suspended_in_background_callback);
            }
 
        }
        else if (job->state == SRV_DA_JOB_STATE_DOWNLOADING || job->state == SRV_DA_JOB_STATE_RESUMING)
        {
            prev_state = job->state;
            job->state = SRV_DA_JOB_STATE_ABORTING;
            job->error_cause = cause;
            job->was_stopped_by_upper_layer = MMI_TRUE;
            job->op->stop(job, 
                     prev_state,
                     MMI_TRUE,
                     srv_da_suspended_in_background_callback);
        }
        else if (job->state == SRV_DA_JOB_STATE_PROCESSING)
        {
            /* We don't allow to pause the jobs in processing,
               since some procedures are non-recoverable */
        }
#ifndef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        /* remove all job */
        else if(job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            srv_da_free_job_and_remove_screens(job);
        }
        else if(job->state == SRV_DA_JOB_STATE_FAILED)
        {
            srv_da_free_job_and_remove_screens(job);
        }
#endif

    }


#ifdef __MMI_OMA_DD_DOWNLOAD__
    srv_da_oma_send_report_stop_retrying();
#endif
    
}



/*****************************************************************************
 * FUNCTION
 *  srv_da_job_cancel
 * DESCRIPTION
 *  Cancel a job which in INIT.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  Successfully cancelled
 *****************************************************************************/
MMI_BOOL srv_da_job_cancel(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL                ret;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC(srv_da_job_cancel);

    /* this func is only to cancel current setuping job */

    if(!g_srv_da_context.setuping_job)
        return MMI_FALSE;
    if(job != g_srv_da_context.setuping_job)
    {
        MMI_ASSERT(0);
        return MMI_FALSE;
    }

#ifdef __MMI_DA_OMADL_CUST_CHL_SUPPORT__
    if(g_srv_da_context.setuping_cb)
        g_srv_da_context.setuping_cb(MMI_FALSE);
    g_srv_da_context.setuping_cb = NULL;
#endif

    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_INIT || job->state == SRV_DA_JOB_STATE_ABORTED || job->state == SRV_DA_JOB_STATE_CREATED);
    ret = srv_da_free_job_and_remove_screens_ex(job);
    //g_srv_da_context.setuping_job = NULL;
    return ret;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_curr_job_do_abort
 * DESCRIPTION
 *  Abort a downloading or suspended job.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_curr_job_do_abort(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_state_enum prev_state;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    DA_TRACE_FUNC1(srv_da_curr_job_do_abort, job->state);
    
    job->was_stopped_by_upper_layer = MMI_TRUE;
        
    prev_state = job->state;
    
    switch (prev_state)
    {
        case SRV_DA_JOB_STATE_DOWNLOADING:
        case SRV_DA_JOB_STATE_PROCESSING:
        case SRV_DA_JOB_STATE_WAITING:
        case SRV_DA_JOB_STATE_PAUSED_WAITING:

            job->state = SRV_DA_JOB_STATE_ABORTING;
        
            job->op->stop(
                job, 
                prev_state,
                MMI_FALSE,
                srv_da_adp_curr_job_aborted_callback);
                
            break;

        case SRV_DA_JOB_STATE_PAUSED:
	    case SRV_DA_JOB_STATE_RESUMING:
        case SRV_DA_JOB_STATE_FAILED:
            job->state = SRV_DA_JOB_STATE_ABORTED;
            srv_da_adp_curr_job_aborted_callback(job, 0);
            break;
        case SRV_DA_JOB_STATE_COMPLETED:
            break;

        default:
            MMI_EXT_ASSERT(MMI_FALSE, prev_state, 0, 0);
            break;
    }
}
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_abot_callback (srv_da_job_struct* job, U16 string_id)
{
    if (job->reporting)
    {
        srv_da_item_progress_struct info;
        DA_JOB_GET_PROGRESS(job, info);
        srv_da_report_to_app(job, &info);
    }
    srv_da_update_job_status (job);
}


void srv_da_abort_all_downloading_jobs (void)
{
    srv_da_job_struct *job = NULL;

    job = srv_da_get_first_job();
    while (job)
    {
        if (job->state == SRV_DA_JOB_STATE_DOWNLOADING)
        {
            job->state = SRV_DA_JOB_STATE_ABORTING;
            job->was_stopped_by_upper_layer = MMI_TRUE;
            srv_da_stop_selected_job (job, SRV_DA_JOB_STATE_DOWNLOADING, MMI_TRUE, srv_da_abot_callback);
            /* free job directly */
        }
        job = job->next_job;
    }
}

#endif

#define JOB_STAMP

void srv_da_job_make_filestamp(srv_da_job_struct* job)
{
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16*  filepath;
    FS_HANDLE   filehandle;
    UINT        filesize;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_PAUSED ||
           job->state == SRV_DA_JOB_STATE_COMPLETED ||
           job->state == SRV_DA_JOB_STATE_FAILED);
    
    filepath = job->op->get_filepath(job);
    filehandle = FS_Open((U16*)filepath, FS_READ_ONLY);
    
    if(filehandle >= 0)
    {
        FS_GetFileSize(filehandle, &filesize);
        job->filestamp.curr_size = filesize;

        FS_Close(filehandle);
        DA_TRACE_FUNC1(srv_da_job_make_filestamp, filesize);
    }
    else
    {
        job->filestamp.curr_size = 0xFFFFFFFF;
        DA_TRACE_FUNC1(srv_da_job_make_filestamp, filehandle);
    }
#endif    
}

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
/*****************************************************************************
 * FUNCTION
 *  mmi_da_job_has_popupinfo_func
 * DESCRIPTION
 *  If the job has pending popup, return MMI_TRUE.
 * PARAMETERS
 *  job         [IN] Job
 *  criteria    [IN] Criteria
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL srv_da_job_has_popupinfo_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    return (MMI_BOOL)(job->pending_popup.type != SRV_DA_POPUP_TYPE_NONE);
}
#endif


/*****************************************************************************
 * FUNCTION
 *  srv_da_report_to_app
 * DESCRIPTION
 *  Report progress to application by report_hdlr.
 * PARAMETERS
 *  job     [IN] Job
 *  info    [IN] Progress info
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_report_to_app(srv_da_job_struct *job, const srv_da_item_progress_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (job->reporting)
    {
        S32 job_id = DA_JOB_UNIQUE_ID(job);
    
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_REPORT_TO_APP, job_id, job->state, job->error_cause, info->currSize);

        job->setting_info.report_hdlr(job_id,
                                      srv_da_util_state_transfer(job->state),
                                      job->error_cause,
                                      0,
                                      info->currSize,
                                      info->fileSize);
    }
}



#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_on_play_selected
 * DESCRIPTION
 *  User selected "Play" item. This function is available only for progressive
 *  download. Continue to report to the application.
 * PARAMETERS
 *  job     [IN] Target job
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_job_on_play_selected(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (srv_da_is_in_voice_call())
    {
        srv_da_adp_popup(STR_GLOBAL_CURRENTLY_NOT_AVAILABLE_IN_CALL, 0, SRV_DA_POPUP_TYPE_ERROR);
        return;
    }
    
    if (!job->reporting &&
        job->setting_info.filepath_hdlr != NULL &&
        (job->state == SRV_DA_JOB_STATE_DOWNLOADING || job->state == SRV_DA_JOB_STATE_COMPLETED))
    {
        srv_da_item_progress_struct info;
        S32 job_id;

        job_id = DA_JOB_UNIQUE_ID(job);
        DA_JOB_GET_PROGRESS(job, info);
    
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);

        /* Note app may call stop_pdl() in filepath_hdlr() */
        job->reporting = MMI_TRUE;
        
        job->setting_info.filepath_hdlr(
            DA_JOB_UNIQUE_ID(job),
            job->mime_type->mime_type,
            job->mime_type->mime_subtype,
            (U16*)job->op->get_filepath(job));

        srv_da_report_to_app(job, &info); /* Will check job->reporting here */
    }
}
#endif
const U16* srv_da_job_get_filepath (const srv_da_job_struct *job)
{
    return (U16*)job->op->get_filepath(job);
}

void  srv_da_job_get_name (const srv_da_job_struct *job, U16 *buffer, U16 len)
{
    job->op->get_name(job, buffer, len);
}

void srv_da_job_dispatch (srv_da_job_struct *job)
{
    job->op->dispatch(job);
}

S32 srv_da_job_can_resume (const srv_da_job_struct *job)
{
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    if (job->op->resume)
    {
        return 1;
    }
#endif /* resume enable */
    return 0;
}

S8* srv_da_job_get_infoURL (srv_da_job_struct *job)
{
    if (job->op->get_infoURL != NULL)
    {
        return (S8*)job->op->get_infoURL(job);
    }
    else
    {
        return NULL;
    }
}

MMI_BOOL srv_da_job_is_status_desc_available (const srv_da_job_struct *job)
{
    if (job->op->get_status_desc !=NULL)
    {
        return MMI_TRUE;
    }
    return MMI_TRUE;
}

void srv_da_job_get_status_desc (const srv_da_job_struct *job, U16 **string_buffer, U32 buffer_len, U16 num_of_item, U32 *num_of_filled)
{
    job->op->get_status_desc(job, string_buffer, buffer_len, num_of_item, num_of_filled);
}

MMI_BOOL srv_da_job_is_object_description_available (srv_da_job_struct *job)
{
    if (job->op->is_object_desc_available != NULL)
    {
        return job->op->is_object_desc_available(job);
    }
    return MMI_FALSE;
}

void srv_da_job_get_object_description_available (srv_da_job_struct *job, U16 *buffer, U32 size)
{
    job->op->get_object_desc(job, (U16*)buffer, size);
}

void srv_da_job_change_filepath_to_download (srv_da_job_struct *job, U16 *filepath)
{
    job->op->assign_filepath(job, filepath);
}

void srv_da_stop_selected_job (srv_da_job_struct *job, S32 prev_state, MMI_BOOL pauseOnly, srv_da_abort_callback_type end_callback)
{
    job->op->stop(job, 
        prev_state,
        pauseOnly,
        end_callback);
}

void srv_da_job_get_setting (const srv_da_job_struct *job, srv_da_setting_struct *setting)
{
    job->op->get_setting(job, setting);
}

U16 srv_da_get_job_id (const srv_da_job_struct *job)
{
    return job->op->get_id(job);
	 
}

srv_da_job_struct* srv_da_get_curr_job_in_setuping_state (void)
{
    return (g_srv_da_context.setuping_job);
}

void srv_da_set_curr_job_in_setuping_state (void *arg)
{
    g_srv_da_context.setuping_job = arg;
}


#define DA_TRACE_HELPER

void srv_da_trace_func(S32 func_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FUNC, func_enum, srv_da_get_curr_job_count());
}

void srv_da_trace_func_ex(S32 func_enum, S32 p1, S32 p2, S32 p3)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FUNC_EX, func_enum, srv_da_get_curr_job_count(), p1, p2, p3);
}

void srv_da_trace_endfunc(S32 func_enum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_END_FUNC, func_enum, srv_da_get_curr_job_count());
}


MMI_BOOL srv_da_adp_popup_long_msg_for_job(
    srv_da_job_struct *job,
    U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
   	srv_da_popup_for_job_msg_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Don't popup during reporting */
    if (job->reporting)
    {
        return MMI_TRUE;
    }
    
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP_FOR_JOB_MSG);
    evt.job = job;
	evt.filepath = filepath;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    return MMI_TRUE;
}
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif


void srv_da_adp_popup_for_job(
    srv_da_job_struct *job,
    srv_da_popup_type_enum type,
    U16 message_str,
    MMI_BOOL free_string_after_popup,
	void *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_popup_message_for_job_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/


    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP_FOR_JOB);
    evt.job = job;
    evt.type = type;
	evt.error_str_id = message_str;
	evt.free_string_after_popup = free_string_after_popup;
	evt.info = info;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}


void srv_da_adp_popup_error_for_job(srv_da_job_struct *job, srv_da_popup_type_enum type, S32 cause, U16 error_str_id, MMI_BOOL terminate_job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	srv_da_popup_error_for_job_struct evt;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/


    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_POPUP_ERROR_FOR_JOB);
    evt.job = job;
    evt.type = type;
	evt.error_str_id = error_str_id;
	evt.terminate_job = terminate_job;
	evt.cause = cause;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);

}





void srv_da_adp_popup_wps_aborted (srv_da_job_struct *job, S32 error_code)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    if (!job->was_stopped_by_upper_layer) /* Stopped by lower layer */
    {
        if (error_code < 0) /* file system error */
        {
           srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_FS_ERROR, error_code, 0, MMI_FALSE);
        }
        else /* unknown error */
        {
			srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_CONNECT_CLOSED, MMI_FALSE);
        }

    }
}
#if (defined(__COSMOS_MMI_PACKAGE__) && (defined(__MMI_DLA_SLIM__) || defined(SLIM_WAP_MMS)))
static void srv_da_delete_completed_failed(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    //srv_da_job_struct* next_job;
    U16 i = 0;
    

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if (job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            i++;
        }
        job = job->next_job;
    }
   
    job = g_srv_da_context.list_job;
    while (i == SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD)
    {
        if (job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            i--;
            srv_da_free_job(job);
            //g_srv_da_context.list_job_num--;
            //next_job = job->next_job;
            //job->op->free(job);
            //job = next_job;
            //continue;
        }
        job = job->next_job;
    }
    //g_srv_da_context.list_job = job;
	job = g_srv_da_context.list_job;
	while(job)
	{
		if (job->state == SRV_DA_JOB_STATE_FAILED)
			srv_da_free_job(job);
		job = job->next_job;
	}
}
#endif
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_delete_extra_completed (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    //srv_da_job_struct* next_job;
    U16 i = 0;
    
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if (job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            i++;
        }
        job = job->next_job;
    }
    
    job = g_srv_da_context.list_job;
    while (i > SRV_DA_MAX_NUM_OF_COMPLETED_DOWNLOAD)
    {
        if (job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            i--;
            srv_da_free_job(job);
            //g_srv_da_context.list_job_num--;
            //next_job = job->next_job;
            //job->op->free(job);
            //job = next_job;
            //continue;
        }
        job = job->next_job;
    }
    //g_srv_da_context.list_job = job;
}
#endif
#if defined (__MMI_OMA_DD_DOWNLOAD__)
/*****************************************************************************
 * FUNCTION
 *  srv_da_adp_oma_popup_message
 * DESCRIPTION
 *  Popup message for the job.
 * PARAMETERS
 *  job             [IN/OUT] Job. May modify the pending message of the job.
 *  error_code      [IN]     OMA error code
 *  will_end_job    [IN]     If MMI_TRUE, the popup will be shown right away.
 *                           Otherwise, it allows pending.
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_adp_oma_popup_message(srv_da_job_struct *job, srv_da_oma_error_enum error_code, MMI_BOOL will_end_job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 string_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    srv_da_oma_report_map_string(error_code, &string_id, NULL);

    if (error_code == SRV_DA_OMA_USER_CANCELLED)
    {
        srv_da_adp_popup(string_id, 0, SRV_DA_POPUP_TYPE_DONE);
    }
    else
    {
        if (job != NULL && !will_end_job)
        {
            srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, string_id, MMI_FALSE);
        }
        else /* job == NULL or will_end_job == TRUE */
        {
            srv_da_adp_popup(string_id, 0, SRV_DA_POPUP_TYPE_ERROR);
        }
    }
}
#endif 
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_make_complete_filepath (U16 *filepath, void *arg, U16 *filename, U16 *ext, U16 drive, U16 size)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job = (srv_da_job_struct*)arg;
    //void                        *job_data;
    srv_da_setting_struct       *setting_data;
    U16                         folder[75] = {'0', };
    U16                         *drv;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //job_data = job->data_ptr;
    setting_data = srv_da_get_setting_buffer();

    if (size == sizeof (srv_da_push_item_struct))
    {
        srv_da_push_get_dir (arg, folder);
        goto CREATE_FILEPATH;
    }
    if (job->type == SRV_DA_JOB_TYPE_NORMAL)
    {
    #ifdef BROWSER_SUPPORT
        srv_da_http_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);

        mmi_wcscpy(folder, setting_data->folder);
    #else
        ASSERT(0);
    #endif /* BROWSER_SUPPORT */
    }
#ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	else if (job->type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
    {
  
        srv_da_http_dl_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);

        mmi_wcscpy(folder, setting_data->folder);
   
    }
#endif
#if defined (__MMI_OMA_DD_DOWNLOAD__)
    else if (job->type == SRV_DA_JOB_TYPE_OMADL)
    {
        srv_da_oma_get_setting(job, setting_data);
        srv_da_copy_setting(job, setting_data);

        mmi_wcscpy(folder, setting_data->folder);
    }
#endif 
#ifdef MMI_DLA_MRE_SUPPORT
    else if (job->type == SRV_DA_JOB_TYPE_MREDL)
    {
    #ifdef MMI_DLA_MRE_SUPPORT
        srv_da_mre_get_app_dir (folder);
    #endif
    }
#endif
    else
    {
        srv_da_push_get_dir (arg, folder);
    }

	if (drive == SRV_DA_DRIVE_MEMORY_CARD)
    {
        drv = (U16*)srv_fmgr_drv_get_path_by_type (SRV_FMGR_DRV_CARD_TYPE);
    }
    else
    {
        drv = (U16*)srv_fmgr_drv_get_path_by_type (SRV_FMGR_DRV_PHONE_TYPE);
    }

    if (ext)
    {
        kal_wsprintf(filepath, "%w%w%w.%w", drv, folder, filename, ext);
    }
    else
    {
        kal_wsprintf(filepath, "%w%w%w", drv, folder, filename);
    }

CREATE_FILEPATH:
    if (drive == SRV_DA_DRIVE_MEMORY_CARD)
    {
        drv = (U16*)srv_fmgr_drv_get_path_by_type (SRV_FMGR_DRV_CARD_TYPE);
    }
    else
    {
        drv = (U16*)srv_fmgr_drv_get_path_by_type (SRV_FMGR_DRV_PHONE_TYPE);
    }

    if (ext)
    {
        kal_wsprintf(filepath, "%w%w%w.%w", drv, folder, filename, ext);
    }
    else
    {
        kal_wsprintf(filepath, "%w%w%w", drv, folder, filename);
    }
}
#endif

#ifdef __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__

void srv_da_abort_callback_do_resume (srv_da_job_struct* job, U16 string_id)
{
   
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)  
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTED);
    job->state = SRV_DA_JOB_STATE_PAUSED;
    srv_da_update_job_status(job);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_PAUSED);

    MMI_ASSERT(job->op->resume);

    srv_da_set_allow_to_trigger_connection(MMI_TRUE);

    /* Don't start to report immediately when user resume the download */
    job->reporting = MMI_FALSE;

    if(srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) +
        srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
    {
        srv_da_adp_popup(SRV_DA_PROMPT_EXCEED_MAX_DL, 0, SRV_DA_POPUP_TYPE_ERROR);
    }
    else
    {
        srv_da_job_resume(job);
    }
#endif
}


void srv_da_suspend_and_resume_download (srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job->state = SRV_DA_JOB_STATE_ABORTING;
    job->was_stopped_by_upper_layer = MMI_FALSE;
    
    srv_da_stop_selected_job (job, SRV_DA_JOB_STATE_DOWNLOADING, MMI_TRUE, srv_da_abort_callback_do_resume);
}


void srv_da_suspend_and_resume_all_downloads_with_browser (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if((job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)  && 
            job->state == SRV_DA_JOB_STATE_DOWNLOADING && 
            srv_da_http_is_browser_job (job))
        {
            srv_da_suspend_and_resume_download (job);
        }
        job = job->next_job;
    }
}
#endif /* __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__ */
#ifndef MMI_DA_PLUTO_SLIM
void srv_da_display_download_list(void)
{
	srv_da_adp_display_job_list(NULL, MMI_TRUE);
}
#endif


/*****************************************************************************
* FUNCTION
*   srv_da_get_header
* DESCRIPTION
*   Get Http header
* PARAMETERS
*   header_len  [OUT]   return the length of header
* RETURNS
*   return a header array to application. AP should invoke this api when their
*   dispatch function invoked. And AP should copy the header to another place,
*   because this array will be free after the callback function finished.
*****************************************************************************/
const S8* srv_da_get_header(S32 session_id, U32* header_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct   *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef BROWSER_SUPPORT
    job = srv_da_find_job(srv_da_job_match_id_func, 
        DA_MAKE_UNIQUE_ID_EX(SRV_DA_JOB_TYPE_NORMAL, session_id));

    if(job)
    {
        return srv_da_http_get_header(job, header_len);
    }
#endif
    
    if (header_len != NULL)
    {
        *header_len = 0;
    }
        
    return srv_da_push_get_header(session_id, header_len);
}


void srv_da_adp_close_app (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_event_struct evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_CLOSE_APP);
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
}

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
void srv_da_set_need_notify (srv_da_job_struct* job)
{
    job->notified = SRV_DA_NOTIFIED_NONE;
}

#ifndef MMI_DA_PLUTO_SLIM
void srv_da_set_notified_failed (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(job->state == SRV_DA_JOB_STATE_FAILED)
        {
            job->notified = SRV_DA_NOTIFIED_FAILED;
        }
        job = job->next_job;
    }
}


void srv_da_set_notified_completed (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = g_srv_da_context.list_job;
    while(job)
    {
        if(job->state == SRV_DA_JOB_STATE_COMPLETED)
        {
            job->notified = SRV_DA_NOTIFIED_COMPLETED;
        }
        job = job->next_job;
    }
}
#endif

MMI_BOOL srv_da_is_notified (const srv_da_job_struct* job, U32 state)
{
    
    if ((job->state == state) && (job->notified == SRV_DA_NOTIFIED_NONE))
		return MMI_TRUE;
    else
        return MMI_FALSE;
    }





void srv_da_resume_all_paused_list (void)
{
 #if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)   
    srv_da_job_struct* job = g_srv_da_context.list_job;
    DA_TRACE_FUNC1(srv_da_resume_all_paused_list, (U32)job);

    while (job)
    {
        if(job->state == SRV_DA_JOB_STATE_PAUSED && !(job->was_stopped_by_upper_layer))
        {
            /* Resuming the job paused because of bearer change */
            MMI_ASSERT(job->state == SRV_DA_JOB_STATE_PAUSED);
            MMI_ASSERT(job->op->resume);

            srv_da_set_allow_to_trigger_connection(MMI_TRUE);

            /* Don't start to report immediately when user resume the download */
            job->reporting = MMI_FALSE;

            if(srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_DOWNLOADING) +
                srv_da_count_job(srv_da_job_match_state_func, SRV_DA_JOB_STATE_PROCESSING) >= MMI_DA_MAX_DL)
            {
                srv_da_adp_popup(SRV_DA_PROMPT_EXCEED_MAX_DL, 0, SRV_DA_POPUP_TYPE_ERROR);
            }
            else
            {
                srv_da_job_resume(job);
            }
        }
        job = job->next_job;
    }
#endif 
}
#ifdef __HTTP_INTERFACE__
/*****************************************************************************
 * FUNCTION
 *  mmi_da_open_bearer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
kal_int8 srv_da_open_bearer(U32 s)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	//srv_da_job_struct *job;
	//srv_da_normal_dl_job_struct *job_data;
	kal_int8 ret = 0;
#ifdef BROWSER_SUPPORT
    srv_brw_profile_content_struct *profile_content_p;
	U32 net_id;
	U8 cbm_app_id;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
	profile_content_p = (srv_brw_profile_content_struct *)srv_da_wps_get_bearer_profile(s);
	if (profile_content_p)
	{
	cbm_app_id = srv_da_wps_get_app_id();
	DA_TRACE_FUNC2(srv_da_open_bearer, 13, cbm_app_id);
 #ifdef MMI_DA_HTTP_DOWNLOAD_SUPPORT
	if (srv_da_get_current_job_type(s) ==SRV_DA_JOB_TYPE_HTTP_DOWNLOAD)
		net_id = cbm_set_app_id(srv_da_get_current_job_acc_id(s), cbm_app_id);
	else
#endif
	net_id = cbm_set_app_id(profile_content_p->data_account_primary_id, cbm_app_id);
	srv_da_wps_set_account_id(net_id);
    ret = cbm_open_bearer(net_id);
		srv_da_wps_reset_cbm_app_id(cbm_app_id);
    srv_srv_da_adp_mem_free(profile_content_p);
    DA_TRACE_FUNC3(srv_da_open_bearer, profile_content_p->data_account_primary_id, net_id, ret);
	return ret;
	}
    return ret;
#else
return ret;
#endif
}
#endif
/*****************************************************************************
 * FUNCTION
 *  srv_da_job_fallback_suspended_callback
 * DESCRIPTION
 *  Callback for suspended
 * PARAMETERS
 *  job         [IN] Job
 *  string_id   [IN] String to show
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_job_fallback_suspended_callback(srv_da_job_struct* job, U16 string_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC1(srv_da_job_fallback_suspended_callback, g_srv_da_context.paused_num);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTED);
    job->state = SRV_DA_JOB_STATE_PAUSED;

   // srv_da_close_job_list_option();
    srv_da_update_job_status(job);
    job->reporting = MMI_FALSE;
    g_srv_da_context.paused_num--;

    if (g_srv_da_context.paused_num == 0)
    {
        srv_da_resume_all_paused_list ();
    }
}


void srv_da_suspend_and_resume_all_download (void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct* job;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_srv_da_context.bearer_switching = MMI_TRUE;
    g_srv_da_context.paused_num = 0;
    job = g_srv_da_context.list_job;
    while (job)
    {
        if (job->state == SRV_DA_JOB_STATE_DOWNLOADING || job->state == SRV_DA_JOB_STATE_RESUMING)
        {
            job->state = SRV_DA_JOB_STATE_ABORTING;
            job->was_stopped_by_upper_layer = MMI_FALSE;
            job->op->stop(job, 
                SRV_DA_JOB_STATE_DOWNLOADING,
                MMI_TRUE,
                srv_da_job_fallback_suspended_callback);
            g_srv_da_context.paused_num++;
        }
        job = job->next_job;
    }
    if (!g_srv_da_context.paused_num)
    {
        srv_da_resume_all_paused_list ();
    }
}

#ifdef MMI_DA_WLAN_PREFER_SUPPORT
void srv_da_reset_bearer_switching (void)
{
    g_srv_da_context.bearer_switching = MMI_FALSE;
}


MMI_BOOL srv_da_is_bearer_switching (void)
{
    return g_srv_da_context.bearer_switching;
}
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */



/*****************************************************************************
 * FUNCTION
 *  srv_da_bearer_change_to_wifi
 * DESCRIPTION
 *  
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_da_bearer_change_to_cellular(mmi_event_struct *evt)
{
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    if (!(srv_sim_ctrl_is_available(MMI_SIM1)
#ifdef __MMI_DUAL_SIM__
/* under construction !*/
#endif /* __MMI_DUAL_SIM__ */
        ))
    {
        DA_TRACE_FUNC1(srv_da_bearer_change_to_cellular, 0);
        return MMI_RET_OK;
    }
    DA_TRACE_FUNC(srv_da_bearer_change_to_cellular);

    if ((g_srv_da_context.list_job == NULL) || (g_srv_da_context.list_job_num == 0))
    {
        DA_TRACE_FUNC1(srv_da_bearer_change_to_cellular, 1);
        return MMI_RET_OK;
    }
    g_srv_da_context.bearer_switching = MMI_TRUE;
    srv_da_wps_handle_bearer_fallback_proc(SRV_DA_SWITCH_BEARER_CELLULAR);
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_bearer_change_to_wifi
 * DESCRIPTION
 *  
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_da_bearer_change_to_wifi(mmi_event_struct *evt)
{
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    DA_TRACE_FUNC(srv_da_bearer_change_to_wifi);
    g_srv_da_context.bearer_switching = MMI_TRUE;
    srv_da_wps_handle_bearer_fallback_proc(SRV_DA_SWITCH_BEARER_WLAN);
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
    return MMI_RET_OK;
}




/*****************************************************************************
 * FUNCTION
 *  mmi_da_bearer_change_to_wifi
 * DESCRIPTION
 *  
 * PARAMETERS
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret srv_da_switch_download_to_other_wlan(mmi_event_struct *evt)
    {
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    DA_TRACE_FUNC(srv_da_switch_download_to_other_wlan);

   // if (!mmi_da_wps_can_switch_to_wlan())
       // {
        DA_TRACE_FUNC1(srv_da_switch_download_to_other_wlan, 0);
        StopTimer(SRV_DA_TIMER_TRIGGERED_PROC_TIMER_BASE);
        srv_da_wps_switch_to_other_wlan();
    //}
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
    return MMI_RET_OK;
}



/*****************************************************************************
* FUNCTION
*  mmi_da_recv_nw_switch_ind
* DESCRIPTION
*  to handle network switch indication from browser
* PARAMETERS
*  MsgStruct  wap_mmi_file_dl_nw_switch_ind_struct   [IN]
* RETURNS
*  void.
*****************************************************************************/
void srv_da_recv_nw_switch_ind(void *MsgStruct, int mod_src, void *ilm_p)
{
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wap_mmi_file_dl_nw_switch_ind_struct     *msg = NULL;
	U32 acc_id;
	U8 app_id;
	srv_da_job_struct* job;
	srv_da_normal_dl_job_struct *job_data;


    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg = (wap_mmi_file_dl_nw_switch_ind_struct *) MsgStruct;
	DA_TRACE_FUNC2(srv_da_recv_nw_switch_ind, msg->user_result, msg->switch_type);
    job = g_srv_da_context.list_job;
    while (job)
    {
        job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
		if (job_data != NULL)
	{
#ifdef __MMI_DA_RESUME__
			if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
				return;
#endif

		}
        job = job->next_job;
    }
	if (!(srv_da_is_bearer_switching()))
	{
	if (msg->user_result)
    {
	srv_da_wps_set_cbm_app_id();
			switch (msg->switch_type)
			{
    case WAP_DL_BEARER_SWITCH_WIFI_TO_PS:
        srv_da_bearer_change_to_cellular(NULL);
        break;
    case WAP_DL_BEARER_SWITCH_WIFI_TO_WIFI:
        srv_da_switch_download_to_other_wlan(NULL);
        break;
    case WAP_DL_BEARER_SWITCH_PS_TO_WIFI:
        srv_da_bearer_change_to_wifi(NULL);
        break;
    default:
        break;
    }
	}

}
if (!(msg->user_result))
   {
	   srv_da_suspend_all_job(SRV_DA_ERROR_OTHERS);
   }
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */
}

srv_da_job_filestamp_enum srv_da_job_check_filestamp (srv_da_job_struct* job, U16 *error_reason_id)
{
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    const U16*  filepath = NULL;
    FS_HANDLE   filehandle = 0;
    UINT        filesize;
    srv_da_job_filestamp_enum         ret;
    U16         error_id = 0; //sahil to do handle in app = STR_ID_DA_ERROR_TEMP_UNAVAILABLE;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job);
    ret = SRV_DA_FILESTAMP_CHECK_OK;
#ifdef MMI_DLA_MRE_SUPPORT
    if (job->type == SRV_DA_JOB_TYPE_MREDL)
    {
        goto func_end;
    }
#endif
    
    if(job->state != SRV_DA_JOB_STATE_COMPLETED &&
        job->state != SRV_DA_JOB_STATE_PAUSED && job->state != SRV_DA_JOB_STATE_RESUMING) 
    {
        /* no need check */
        goto func_end;
    }


    // TODO: check for temporary or permant missing?

    filepath = job->op->get_filepath(job);

#ifdef __USB_IN_NORMAL_MODE__
    if (srv_usb_is_in_mass_storage_mode() &&
        srv_usb_check_path_exported((WCHAR*)filepath))
    {
        /* if path is exported , it is temporary */
        ret = SRV_DA_FILESTAMP_CHECK_FAIL_TEMP;
        error_id = STR_GLOBAL_NOT_AVAILABLE_IN_MASS_STORAGE_MODE;
        goto func_end;
    }
#endif

    /* try to open file */
    filehandle = FS_Open((U16*)filepath, FS_READ_ONLY);

    if(filehandle >= FS_NO_ERROR)
    {
        /* we can provide more check here */
        if(job->filestamp.curr_size != 0xFFFFFFFF)
        {
            FS_GetFileSize(filehandle, &filesize);
            if(job->filestamp.curr_size != filesize)
            {
                ret = SRV_DA_FILESTAMP_CHECK_FAIL;
            }
        }
        FS_Close(filehandle);
    }
    else
    {
        error_id = srv_fmgr_fs_error_get_string(filehandle);
        switch(filehandle)
        {
        case FS_DEVICE_BUSY:
            ret = SRV_DA_FILESTAMP_CHECK_FAIL_TEMP;
            break;

        default:
            ret = SRV_DA_FILESTAMP_CHECK_FAIL;
        }
    }

func_end:
    //sahil to do add this trace DA_TRACE_FUNC2(srv_da_job_check_filestamp, ret, filehandle);

    if(error_reason_id && error_id)
       *error_reason_id = error_id; 
       
    return ret;
#else
    return SRV_DA_FILESTAMP_CHECK_OK;
#endif    
}

#if defined(__SIM_HOT_SWAP_SUPPORT__) && defined(BROWSER_SUPPORT)
mmi_sim_enum srv_da_get_active_sim_id()
{
	mmi_brw_sim_id_enum sim_id = MMI_BRW_SIM_ID_DEFAULT;
	mmi_sim_enum active_sim = MMI_SIM_NONE;
	sim_id = srv_brw_get_active_sim_id();
	switch (sim_id)
	{
	case MMI_BRW_SIM_ID_DEFAULT:
	case MMI_BRW_SIM_ID_SIM1:
		return MMI_SIM1;
#if (MMI_MAX_SIM_NUM>=2)
	case MMI_BRW_SIM_ID_SIM2:
		return MMI_SIM2;
#if (MMI_MAX_SIM_NUM>=3) 
	case MMI_BRW_SIM_ID_SIM3:
		return MMI_SIM3;
#if (MMI_MAX_SIM_NUM>=4)
	case MMI_BRW_SIM_ID_SIM4:
		return MMI_SIM4;
#endif
#endif
#endif
	}
}

MMI_BOOL srv_da_adp_wifi_bearer_is_in_use()
{
#ifdef __HTTP_INTERFACE__
	if(!srv_da_wps_can_switch_to_wlan())
		return MMI_TRUE;
	else
#endif
	{
		return MMI_FALSE;
}
}


void srv_da_adp_on_sim_plug_out(mmi_sim_enum sim_id)
{
	if (srv_da_adp_wifi_bearer_is_in_use())
		return;
	else
	{
		if (sim_id == srv_da_get_active_sim_id())
		{
			srv_da_suspend_all_job(SRV_DA_ERROR_OTHERS);
		}
	}
}

#endif
S32 srv_da_get_job_count(void)
{
    return (S32)g_srv_da_context.list_job_num;
}

MMI_BOOL srv_da_free_job_and_remove_screens_ex(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_BOOL ret;
    srv_da_remove_scr_event_struct  evt;
	S32 index;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	index = srv_da_get_job_index(job);
    ret = srv_da_free_job(job);
    g_srv_da_context.setuping_job = NULL;
    MMI_FRM_INIT_EVENT(&evt, EVT_ID_DLA_SRV_REMOVE_JOB_SCREENS);
    evt.job = job;
	evt.is_in_job_screen = ret;
	evt.index = index;
    MMI_FRM_CB_EMIT_EVENT((mmi_event_struct *)&evt);
    /* POST event to invoke remove screen in MMI */
    return ret;
}
#endif /* __MMI_DOWNLOAD_AGENT__ */

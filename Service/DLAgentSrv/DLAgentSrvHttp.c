/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE.
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *
 *
 * Author:
 * -------
 * -------
 *
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
 
#include "MMI_include.h"

#if defined (__MMI_DOWNLOAD_AGENT__) && defined(BROWSER_SUPPORT)

//#include "CommonScreens.h"
//#include "ProtocolEvents.h"
#include "app_mine.h"

#include "drm_def.h"                    /* DRM_PROC_RESULT_OK */
#include "drm_gprot.h"
#include "DLAgentSrvDef.h"
#include "DLAgentSrvGprot.h"
#include "DLAgentSrvIProt.h"
#include "DLAgentSrvProt.h"
#ifdef __MMI_DOWNLOAD_AGENT__
#include "mmi_rp_srv_downloadagent_def.h"
#endif
#include "DLAgentSrvWPS.h"

//#include "SimDetectionDef.h"            /* SCR_SIM_INSERTION and SCR_SIM_BLOCK */
//#include "IdleAppDef.h"                 /* IDLE_SCREEN_ID */
//#include "MessagesResourceData.h"       /* IMG_NEW_MESSAGE_NOTIFICATION_MSG */
//#include "FileMgr.h"
//#include "FileManagerDef.h"
#include "FileMgrSrvGprot.h"
//#include "mmi_rp_app_imageviewer_def.h"
//#include "SettingDefs.h"
#include "UCMGProt.h"
//#include "IdleAppProt.h"                /* mmi_idle_is_on_idle_screen */

//#include "wap_ps_struct.h"
//#include "wapadp.h"
//#include "Conversions.h"

#include "USBDeviceGprot.h"             /* mmi_usb_is_in_mass_storage_mode */
//#include "gpioInc.h"                    /* TurnOnBacklight */


    #include "MMIDataType.h"
    #include "MMI_features.h"
    #include "kal_general_types.h"
    #include "wps_struct.h"
    #include "stack_msgs.h"
    #include "mmi_frm_events_gprot.h"
    #include "Unicodexdcl.h"
    #include "das_struct.h"
    #include "kal_public_api.h"
    #include "DebugInitDef_Int.h"
    #include "mmi_frm_mem_gprot.h"
    #include "mmi_rp_srv_downloadagent_def.h"
    #include "GlobalResDef.h"
    #include "CustDataRes.h"
    #include "mmi_frm_queue_gprot.h"
    #include "app_ltlcom.h"
    #include "wap_adp.h"
    #include "wgui_categories_util.h"
    #include "fs_errcode.h"
    #include "string.h"
    #include "FileMgrType.h"
    #include "MMI_conn_app_trc.h"
    #include "mmi_conn_app_trc.h"
    #include "kal_trace.h"
    #include "AlertScreen.h"
    #include "CommonScreensResDef.h"
    #include "app_str.h"
	#include "app_url.h"
    #include "mmi_frm_history_gprot.h"


/****************************************************************************
 * Define
 ****************************************************************************/
#if defined(__MMI_VIDEO_PDL__) || defined(__MMI_AUDIO_PDL__)
#define __MMI_DA_PREFETCHING_SCREEN__
#endif

#define DA_INVALID_SESSION_ID   9999


/****************************************************************************
 * Typedef
 ****************************************************************************/

typedef enum
{
    SRV_DA_HTTP_PREFETCHING_STATE_NONE,
    SRV_DA_HTTP_PREFETCHING_STATE_WAITING,
    SRV_DA_HTTP_PREFETCHING_STATE_CANCELLING,

    SRV_DA_HTTP_PREFETCHING_STATE_END_OF_ENUM
} srv_da_http_prefetching_state_enum;

typedef struct
{
    S32     session_id;
    srv_da_http_prefetching_state_enum state;
} srv_da_http_prefetching_context_struct;



/****************************************************************************
 * Exported Variable
 ****************************************************************************/
 
extern srv_da_acceptance_enum srv_da_http_filename_done(
    U32 criteria, U16* filepath, MMI_BOOL canback, MMI_BOOL canpopup, void *instance);
static void srv_da_http_init_module(void);
static void srv_da_http_get_name(const srv_da_job_struct *job, U16 *buffer, U32 buffer_len);
static MMI_BOOL srv_da_http_free_job(srv_da_job_struct* job);
static const U16* srv_da_http_get_item_filepath(const srv_da_job_struct* job);
static U32 srv_da_http_get_item_progress(const srv_da_job_struct* job, srv_da_item_progress_struct *info);
static void srv_da_http_abort_job(srv_da_job_struct* job, S32 prev_state, MMI_BOOL pauseOnly,
                                  srv_da_abort_callback_type end_callback);
static void srv_da_http_dispatch_job(const srv_da_job_struct* job);
static U16 srv_da_http_get_job_id(const srv_da_job_struct* job);
static void srv_da_http_get_status_desc(
        const srv_da_job_struct *job,
        U16 *string_buffer[],       /* string_buffer[num_of_buffers] */
        const U32 buffer_len,       /* Max length per buffer(line) */
        const U32 num_of_buffers,   /* Number of buffers(lines) */
        U32 *num_of_filled);        /* Number of buffers(lines) filled */
static void srv_da_http_assign_filepath(srv_da_job_struct* job, const U16* new_filepath);
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
static void srv_da_http_resume_job(srv_da_job_struct* job);
#endif
#ifdef __MMI_DA_RESUME__
static void srv_da_http_auto_resume_try_to_resume(void *arg, S32 unique_id);
#endif

extern void srv_da_http_get_setting(const srv_da_job_struct* job, srv_da_setting_struct *setting_data);

const srv_da_module_funcptr_table srv_da_http_module =
{
    srv_da_http_init_module

    ,srv_da_http_get_name
    ,srv_da_http_get_item_filepath
    ,srv_da_http_get_item_progress
    ,srv_da_http_get_job_id
    ,srv_da_http_get_setting
    ,NULL /* is_object_desc_available() */
    ,NULL /* get_object_desc() */
    ,srv_da_http_get_status_desc
    ,NULL /* get_infoURL() */
    
    ,srv_da_http_free_job
    ,srv_da_http_abort_job
    ,srv_da_http_dispatch_job
    ,srv_da_http_assign_filepath
    
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    ,srv_da_http_resume_job
#endif    
};



    


/****************************************************************************
 * Global Variable
 ****************************************************************************/

#ifdef __MMI_DA_PREFETCHING_SCREEN__
static srv_da_http_prefetching_context_struct g_srv_da_http_prefetching_cntx;
#endif

/****************************************************************************
* Function Forward Declaration
*****************************************************************************/


#ifdef __DRM_SUPPORT__
static void srv_da_http_drm_process(srv_da_job_struct *job);
#endif

#ifdef __MMI_DA_RESUME__
static void srv_da_http_wps_session_aborted_callback(U32 arg);
static void srv_da_http_wps_created_callback(MMI_BOOL success, U32 arg);
static void srv_da_http_wps_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause);
#ifdef  __MMI_DOWNLOAD_AGENT_MULTI_DL__
static void srv_da_http_wps_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp);
static void srv_da_http_wps_http_auth_ind_callback(U32 arg);
#ifndef __COSMOS_MMI_PACKAGE__
static void srv_da_http_resume_cancel_callback(void *arg, MMI_BOOL is_deleted);
#endif
#endif
#endif /* __MMI_DA_RESUME__ */


#define END_OF_FUNCTION_DECLARATION


/****************************************************************************
* Function 
*****************************************************************************/



static void srv_da_http_init_module(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

#ifdef __MMI_DA_PREFETCHING_SCREEN__
    g_srv_da_http_prefetching_cntx.session_id = -1;
    g_srv_da_http_prefetching_cntx.state = SRV_DA_HTTP_PREFETCHING_STATE_NONE;
#endif /* __MMI_DA_PREFETCHING_SCREEN__ */
}

#define JOB_TABLE

/*****************************************************************************
 * FUNCTION
 *  srv_da_http_get_name
 * DESCRIPTION
 *  Get item name to be displayed
 * PARAMETERS
 *  job         [IN] Job
 *  buffer      [IN] Buffer to be filled in
 *  buffer_len  [IN] Buffer length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_get_name(const srv_da_job_struct *job, U16 *buffer, U32 buffer_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    mmi_wcsncpy(buffer, job_data->filepath, buffer_len - 1);
    srv_da_util_process_filepath_to_be_displayed(buffer);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_free_job
 * DESCRIPTION
 *  Free download job of HTTP.
 * PARAMETERS
 *  job         [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL srv_da_http_free_job(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(job->type != SRV_DA_JOB_TYPE_NORMAL)
        return MMI_FALSE;
    
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if(job->state == SRV_DA_JOB_STATE_INIT)
    {
        srv_da_send_wap_file_dl_res(job_data->session_id, WAP_DL_ERROR_CANCELLED, NULL);
    }

#ifdef __MMI_DA_RESUME__
    if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }
#endif

    MMI_ASSERT(job_data->drm_process_session == NULL);

#ifdef __DRM_SUPPORT_SD_CALLBACK__
    /* It may still wait for rights (infinitely wait) */
    if (job_data->drm_wait_for_rights_session != NULL)
    {
        srv_da_drm_wait_for_rights_cancel(job_data->drm_wait_for_rights_session);
        job_data->drm_wait_for_rights_session = NULL;
    }
#endif /* __DRM_SUPPORT_SD_CALLBACK__ */

    if ((job->state == SRV_DA_JOB_STATE_ABORTED ||
         job->state == SRV_DA_JOB_STATE_PAUSED ||
         job->state == SRV_DA_JOB_STATE_FAILED ||
		 job->state == SRV_DA_JOB_STATE_RESUMING) &&
         job_data->filepath != NULL && !job->reporting)
    {
        srv_da_util_file_delete(job_data->filepath);
    }
    
    DA_FREE_BUFFER(job_data->url_ptr);
    DA_FREE_BUFFER(job_data->mime_type_ptr);
    DA_FREE_BUFFER(job_data->filepath);
    DA_FREE_BUFFER(job_data->content);
    DA_FREE_BUFFER(job_data->header);
    DA_FREE_BUFFER(job_data->etag);

    OslMfree(job_data);
    job->data_ptr = NULL;
    
    DA_TRACE_ENDFUNC(srv_da_http_free_job);
    return MMI_TRUE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_get_item_filepath
 * DESCRIPTION
 *  Get the filepath of an HTTP download.
 * PARAMETERS
 *  job         [IN] Job
 * RETURNS
 *  Filepath; NOTE: DO NOT MODIFY THE CONTENT RETURNED
 *****************************************************************************/
static const U16* srv_da_http_get_item_filepath(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
    
    return (job_data->filepath);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_get_item_progress
 * DESCRIPTION
 *  Get download progress & status of an HTTP download.
 * PARAMETERS
 *  job         [IN]  Job
 *  info        [OUT] Download status
 * RETURNS
 *  Progress in percent
 *****************************************************************************/
static U32 srv_da_http_get_item_progress(const srv_da_job_struct* job, srv_da_item_progress_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    U32 secs;
    U32 progress;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    info->fileSize = job_data->size;
    info->currSize = job_data->curr_size;
    info->processing_string_id = 0;
    secs = srv_da_util_ticks_to_milli_seconds(job_data->dl_latest_tick - job_data->dl_start_tick) / 1000;
    if(job_data->size && job_data->curr_size && secs)
    {
        info->secs_remain = (U32)((U64)secs * (U64)(job_data->size - job_data->curr_size) / (U64)job_data->curr_size);
    }
    else
    {
        info->secs_remain = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;
    }

    progress = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;

    if(job_data->size > 0)
    {
        progress = (U32)( ((U64)job_data->curr_size * (U64)100) / (U64)(job_data->size) );

        if (progress > 100)
        {
            progress = 100;
        }
    }
    else
    {
        switch(job->state)
        {
            case SRV_DA_JOB_STATE_COMPLETED:
            case SRV_DA_JOB_STATE_PROCESSING:
                progress = 100;
                break;

            default:
                progress = MMI_DA_UTIL_ESTIMATED_TIME_UNKNOWN;
                break;
        }
    }

    return progress;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_get_status_desc
 * DESCRIPTION
 *  Fill the object description of job in string_buffer[]
 * PARAMETERS
 *  job                 [IN]  Job.
 *  string_buffer       [IN]  Array of string buffers
 *  buffer_len          [IN]  Length of each string buffer element (in U16)
 *  num_of_buffers      [IN]  Number of string buffers. That is, this function can only
 *                            fill string_buffer[0..number_of_buffers-1]
 *  num_of_filled       [OUT] Number of filled buffer by this function
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_get_status_desc(
        const srv_da_job_struct *job,
        U16 *string_buffer[],       /* string_buffer[num_of_buffers] */
        const U32 buffer_len,       /* Max length per buffer(line) */
        const U32 num_of_buffers,   /* Number of buffers(lines) */
        U32 *num_of_filled)         /* Number of buffers(lines) filled */
{
#ifdef __DRM_SUPPORT__
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    U16 status_desc_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    status_desc_id = 0;

    switch (job->state)
    {
        case SRV_DA_JOB_STATE_PROCESSING:
            switch (job_data->drm_status)
            {
#if 0 // sahil to do in app
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif //0
                default:
                    break;
            }

            if (status_desc_id != 0)
            {
                mmi_wcsncpy(string_buffer[0], (U16*)GetString(status_desc_id), buffer_len - 1);
                string_buffer[0][buffer_len - 1] = L'\0';
                *num_of_filled = 1;
            }
            else
            {
                *num_of_filled = 0;
            }
            
            break;
            
        default:
            *num_of_filled = 0;
            break;
    }
    
#else /* __DRM_SUPPORT__ */

    *num_of_filled = 0;

#endif /* __DRM_SUPPORT__ */
}


static void srv_da_http_abort_job(srv_da_job_struct* job, S32 prev_state, MMI_BOOL pauseOnly,
                                  srv_da_abort_callback_type end_callback)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wap_mmi_file_dl_stop_req_struct* msg;
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTING);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    job_data->abort_callback = end_callback;

    switch (prev_state)
    {
        case SRV_DA_JOB_STATE_DOWNLOADING:
		case SRV_DA_JOB_STATE_RESUMING:
		

#ifdef __MMI_DA_RESUME__
            if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
            {
                /* Resuming */
                srv_da_wps_close_session(job_data->session, srv_da_http_wps_session_aborted_callback);
                job_data->session = SRV_DA_WPS_INVALID_SESSION;
            }
            else
#endif /* __MMI_DA_RESUME__ */
            if (job_data->session_id != -1) /* DAS downloading */
            {
                msg = (wap_mmi_file_dl_stop_req_struct*) OslConstructDataPtr(sizeof(wap_mmi_file_dl_stop_req_struct));
                msg->session_id = job_data->session_id;
                srv_da_send_ilm_to_wap(msg, NULL, MSG_ID_WAP_MMI_FILE_DL_STOP_REQ);
            }
            else
            {
                job->state = SRV_DA_JOB_STATE_ABORTED;
                end_callback(job, 0);
            }

            break;

#ifdef __DRM_SUPPORT__

        case SRV_DA_JOB_STATE_PROCESSING:

            if (job_data->drm_process_session != NULL)
            {
                srv_da_drm_process_cancel(job_data->drm_process_session);
                return;
            }

#ifdef __DRM_SUPPORT_SD_CALLBACK__
            if (job_data->drm_wait_for_rights_session != NULL)
            {
                srv_da_drm_wait_for_rights_cancel(job_data->drm_wait_for_rights_session);
                job_data->drm_wait_for_rights_session = NULL;
            }
#endif /* __DRM_SUPPORT_SD_CALLBACK__ */

            job->state = SRV_DA_JOB_STATE_ABORTED;
            job_data->drm_status = SRV_DA_DRM_STATUS_NONE;

            end_callback(job, 0);

            break;
            
#endif /*__DRM_SUPPORT__ */ 


        default:
        
            MMI_EXT_ASSERT(MMI_FALSE, job->state, 0, 0);
            break;
    }
}

static void srv_da_http_dispatch_job(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
 if (!srv_da_util_does_file_exist(job_data->filepath))
    {
        srv_da_adp_popup(0, FS_FILE_NOT_FOUND, SRV_DA_POPUP_TYPE_FS_ERROR);
    }
    else
    {
    srv_da_dispatch_to_app(
        DA_MAKE_UNIQUE_ID(job, srv_da_get_job_id(job)),
        job->mime_type,
        MMI_DA_WAP_DOWNLOAD,
        job_data->filepath,
        job_data->url_ptr,
        job_data->mime_type_ptr,
        job->type_handler);
#ifndef __COSMOS_MMI_PACKAGE__
#if defined (__MMI_NCENTER_SUPPORT__)
        if (job->notify_handle != NULL)
		    vsrv_ncenter_close_notification(job->notify_handle);
#endif
#endif
}
        
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_get_job_id
 * DESCRIPTION
 *  Get LOCAL ID of an HTTP download job.
 * PARAMETERS
 *  job         [IN] Job
 * RETURNS
 *  Local ID
 *****************************************************************************/
static U16 srv_da_http_get_job_id(const srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    return job_data->unique_id;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_assign_filepath
 * DESCRIPTION
 *  Assign a new filepath for the file of the job.
 * PARAMETERS
 *  job             [IN/OUT] Job
 *  new_filepath    [IN]     Filepath
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_assign_filepath(srv_da_job_struct* job, const U16* new_filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_COMPLETED);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    UCS2_STR_MALLOC_COPY(job_data->filepath, new_filepath);
}


#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)

static void srv_da_http_resume_job(srv_da_job_struct* job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    U32                         size;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL);
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_RESUMING);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
#ifndef __COSMOS_MMI_PACKAGE__
    srv_da_adp_show_progressing(
        SRV_DA_ACTION_SCR_PLEASE_WAIT,
        SRV_DA_PROCESSING,
        srv_da_job_get_title_icon(job),
        SRV_DA_PLEASE_WAIT,
        MMI_TRUE,
        job,
        srv_da_http_resume_cancel_callback);
#endif

    /* Before resume, check the file length again */
    size = srv_da_util_get_file_size(job_data->filepath);
    if(size)
        job_data->curr_size = size;

    if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }

    /* DLS do not support resume, so we use WPS session */
    job_data->session = srv_da_wps_create_session((U32)job,
                              SRV_DA_WPS_SETTING_DEFAULT,
                              srv_da_http_wps_created_callback,
                              srv_da_http_wps_http_response_callback,
                              srv_da_http_wps_http_auth_ind_callback,
                              srv_da_http_wps_dl_progress_callback);
}
#endif

void srv_da_http_get_setting(const srv_da_job_struct* job, srv_da_setting_struct *setting_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    srv_da_setting_hdlr         setting_hdlr;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_HTTP_DOWNLOAD);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    setting_hdlr = srv_da_default_setting;
    MMI_ASSERT(job->type_handler);
    if(job->type_handler->setting_hdlr)
        setting_hdlr = job->type_handler->setting_hdlr;

    setting_hdlr(
        DA_MAKE_UNIQUE_ID(job, srv_da_get_job_id(job)),
        job->mime_type ? job->mime_type->mime_type : 0,
        job->mime_type ? job->mime_type->mime_subtype : 0,
        MMI_DA_WAP_DOWNLOAD,
        job_data->size,
        job_data->url_ptr,
        job_data->mime_type_ptr,
        job_data->content_len,
        job_data->content,
        setting_data
    );

    MMI_ASSERT(srv_da_setting_check(setting_data));
}


#ifdef __DRM_SUPPORT__

#ifdef __DRM_SUPPORT_SD_CALLBACK__

/*****************************************************************************
 * FUNCTION
 *  srv_da_http_drm_rights_arrived_callback
 * DESCRIPTION
 *  To be notified that DRM rights has been arrived.
 * PARAMETERS
 *  arg                     [IN]  srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_drm_rights_arrived_callback(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_normal_dl_job_struct *job_data;
    srv_da_setting_struct setting;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    job_data->drm_wait_for_rights_session = NULL;
    job_data->drm_status = SRV_DA_DRM_STATUS_RIGHTS_ARRIVED;
    job->state = SRV_DA_JOB_STATE_COMPLETED;
    
    /* Update do_dispatch */
    srv_da_http_get_setting(job, &setting);
    srv_da_copy_setting(job, &setting);

    job->notified_complete = MMI_FALSE;

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

    srv_da_update_job_status(job);
    
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    srv_da_job_drm_save_as(job, job_data->drm_method);

#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_drm_fail_to_wait_callback
 * DESCRIPTION
 *  Callback function for waiting DRM rights failed.
 * PARAMETERS
 *  arg                     [IN]  srv_da_job_struct*
 *  can_continue_waiting    [IN]  If MMI_TRUE, continue_waiting can set to be MMI_TRUE
 *  continue_waiting        [OUT] Continue waiting for rights infinitely
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_drm_fail_to_wait_callback(
    void *arg,
    drm_sd_expiry_type_enum cause,
    MMI_BOOL can_continue_waiting,
    MMI_BOOL *continue_waiting)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_normal_dl_job_struct *job_data;
    U16 *popup_string;
    const U16 *popup_suffix;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (can_continue_waiting)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

        *continue_waiting = MMI_TRUE;

        if (cause == DRM_SD_EXPIRY_TIMEOUT)
        {
            srv_da_adp_popup_long_msg_for_job(job, job_data->filepath);
        }
            
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

        *continue_waiting = MMI_FALSE;
        job_data->drm_wait_for_rights_session = NULL;
        if (cause == DRM_SD_EXPIRY_TIMEOUT)
        {

            srv_da_adp_popup(SRV_DA_RIGHTS_DID_NOT_ARRIVE_ON_TIME, 0, SRV_DA_POPUP_TYPE_INFO);
        }

#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    }
    else
    {
        *continue_waiting = MMI_FALSE;
        job_data->drm_wait_for_rights_session = NULL;
    }

    job_data->drm_status = SRV_DA_DRM_STATUS_NO_RIGHTS;
    job->state = SRV_DA_JOB_STATE_COMPLETED;
    
    /* notifyed_complete will be reset when rights arrived */
    job->notified_complete = MMI_TRUE;
    
    srv_da_update_job_status(job);
}

#endif /*__DRM_SUPPORT_SD_CALLBACK__ */


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_drm_process_callback
 * DESCRIPTION
 *  Callback function for DRM processing result.
 * PARAMETERS
 *  arg             [IN] srv_da_job_struct*
 *  result          [IN] Processing result
 *  new_filepath    [IN] The filepath of processing result(output), it may be
 *                       the same to original path.
 *  method          [IN] DRM method
 *  is_archive      [IN] archive
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_drm_process_callback(
    void *arg,
    S32 result,
    const U16 *new_filepath,
    const applib_mime_type_struct *new_mime_type,
    drm_method_enum method,
    const srv_da_drm_result_info_struct *info)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_normal_dl_job_struct *job_data;
    const applib_mime_type_struct *mime_type_to_rename;
    srv_da_setting_struct setting;
    U16 *filepath_after_moved;
    S32 fs_error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    job_data->drm_process_session = NULL;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
    
        if (job_data->abort_callback != NULL)
        {
            job_data->abort_callback(job, 0);
        }

        return;
    }

    /* The content is useless for the processing result,
       do not pass them to the setting handler */
    job_data->content_len = 0;
    if (job_data->content != NULL)
    {
        OslMfree(job_data->content);
        job_data->content = NULL;
    }

    if (srv_da_job_update_content_by_drm_processing_result(
        job,
        MMI_DA_WAP_DOWNLOAD,
        result,
        new_filepath,
        new_mime_type,
        info))
    {
        mime_type_to_rename = new_mime_type;
        
#ifdef __DRM_V02__
        if(method == DRM_METHOD_V2) /* use .odf for drm 2.0 files */
        {
            mime_type_to_rename = applib_mime_type_look_up(NULL, NULL, MIME_TYPE_APPLICATION, MIME_SUBTYPE_DRM_CONTENT_V2);
        }
#endif /* __DRM_V02__ */

        srv_da_http_get_setting(job, &setting);

        filepath_after_moved = (U16*)srv_da_adp_mem_allocate((SRV_FMGR_PATH_MAX_LEN + 1) * sizeof(U16));

        fs_error = srv_da_move_as_new_type(
            new_filepath,
            setting.folder,
            srv_da_util_get_filename(job_data->filepath),
            mime_type_to_rename,
            filepath_after_moved);

        if (fs_error == FS_NO_ERROR)
        {
            U32 filepath_len;
            
            /* Delete old file */
            if(mmi_wcsicmp(job_data->filepath, filepath_after_moved) != 0)
            {
                srv_da_util_file_delete(job_data->filepath);
            }

            /* Reassign the filepath of the DRM processing result to job */
            filepath_len = mmi_wcslen(filepath_after_moved);
            OslMfree(job_data->filepath);
            job_data->filepath = (U16 *)srv_da_adp_mem_allocate((filepath_len + 1) * sizeof(U16));
            mmi_wcscpy(job_data->filepath, filepath_after_moved);

            srv_da_copy_setting(job, &setting);
            DRM_register_file((kal_wchar*)job_data->filepath);
            job_data->drm_method = method;

#ifdef __DRM_SUPPORT_SD_CALLBACK__
            if (job_data->time_to_wait_for_rights >= 0 &&
                job->mime_type != NULL && /* Only wait for rights when the MIME type is supported */
                !srv_da_drm_has_rights(job_data->filepath, job->mime_type))
            {
                job_data->drm_wait_for_rights_session = srv_da_drm_wait_for_rights(
                    job_data->filepath,
                    job_data->time_to_wait_for_rights,
                    job,
                    srv_da_http_drm_rights_arrived_callback,
                    srv_da_http_drm_fail_to_wait_callback);

                if (job_data->drm_wait_for_rights_session != NULL)
                {
                    job_data->drm_status = SRV_DA_DRM_STATUS_WAITING_FOR_RIGHTS;
                }
                else
                {
                    /* Treat as fail to wait, no rights */
                    job_data->drm_status = SRV_DA_DRM_STATUS_NO_RIGHTS;
                    job->state = SRV_DA_JOB_STATE_COMPLETED;
                    job->setting_info.confirm_dispatch = MMI_FALSE;
                    job->setting_info.do_dispatch = MMI_FALSE;
                }

                srv_da_update_job_status(job);
                
            }
            else
#endif /* __DRM_SUPPORT_SD_CALLBACK__ */
            {
                job->state = SRV_DA_JOB_STATE_COMPLETED;
            
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__

                srv_da_update_job_status(job);
                
#else /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

                srv_da_job_drm_save_as(job, method);
                    
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
            }
        }
        else
        {
            srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_FS_ERROR, fs_error, 0,  MMI_TRUE);
            srv_da_update_job_status(job);
        }

        OslMfree(filepath_after_moved);
    }
    else
    {
        srv_da_update_job_status(job);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_drm_process
 * DESCRIPTION
 *  DRM processing procedure for HTTP.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_drm_process(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    MMI_BOOL need_to_wait;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/  
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    job->state = SRV_DA_JOB_STATE_PROCESSING;

    job_data->drm_wait_for_rights_session = NULL;
    job_data->drm_process_session = srv_da_drm_process(
        job_data->filepath,
        job->mime_type,
        &need_to_wait,
        job,
        srv_da_http_drm_process_callback);

    if (job_data->drm_process_session != NULL)
    {
        if (need_to_wait)
        {
            job_data->drm_status = SRV_DA_DRM_STATUS_PROCESSING;
            srv_da_update_job_status(job);
        }
    }
    else
    {
        /* If no need to wait, it will call the callback function directly */
        /* Whatever the case is, the callback function will be called finally. */
    }
}


#endif /* __DRM_SUPPORT__ */


#define HTTP_UI

#ifndef MMI_DA_PLUTO_SLIM
/*****************************************************************************
 * FUNCTION
 *  srv_da_http_confirm_cancel_callback
 * DESCRIPTION
 *  Handler for user rejected (selected No) the download.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_confirm_cancel_callback(void *arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;

    srv_da_adp_set_active_download_confirm_screen(job, 0);
  
    /* cancel, free resource */
    srv_da_job_cancel(job);
}
#endif

/*****************************************************************************
 * FUNCTION
 *  srv_da_http_confirm_start_to_download_callback
 * DESCRIPTION
 *  Handler for user accepted (Select Yes) the download.
 * PARAMETERS
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_confirm_start_to_download_callback(void *arg, U16 *filepath)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    srv_da_setting_struct       *setting_data;
    srv_da_storage_parameter_struct *para;
    
	U32 error;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (filepath != NULL)
    {
        /* 
         * Venus UI can provide filepath in one go, do not need to activate storage selection 
         * this filepath should never be invalid or co-exist with another download.
         */
        /* assign final path */
        UCS2_STR_MALLOC_COPY(job_data->filepath, filepath);

        /* notify DLS for path */
        srv_da_send_wap_file_dl_res(job_data->session_id, WAP_DL_ERROR_OK, job_data->filepath);

        /* starting download */
        job->state = SRV_DA_JOB_STATE_DOWNLOADING;
        job_data->curr_size = 0;
        kal_get_time(&job_data->dl_start_tick);

        /* download is starting!, push it into list */
        srv_da_job_start(job);

        srv_da_set_allow_to_trigger_connection(MMI_TRUE);
#ifndef MMI_DA_PLUTO_SLIM
        srv_da_adp_show_ncenter (job, SRV_DA_JOB_TYPE_NORMAL);
 #endif       
		if(job->setting_info.filepath_hdlr)
		{
			S32 job_id = DA_MAKE_UNIQUE_ID(job, srv_da_get_job_id(job));
    
			MMI_ASSERT(job->mime_type);

			MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);
        
			job->setting_info.filepath_hdlr(
				job_id,
				job->mime_type->mime_type,
				job->mime_type->mime_subtype,
				filepath);
		}	

        return;
    }
#ifndef MMI_DA_PLUTO_SLIM
    srv_da_adp_set_active_download_confirm_screen(job, 0);
#endif
    /* retrieve setting */
    setting_data = srv_da_get_setting_buffer();
    //srv_da_http_get_setting(job, setting_data);
	srv_da_job_get_setting(job, setting_data);

    /* store setting */
    srv_da_copy_setting(job, setting_data);

    /* prepare storage parameter */
    
    para = (srv_da_storage_parameter_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_storage_parameter_struct));
    
    memset(para, 0, sizeof(srv_da_storage_parameter_struct));
    
    para->drv = setting_data->drv;
    para->storage = setting_data->storage;
    
#ifdef MMI_DA_CFG_SELECT_STORAGE_BEFORE_DOWNLOAD
#ifdef PGDL_SUPPORT_YOUTUBE 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    para->select_storage = setting_data->storage == SRV_DA_STORAGE_NONE ? MMI_TRUE : MMI_FALSE;
	
#else
    if (para->storage == SRV_DA_STORAGE_NONE)
    {
        para->storage = SRV_DA_STORAGE_AUTO;
    }
    para->select_storage = MMI_FALSE;

#endif

    mmi_wcscpy(para->folder, setting_data->folder);
	if (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
		mmi_wcscat(para->folder, L"youtube\\");
   

    if (!setting_data->default_filename && setting_data->filename[0])
    {
        srv_da_extract_filepath(setting_data->filename, para->filename, para->fileext);
    }
    else if (job_data->filepath!= NULL && job_data->filepath[0] != L'\0')
    {
        /* Assigned filepath in FILE_DL msg */
        srv_da_extract_filepath(job_data->filepath, para->filename, para->fileext);
    }
    else
    {
        srv_da_extract_filename_from_url(job_data->url_ptr, para->filename, para->fileext);
    }
if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
{
    if(job->mime_type != NULL)
    {
        mmi_asc_n_to_wcs(para->fileext, job->mime_type->file_ext, SRV_FMGR_PATH_MAX_FILE_EXT_LEN);
    }
}
#ifdef MMI_DA_CFG_INPUT_FILENAME_BEFORE_DOWNLOAD
#ifdef PGDL_SUPPORT_YOUTUBE 
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    para->select_filename = (!setting_data->default_filename && setting_data->filename[0] == 0) ? MMI_TRUE : MMI_FALSE;
#else
    para->select_filename = MMI_FALSE;
#endif

    para->filesize = job_data->size;
    
#ifdef __DRM_SUPPORT__
    /* DRM V1.0 content require twice space */
    if( job->mime_type && 
        (job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_CONTENT ||
         job->mime_type->mime_subtype == MIME_SUBTYPE_DRM_MESSAGE) )
    {
        para->filesize *= 2;
    }
#endif

    /* if app control (provide filepath callback), skip file size checking */

    if(job->setting_info.filepath_hdlr && (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD))
        para->filesize = 0;

    para->filecheck_func = srv_da_does_job_with_filepath_exist;

    if (!(para->select_storage || para->select_filename)) /* Vikas: need to stop redundant event firing from service */
    {
#ifndef MMI_DA_PLUTO_SLIM 
		if (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
		{
			srv_da_decide_yt_filepath ((U32) job, para, MMI_DA_WAP_DOWNLOAD, srv_da_http_filename_done);
		}
		else
#endif
		{
		  error = srv_da_decide_filepath_auto ((U32) job, para, MMI_DA_WAP_DOWNLOAD, srv_da_http_filename_done);
		  if (error != SRV_DA_SCR_SELECT_STORAGE_CAUSE_NONE)
		  {
			  if(job == srv_da_get_curr_job_in_setuping_state())
				srv_da_job_cancel(job);
		  }
		}
	
        OslMfree(para);
        return;
    }

    /* confirmed, select storage now. */
    srv_da_adp_display_select_storage ((U32) job, para, MMI_DA_WAP_DOWNLOAD);
    OslMfree(para);

}


srv_da_acceptance_enum srv_da_http_filename_done(
    U32 criteria, U16* filepath, MMI_BOOL canback, MMI_BOOL canpopup, void *instance)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)criteria;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
    
    if(!filepath)
    {
        /* user cancel, free resource */
        srv_da_job_cancel(job);

        srv_da_adp_set_active_select_storage_instance(NULL);
        return SRV_DA_ACCEPTANCE_ACCEPT;
    }

    /* assign final path */
    UCS2_STR_MALLOC_COPY(job_data->filepath, filepath);

    /* notify DLS for path */
    srv_da_send_wap_file_dl_res(job_data->session_id, WAP_DL_ERROR_OK, job_data->filepath);

    /* starting download */
    job->state = SRV_DA_JOB_STATE_DOWNLOADING;
    job_data->curr_size = 0;
    kal_get_time(&job_data->dl_start_tick);

    /* download is starting!, push it into list */
    srv_da_job_start(job);
#ifdef MMI_DA_WLAN_PREFER_SUPPORT
    srv_da_wap_reset_bearer_type();
#endif /* MMI_DA_WLAN_PREFER_SUPPORT */

    srv_da_set_allow_to_trigger_connection(MMI_TRUE);
    
    if (job->type != SRV_DA_JOB_TYPE_YT_DOWNLOAD)
    {

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if(job->setting_info.can_minimize)
    {
        /* bring up list screen */

        srv_da_adp_display_job_list(job, MMI_TRUE);
    }
    else
#endif
    {
		srv_da_adp_display_job_detail(job);
    }
#ifndef MMI_DA_PLUTO_SLIM
	srv_da_adp_show_ncenter (job, SRV_DA_JOB_TYPE_NORMAL);
	}
	else
	{
#ifndef __COSMOS_MMI_PACKAGE__		
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif
#endif
	}

   
    
    /* notify client that download start */
    if(job->setting_info.filepath_hdlr)
    {
        S32 job_id = DA_MAKE_UNIQUE_ID(job, srv_da_get_job_id(job));
    
        MMI_ASSERT(job->mime_type);

        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);
        
        job->setting_info.filepath_hdlr(
            job_id,
            job->mime_type->mime_type,
            job->mime_type->mime_subtype,
            filepath);
    }


    srv_da_adp_set_active_select_storage_instance(NULL);
    return SRV_DA_ACCEPTANCE_ACCEPT;
}


#define MESSAGE_HANDLERS

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
mmi_ret srv_da_http_display_job_list_callback(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_alert_result_evt_struct *result_evt;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (evt->evt_id == EVT_ID_ALERT_QUIT)
    {
        result_evt = (mmi_alert_result_evt_struct*)evt;
        if (result_evt->result == MMI_ALERT_NORMAL_EXIT)
        {

            srv_da_adp_display_job_list(NULL, MMI_FALSE);
        }
    }

    return MMI_RET_OK;
}

static MMI_BOOL srv_da_http_job_match_url_func(const srv_da_job_struct* job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    
    if(job->type != SRV_DA_JOB_TYPE_NORMAL)
        return MMI_FALSE;
        
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
    if(job_data && app_stricmp(job_data->url_ptr, (S8*)criteria) == 0)
        return MMI_TRUE;

    return MMI_FALSE;
}

#endif


#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#ifdef __MMI_DA_PREFETCHING_SCREEN__
/*****************************************************************************
 * FUNCTION
 *  srv_da_http_do_prefetching_process
 * DESCRIPTION
 *  Check & UI control for prefetching.
 * PARAMETERS
 *  msg         [IN] FILE_DL_IND
 * RETURNS
 *  MMI_TRUE if the FILE_DL_IND is accepted and processed by this function.
 *  recv_wap_file_dl_ind() do need to and should not continue the process.
 *  Otherwise, recv_wap_file_dl_ind() should follow the normal flow.
 *****************************************************************************/
static MMI_BOOL srv_da_http_do_prefetching_process(wap_mmi_file_dl_ind_struct *msg, MMI_BOOL *is_yt_url)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_http_prefetching_context_struct *cntx;
#ifdef PGDL_SUPPORT_YOUTUBE
/* under construction !*/
#endif
	

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cntx = &g_srv_da_http_prefetching_cntx;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_PREFETCHING_PROCESS, msg->session_id, msg->with_content, cntx->state);

    switch (cntx->state)
    {
        case SRV_DA_HTTP_PREFETCHING_STATE_NONE:
            cntx->session_id = -1;
            break; /* To check USB mode, can_receive_file(), need_content.. */

        case SRV_DA_HTTP_PREFETCHING_STATE_WAITING:
            if (cntx->session_id == msg->session_id)
            {
                MMI_ASSERT(msg->with_content);

                cntx->state = SRV_DA_HTTP_PREFETCHING_STATE_NONE;
/* You tube PGDL Support */
#ifdef PGDL_SUPPORT_YOUTUBE
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef MMI_DA_PLUTO_SLIM
/* under construction !*/
/* under construction !*/
#endif  
#endif  
/* under construction !*/
/* under construction !*/
#ifndef __COSMOS_MMI_PACKAGE__			
/* under construction !*/
/* under construction !*/
/* under construction !*/
#ifndef MMI_DA_PLUTO_SLIM
/* under construction !*/
#endif
/* under construction !*/
#endif
#else 
#ifndef __COSMOS_MMI_PACKAGE__			
#ifndef MMI_DA_PLUTO_SLIM		
                srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
  #endif
#endif  
#endif  
                /* We can continue the download */
            }
            else
            {
                srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);
                return MMI_TRUE;
            }
        
            break;

        case SRV_DA_HTTP_PREFETCHING_STATE_CANCELLING:
            if (cntx->session_id == msg->session_id)
            {
                /* Ignore */
            }
            else
            {
                srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);
            }
            
            return MMI_TRUE;

        default:
            MMI_EXT_ASSERT(MMI_FALSE, cntx->session_id, cntx->state, 0);
            break;
    }
    
    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_cancel_prefetching
 * DESCRIPTION
 *  Cancel handler for the "Please wait" of content prefetching.
 * PARAMETERS
 *  arg         [IN] Unused, always NULL
 *  is_deleted  [IN] In deleting context
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_cancel_prefetching(void *arg, MMI_BOOL is_deleted)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_http_prefetching_context_struct *cntx;
    wap_mmi_file_dl_cancel_prefetch_req_struct *cancel_req;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    cntx = &g_srv_da_http_prefetching_cntx;

    switch (cntx->state)
    {
        case SRV_DA_HTTP_PREFETCHING_STATE_WAITING:

            cancel_req =
                (wap_mmi_file_dl_cancel_prefetch_req_struct*)OslConstructDataPtr(sizeof(wap_mmi_file_dl_cancel_prefetch_req_struct));

            cancel_req->session_id = cntx->session_id;

            srv_da_send_ilm_to_wap(cancel_req, NULL, MSG_ID_WAP_MMI_FILE_DL_CANCEL_PREFETCH_REQ);

            if (!is_deleted)
            {
#ifndef __COSMOS_MMI_PACKAGE__
                srv_da_adp_show_progressing(
                    SRV_DA_ACTION_SCR_PLEASE_WAIT,
                    0,
                    0,
                    SRV_DA_GLOBAL_CANCELLING,
                    MMI_FALSE,
                    NULL,
                    NULL);
#endif 
            }

            cntx->state = SRV_DA_HTTP_PREFETCHING_STATE_CANCELLING;
                
            break;

        case SRV_DA_HTTP_PREFETCHING_STATE_NONE:
            /* PREFETCH_ABORTED is received before receive the Cancel event (from key) */
            /* Ignore */
            break;

        default:
            MMI_EXT_ASSERT(MMI_FALSE, cntx->state, cntx->session_id, 0);
            break;
    }

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_cancel_prefetch_rsp_hdlr
 * DESCRIPTION
 *  Message handler for CANCEL_PREFETCH_RSP.
 * PARAMETERS
 *  msg     [IN] wap_mmi_file_dl_cancel_prefetch_rsp_struct*
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_http_cancel_prefetch_rsp_hdlr(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_http_prefetching_context_struct *cntx;
    wap_mmi_file_dl_cancel_prefetch_rsp_struct *cancel_rsp;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    cntx = &g_srv_da_http_prefetching_cntx;

    cancel_rsp = (wap_mmi_file_dl_cancel_prefetch_rsp_struct*)msg;

    MMI_EXT_ASSERT(cancel_rsp->session_id == cntx->session_id, cancel_rsp->session_id, cntx->session_id, cntx->state);

    switch (cntx->state)
    {
        case SRV_DA_HTTP_PREFETCHING_STATE_CANCELLING:
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef MMI_DA_PLUTO_SLIM
            srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PREFETCHING_CANCELLING);
#endif            
#endif            
            cntx->state = SRV_DA_HTTP_PREFETCHING_STATE_NONE;
            break;

        default:
            MMI_EXT_ASSERT(MMI_FALSE, cntx->state, cntx->session_id, 0);
            break;
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_prefetch_aborted_ind_hdlr
 * DESCRIPTION
 *  Message handler for PREFETCH_ABORTED_IND
 * PARAMETERS
 *  msg     [IN] wap_mmi_file_dl_prefetch_aborted_ind_struct*
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_http_prefetch_aborted_ind_hdlr(void *msg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_http_prefetching_context_struct *cntx;
    wap_mmi_file_dl_prefetch_aborted_ind_struct *aborted_ind;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cntx = &g_srv_da_http_prefetching_cntx;
    aborted_ind = (wap_mmi_file_dl_prefetch_aborted_ind_struct*)msg;

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_RECV_PREFETCH_ABORTED, aborted_ind->session_id, aborted_ind->cause, cntx->state);

    MMI_EXT_ASSERT(aborted_ind->session_id == cntx->session_id, aborted_ind->session_id, cntx->session_id, cntx->state);

    switch (cntx->state)
    {
        case SRV_DA_HTTP_PREFETCHING_STATE_WAITING:
            srv_da_adp_popup(0, aborted_ind->cause, SRV_DA_POPUP_TYPE_WAP_ERROR);            
#ifndef __COSMOS_MMI_PACKAGE__            
#ifndef MMI_DA_PLUTO_SLIM       
            srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif 
#endif 
            cntx->state = SRV_DA_HTTP_PREFETCHING_STATE_NONE;
            break;
            
        case SRV_DA_HTTP_PREFETCHING_STATE_CANCELLING:
#ifndef __COSMOS_MMI_PACKAGE__             
#ifndef MMI_DA_PLUTO_SLIM           
srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PREFETCHING_CANCELLING);
#endif            
#endif            
            cntx->state = SRV_DA_HTTP_PREFETCHING_STATE_NONE;
            break;

        default:
            MMI_EXT_ASSERT(MMI_FALSE, cntx->session_id, cntx->state, 0);
            break;
    }
}

#endif /* __MMI_DA_PREFETCHING_SCREEN__ */


void srv_da_recv_wap_file_dl_ind(void *MsgStruct, int mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wap_mmi_file_dl_ind_struct *msg = (wap_mmi_file_dl_ind_struct*)MsgStruct;
    ilm_struct *mmi_ilm_ptr = (ilm_struct*) ilm_p;
    const applib_mime_type_struct *mime_type;
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    const srv_da_type_handler_struct *type_handler;
    srv_da_presetting_struct    presetting;
#ifdef PGDL_SUPPORT_YOUTUBE
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
	MMI_BOOL is_yt = MMI_FALSE;
	//U16 *filepath = (U16 *)OslMalloc(SRV_FMGR_PATH_MAX_LEN + 1); 
	//U16 *filename = (U16 *)OslMalloc(SRV_FMGR_PATH_MAX_LEN + 1);
	//U16 *ext = (U16 *)OslMalloc(SRV_FMGR_PATH_MAX_LEN + 1);
	//memset (filepath, 0, (SRV_FMGR_PATH_MAX_LEN + 1));
	//memset (filename, 0, (SRV_FMGR_PATH_MAX_LEN + 1));
	//memset (ext, 0, (SRV_FMGR_PATH_MAX_LEN + 1));

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_RECV_FILE_DL_IND, msg->session_id);
#ifdef __USB_IN_NORMAL_MODE__
    /* check is in mass storage mode */
    if (srv_usb_is_in_mass_storage_mode())
    {
        /* phone drive is exported, cant use this app */
        /* VIKAS */
        mmi_usb_app_unavailable_popup(0);   /* pass 0 will show default string */
        srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_FILE_ACCESS, NULL);
        return;
    }
#endif /* __USB_IN_NORMAL_MODE__ */
#ifdef PGDL_SUPPORT_YOUTUBE
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
#ifdef __MMI_DA_PREFETCHING_SCREEN__
    if (srv_da_http_do_prefetching_process(msg, &is_yt))
    {
        return;
    }
#endif /* __MMI_DA_PREFETCHING_SCREEN__ */

    if (!srv_da_can_receive_file())
    {
        srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);
        return;
    }



    mime_type = srv_da_util_lookup_mime_type(
        (U8*)(msg->mime_type),
        srv_da_util_get_extension((U16*)msg->file_name),
        MIME_TYPE_NONE,
        MIME_SUBTYPE_NONE);

    DA_TRACE1(MMI_DA_TRC_MIMETYPE, (S32)(mime_type != NULL ? mime_type->mime_subtype : 0));

    type_handler = srv_da_search_mime_type_handler(mime_type);


    /* Get presetting */
    {
        srv_da_presetting_param_struct param;

        param.action = MMI_DA_WAP_DOWNLOAD;
        param.mime_type = mime_type;
        param.uri = (S8*)msg->url;

        if (type_handler->get_presetting != NULL)
        {
            type_handler->get_presetting(&param, &presetting);
        }
        else
        {
            srv_da_default_presetting(&param, &presetting);
        }
    }

#ifdef __MMI_DA_PREFETCHING_SCREEN__
    if (presetting.need_content && !msg->with_content)
    {
        g_srv_da_http_prefetching_cntx.session_id = msg->session_id;
        g_srv_da_http_prefetching_cntx.state = SRV_DA_HTTP_PREFETCHING_STATE_WAITING;
    
        srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_NEED_CONTENT, NULL);
#ifndef __COSMOS_MMI_PACKAGE__ 
        srv_da_adp_show_progressing(
            SRV_DA_ACTION_SCR_PLEASE_WAIT,
            0,
            0,
            SRV_DA_PLEASE_WAIT,
            MMI_TRUE,
            NULL,
            srv_da_http_cancel_prefetching);
#endif 
        
        return;
    }
#endif /* __MMI_DA_PREFETCHING_SCREEN__ */
#ifndef MMI_DA_PLUTO_SLIM
if (mime_type != NULL)
{
	if (srv_da_find_java_job(mime_type->mime_subtype))
	{
		srv_da_adp_popup(SRV_DA_JAVA_JOB_EXIST, 0, SRV_DA_POPUP_TYPE_ERROR);
		srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);
		return;

	}
}
#endif

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    job = srv_da_find_job(srv_da_http_job_match_url_func, (U32)msg->url);
#ifdef __MMI_OMA_DD_DOWNLOAD__
    if(!job)
        job = srv_da_oma_find_job_by_dd((S8*)msg->url);
#endif

    if(job)
    {
        srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);
        srv_da_adp_click_job(job);
        return;
    }
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */

    /* parse message & allocate a new job */
if (!is_yt)
    job = srv_da_job_create(SRV_DA_JOB_TYPE_NORMAL, NULL);
else
	job = srv_da_job_create(SRV_DA_JOB_TYPE_YT_DOWNLOAD, NULL);	

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
#ifdef __DRM_SUPPORT__
    if(!job && srv_da_get_last_error() == SRV_DA_IERROR_EXCEED_MAX_JOB)
    {

        if( srv_da_is_drm_right(mime_type) ||
            srv_da_is_drm_roap(mime_type) )
        {
            job = srv_da_job_create_ex(SRV_DA_JOB_TYPE_NORMAL, NULL);
        }
    }
#endif
#endif


    if (job == NULL)
    {
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
        srv_da_adp_popup_for_error_code_with_callback (srv_da_get_last_error(), srv_da_http_display_job_list_callback);
#endif

        srv_da_send_wap_file_dl_res(msg->session_id, WAP_DL_ERROR_CANCELLED, NULL);

        return;
    }

    job_data = (srv_da_normal_dl_job_struct*)srv_da_adp_mem_allocate(sizeof(srv_da_normal_dl_job_struct));
    memset(job_data, 0, sizeof(srv_da_normal_dl_job_struct));

    job->data_ptr = job_data;

    job_data->session_id = msg->session_id;
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
    job_data->session = SRV_DA_WPS_INVALID_SESSION;
#endif    
    ANSI_STR_MALLOC_COPY(job_data->url_ptr, msg->url, sizeof(msg->url));
    ANSI_STR_MALLOC_COPY(job_data->mime_type_ptr, msg->mime_type, sizeof(msg->mime_type));
    UCS2_STR_MALLOC_COPY(job_data->filepath, msg->file_name);
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
    job_data->size = msg->file_length;
    
    job->mime_type = mime_type;
    job->type_handler = srv_da_search_mime_type_handler(job->mime_type);

    job_data->content = NULL;
    job_data->content_len = 0;
    job_data->header = NULL;
    job_data->header_len = 0;
    job_data->etag = NULL;
#ifdef __DRM_SUPPORT__
    job_data->drm_method = DRM_METHOD_NONE;
#endif
    job_data->drm_status = SRV_DA_DRM_STATUS_NONE;
    job_data->drm_process_session = NULL;
    job_data->drm_wait_for_rights_session = NULL;
    job_data->time_to_wait_for_rights = -1;
    
    if (mmi_ilm_ptr->peer_buff_ptr)
    {
        wap_mmi_file_dl_var_struct buffer;
        kal_uint16 len;

        if( wps_pun_var_part(
                WPS_PUN_UNPACK,
                MSG_ID_WAP_MMI_FILE_DL_IND,
                &buffer,
                get_pdu_ptr(mmi_ilm_ptr->peer_buff_ptr, &len)) > 0)
        {

            if( buffer.header_len > 0 )
            {
                job_data->header_len = buffer.header_len;
                job_data->header = (S8*)get_ctrl_buffer(buffer.header_len+1);
                
                memcpy(job_data->header, buffer.header, buffer.header_len);
                job_data->header[job_data->header_len] = 0;
            }

            if( buffer.content_len > 0 )
            {
                /* Only copy 255 bytes */
                job_data->content_len = buffer.content_len;
                if(job_data->content_len > 255)
                    job_data->content_len = 255;
                job_data->content = (S8*)get_ctrl_buffer(job_data->content_len+1);
                memcpy(job_data->content, buffer.content, job_data->content_len);
                job_data->content[job_data->content_len] = 0;
            }
        }
    }

    job_data->unique_id = srv_da_job_get_new_unique_id();

    /* Extract Etag */
    if (job_data->header != NULL)
    {
        S8 *etag;

        etag = (S8*)srv_da_adp_mem_allocate(MMI_DA_MAX_HTTP_ETAG_LEN);
        if (srv_da_util_extract_from_header(job_data->header, "ETag", etag, MMI_DA_MAX_HTTP_ETAG_LEN) == NULL)
        {
            OslMfree(etag);
        }
        else
        {
            job_data->etag = etag;
        }

#ifdef __DRM_SUPPORT_SD_CALLBACK__
        srv_da_drm_extract_info_from_http_header(job_data->header, &(job_data->time_to_wait_for_rights));
#endif

        DA_TRACE_FUNC3(srv_da_recv_wap_file_dl_ind, 10, (S32)job_data->etag, job_data->time_to_wait_for_rights);
    }
#ifndef MMI_DA_PLUTO_SLIM
   if (presetting.confirm_download &&  !is_yt)
    {
    
        srv_da_adp_show_choice_screen(
            MMI_FALSE,
            job,
            sizeof (srv_da_job_struct),
            srv_da_http_confirm_start_to_download_callback,
            srv_da_http_confirm_cancel_callback,
            srv_da_http_confirm_cancel_callback, 
            MMI_TRUE);
    }
    else
#endif
    {
        srv_da_http_confirm_start_to_download_callback(job, NULL);
    }
}



/*****************************************************************************
 * FUNCTION
 *  srv_da_http_match_wap_dl_session_id
 * DESCRIPTION
 *  If the session_id(criteria) matches the job, it returns MMI_TRUE.
 * PARAMETERS
 *  job         [IN] Job
 *  criteria    [IN] WAP session ID.
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
static MMI_BOOL srv_da_http_match_wap_dl_session_id(const srv_da_job_struct *job, U32 criteria)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)
    {
        job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

        if (job_data->session_id == (S32)criteria)
        {
            return MMI_TRUE;
        }
    }

    return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_recv_wap_file_dl_progress_ind
 * DESCRIPTION
 *  Message handler for FILE_DL_PROGRESS_IND.
 * PARAMETERS
 *  MsgStruct   [IN] Message
 *  mod_src     [IN] Source module
 *  ilm_p       [IN] ILM
 * RETURNS
 *  void
 *****************************************************************************/
void srv_da_recv_wap_file_dl_progress_ind(void *MsgStruct, int mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wap_mmi_file_dl_progress_ind_struct *msg = (wap_mmi_file_dl_progress_ind_struct*) MsgStruct;
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* communicate with lower layer */
    srv_da_send_wap_file_dl_progress_res(msg->session_id, msg->seq_num);

    /* search from job list for session id */
    job = srv_da_find_job(srv_da_http_match_wap_dl_session_id, msg->session_id);

    if(!job)
        return;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    job_data->curr_size = msg->acc_size;

    /* state checking */
    if(job->state == SRV_DA_JOB_STATE_ABORTING)
        return;
    if(job->state != SRV_DA_JOB_STATE_DOWNLOADING)
    {
        MMI_ASSERT(0);
        return;
    }

    /* update status */
    kal_get_time(&job_data->dl_latest_tick);
    job->error_cause = srv_da_wap_error_to_internal_error(msg->cause);

    switch(msg->status)
    {
        case WAP_DL_STATUS_CANCELLED:
            
            MMI_ASSERT(0);
            job->state = SRV_DA_JOB_STATE_ABORTED;
            break;
            
        case WAP_DL_STATUS_ABORTED:
#ifdef __MMI_DA_RESUME__
            if (msg->cause == WAP_DL_ERROR_CONNECTION_CLOSED &&
                !job->was_stopped_by_upper_layer &&
                srv_da_is_allowed_to_trigger_connection())
            {
 #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                /*
                 * MAUI_02662312: When auto resume channel does not get unset because this job status is still in 
                 * downloading, pause download and change the total active download count of WPS, it will be dcreased
                 * and now channel will be released if it is only active download.
                 */
                job->state = SRV_DA_JOB_STATE_PAUSED;
                srv_da_update_job_status(job);
                job->state = SRV_DA_JOB_STATE_DOWNLOADING;
        #endif /* MMI_DA_WLAN_PREFER_SUPPORT */
                /* Keep the job->state == DOWNLOADING */
            #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                if (!srv_da_is_bearer_switching())
            #endif
				{
#ifndef MMI_DA_PLUTO_SLIM
					if (!srv_da_is_pdp_switching())
#endif					
					{
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
                srv_da_util_trigger_proc_ext(srv_da_http_auto_resume_try_to_resume, job, job_data->unique_id);
#endif
                break;
            }
				}
                
            }
#endif /* __MMI_DA_RESUME__ */
#ifndef MMI_DA_PLUTO_SLIM
            if (!srv_da_is_pdp_switching())
#endif
            srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_WAP_ERROR, msg->cause, 0,  MMI_FALSE);

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
            /* update state */
            if(job->setting_info.can_minimize)
            {
                job->state = SRV_DA_JOB_STATE_PAUSED;
            }
            else
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */
            {
                /* remove job, regardless of popup already. */
                job->state = SRV_DA_JOB_STATE_ABORTED;
            }

            break;
            
        case WAP_DL_STATUS_COMPLETE:
            {
                U16 oma_file = MMI_FALSE;
                job->state = SRV_DA_JOB_STATE_COMPLETED;

            #ifdef __DRM_SUPPORT__
                /* parse DRM type first */
                if ((!oma_file) && (srv_da_is_drm_require_processing(job->mime_type)))
                {
                    job_data->session_id = DA_INVALID_SESSION_ID;
                    srv_da_http_drm_process(job);
                    return;
                }
            #endif
            }

            break;
            
        case WAP_DL_STATUS_DOWNLOADING:
            job->state = SRV_DA_JOB_STATE_DOWNLOADING;
            break;
    }

    if (job->state != SRV_DA_JOB_STATE_DOWNLOADING && job->state != SRV_DA_JOB_STATE_ABORTING)
    {
        job_data->session_id = DA_INVALID_SESSION_ID;
    }

    srv_da_update_job_status(job);
}


void srv_da_recv_wap_file_stop_rsp(void *MsgStruct, int mod_src, void *ilm_p)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    wap_mmi_file_dl_stop_rsp_struct *msg;
    srv_da_job_struct               *job;
    srv_da_normal_dl_job_struct     *job_data;
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    U32                             size;
#endif

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    msg = (wap_mmi_file_dl_stop_rsp_struct*) MsgStruct;
    job = srv_da_find_job(srv_da_http_match_wap_dl_session_id, msg->session_id);
    if(!job)
        return;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTING);
    job->state = SRV_DA_JOB_STATE_ABORTED;
    job_data->session_id = DA_INVALID_SESSION_ID;
    
#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    size = srv_da_util_get_file_size(job_data->filepath);
    if(size)
        job_data->curr_size = size;
#endif

    job_data->abort_callback(job, 0);
    // After callback, job may be removed, do not use it.
}


const S8* srv_da_http_get_header(srv_da_job_struct *job, U32* header_len)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if(header_len)
        *header_len = job_data->header_len;
    return job_data->header;
}


#ifdef __MMI_DA_RESUME__
static void srv_da_http_wps_dl_progress_callback(U32 arg, U8 status, U32 curr_size, S32 cause)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    /* state checking */
    if(job->state == SRV_DA_JOB_STATE_ABORTING ||
        job_data->session == SRV_DA_WPS_INVALID_SESSION)
    {
        return;
    }
    
    if(job->state != SRV_DA_JOB_STATE_DOWNLOADING)
    {
        MMI_ASSERT(0);
        return;
    }

    /* update status */
    job_data->curr_size = curr_size;
    kal_get_time(&job_data->dl_latest_tick);

    switch(status)
    {
        case WPS_DL_STATUS_ABORT:
            job->error_cause = srv_da_wps_map_error_code(cause);
        
            if (cause > 0 && /* Network problem */
                !job->was_stopped_by_upper_layer &&
                job_data->size > 0 &&
                srv_da_is_allowed_to_trigger_connection())
            {
        #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                /*
                 * MAUI_02662312: When auto resume channel does not get unset because this job status is still in 
                 * downloading, pause download and change the total active download count of WPS, it will be dcreased
                 * and now channel will be released if it is only active download.
                 */
                job->state = SRV_DA_JOB_STATE_PAUSED;
                srv_da_update_job_status(job);
                job->state = SRV_DA_JOB_STATE_DOWNLOADING;
        #endif /* MMI_DA_WLAN_PREFER_SUPPORT */               
                if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
                {
                    srv_da_wps_close_session(job_data->session, NULL);
                    job_data->session = SRV_DA_WPS_INVALID_SESSION;
                }
            #ifdef MMI_DA_WLAN_PREFER_SUPPORT
                if (!srv_da_is_bearer_switching())
            #endif
				{
#ifndef MMI_DA_PLUTO_SLIM
					if (!srv_da_is_pdp_switching())
#endif                
					{
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
                srv_da_util_trigger_proc_ext(srv_da_http_auto_resume_try_to_resume, job, job_data->unique_id);
#endif					
					}
				}
                break;
            }
        #ifdef MMI_DA_WLAN_PREFER_SUPPORT
            if (!srv_da_is_bearer_switching())
        #endif
#ifndef MMI_DA_PLUTO_SLIM
			{
				if (!srv_da_is_pdp_switching())
            srv_da_adp_popup_wps_aborted(job, cause);
			}
#endif

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
            if(job->setting_info.can_minimize)
            {
                job->state = SRV_DA_JOB_STATE_PAUSED;
            }
            else
#endif /* defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__) */
            {
                job->state = SRV_DA_JOB_STATE_ABORTED;
            }

            if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
            {
                srv_da_wps_close_session(job_data->session, NULL);
                job_data->session = SRV_DA_WPS_INVALID_SESSION;
            }
            break;
            
        case WPS_DL_STATUS_COMPLETE:
            job->state = SRV_DA_JOB_STATE_COMPLETED;

            // close session
            if(job_data->session != SRV_DA_WPS_INVALID_SESSION)
            {
                srv_da_wps_close_session(job_data->session, NULL);
                job_data->session = SRV_DA_WPS_INVALID_SESSION;
            }
            
#ifdef __DRM_SUPPORT__
            /* parse DRM type first */
            if(srv_da_is_drm_require_processing(job->mime_type))
            {
                srv_da_http_drm_process(job);
                return;
            }
#endif
            break;
            
        case WPS_DL_STATUS_DOWNLOADING:
            job->state = SRV_DA_JOB_STATE_DOWNLOADING;
            break;

        default:
            MMI_ASSERT(0);
            break;
    }
    srv_da_update_job_status(job);
}


static void srv_da_http_wps_session_aborted_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    U32                         size;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    /* session closed */
    job_data->session = SRV_DA_WPS_INVALID_SESSION;
    
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_ABORTING);
    job->state = SRV_DA_JOB_STATE_ABORTED;
    
    size = srv_da_util_get_file_size(job_data->filepath);
    if(size)
        job_data->curr_size = size;

    if(job_data->abort_callback)
        job_data->abort_callback(job, 0);
    // After callback, job may be removed, do not use it.
}
#endif /* __MMI_DA_RESUME__ */

#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
#ifndef __COSMOS_MMI_PACKAGE__
static void srv_da_http_resume_cancel_callback(void *arg, MMI_BOOL is_deleted)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct *job;
    srv_da_normal_dl_job_struct *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_RESUMING)
    {
        if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
        {
            srv_da_wps_close_session(job_data->session, NULL);
            job_data->session = SRV_DA_WPS_INVALID_SESSION;
        }
        job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_update_job_status(job);
    }
}
#endif

static void srv_da_http_wps_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    S8                          *header;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL) || (job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD)) ;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (!success)
    {
        job->state = SRV_DA_JOB_STATE_PAUSED;
        srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_RESUME_FAIL, MMI_FALSE);
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
#ifndef MMI_DA_PLUTO_SLIM
        srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
#endif		
		srv_da_update_job_status(job);
        #ifndef __COSMOS_MMI_PACKAGE__
#ifndef MMI_DA_PLUTO_SLIM
		srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);
        #endif
#endif
        return;
    }

    header = (S8 *)srv_da_adp_mem_allocate(128);
    
    if (!srv_da_wps_http_req(
        job_data->session,
        WPS_HTTP_METHOD_GET,
        job_data->url_ptr,
        srv_da_util_gen_http_header_to_resume(header, job_data->etag, job_data->curr_size),
        NULL,
        job_data->filepath,
        WPS_DATA_TYPE_FILE))
    {
        MMI_ASSERT(0);
    }

    OslMfree(header);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_wps_http_response_callback
 * DESCRIPTION
 *  HTTP response handler for manual resumption.
 * PARAMETERS
 *  arg             [IN] (mmi_da_oma_send_report_session_struct*)Session
 *  result          [IN] Result
 *  status          [IN] Status code which server responded
 *  header          [IN] HTTP header
 *  content_type    [IN] Content-Type
 *  content_len     [IN] Content-Length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_wps_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
   
    const applib_mime_type_struct *mime_type;
   

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    DA_TRACE_FUNC3(srv_da_http_wps_http_response_callback, result, status, content_len);
    
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    MMI_ASSERT(job->state == SRV_DA_JOB_STATE_RESUMING);
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;
    
#ifndef __COSMOS_MMI_PACKAGE__
#ifndef MMI_DA_PLUTO_SLIM       
     
    srv_da_adp_scr_progressing_close(SRV_DA_ACTION_SCR_PLEASE_WAIT);

#endif
#endif 

//TODO : do enter dummy and close please wait in adp
    if(result != WPS_OK)
    {
        goto error_cleanup;
    }
    else if (status >= 300 || status < 200)
    {
        goto error_cleanup;
    }
    
    /* check content len */
    if (status != 206)
    {
        /* full content */
        if(job_data->size == 0)
           job_data->size = content_len;
        if(content_len != job_data->size)
        {
            DA_TRACE_FUNC1(srv_da_http_wps_http_response_callback, 1);
            goto error_cleanup;
        }
    }
    else
    {
        if (content_len > 0) /* Content-Length is present */
        {
            if (job_data->size == 0)
            {
                job_data->size = job_data->curr_size + content_len;
            }
            else if (content_len + job_data->curr_size == job_data->size)
            {
                /* OK */
            }
            else if (content_len == job_data->size)
            {
                /*
                 * [MAUI_02630704]
                 * Some server may send the total file length for Content-Length
                 * even for 206 Partial Content.
                 */
            }
            else
            {
                DA_TRACE_FUNC1(srv_da_http_wps_http_response_callback, 2);
                goto error_cleanup;
            }
        }
    }
    
    /* check mimetype */
    mime_type = srv_da_util_lookup_mime_type((U8*)content_type, 
                                                  srv_da_util_get_extension((U16*)job_data->filepath), 
                                                  MIME_TYPE_NONE, MIME_SUBTYPE_NONE);
    /* only need to check if file is typed */
    if(job->mime_type && 
        (!mime_type || 
         mime_type->mime_type != job->mime_type->mime_type || 
         mime_type->mime_subtype != job->mime_type->mime_subtype) )
    {
        DA_TRACE_FUNC1(srv_da_http_wps_http_response_callback, 99);
        goto error_cleanup;
    }
    
    /* its all ok now, Download start! */
    job->state = SRV_DA_JOB_STATE_DOWNLOADING;
	if(job->setting_info.filepath_hdlr)
	{
			S32 job_id = DA_MAKE_UNIQUE_ID(job, srv_da_http_get_job_id(job));
    
			MMI_ASSERT(job->mime_type);

			MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);
        
			job->setting_info.filepath_hdlr(
				job_id,
				job->mime_type->mime_type,
				job->mime_type->mime_subtype,
				job_data->filepath);
			job->reporting = MMI_TRUE;
	}	

    if(status != 206)   /* full content, so reset size */
        job_data->curr_size = 0;
    
    //srv_da_job_start(job);
    kal_get_time(&job_data->dl_start_tick);
//TODO : do display job list, mmi_frm_scrn_close_active_id adp
    srv_da_adp_handle_wps_http_response_callback ((U32)job, status, MMI_FALSE);
   
    return;
    
error_cleanup:
	job->state = SRV_DA_JOB_STATE_PAUSED;
    srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_RESUME_FAIL, MMI_FALSE);
    srv_da_wps_close_session(job_data->session, NULL);
    job_data->session = SRV_DA_WPS_INVALID_SESSION;
    srv_da_adp_handle_wps_http_response_callback ((U32)job, status, MMI_TRUE);
}
                                                  
void srv_da_http_user_auth_callback(U32 criteria, U16* username, U16* password, U32 type)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)criteria;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if(!username || !password)
    {
        if(job->state != SRV_DA_JOB_STATE_INIT && job->state != SRV_DA_JOB_STATE_PAUSED && job->state != SRV_DA_JOB_STATE_RESUMING) 
        {    
            MMI_ASSERT(0);
        }
        if(job->state == SRV_DA_JOB_STATE_PAUSED || job->state == SRV_DA_JOB_STATE_RESUMING)
            job->state = SRV_DA_JOB_STATE_PAUSED;

       srv_da_update_job_status(job);
    }
    else
    {
        // Cache last username/password
        UCS2_STR_MALLOC_COPY(job_data->auth_username, username);
        UCS2_STR_MALLOC_COPY(job_data->auth_password, password);

        /* User input info, it is not valid yet */
        job_data->auth_is_info_valid = MMI_FALSE;
        
        srv_da_wps_session_auth_UCS2(job_data->session, username, password);
    }
}

static void srv_da_http_wps_http_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    /* if auth info not valid yet, it means user need re-input */
    if(!job_data->auth_password || !job_data->auth_username || !job_data->auth_is_info_valid)
    {
        srv_da_adp_show_user_auth_screen((U32) job, (srv_da_auth_callback_type)srv_da_http_user_auth_callback);
    }
    else
    {
        srv_da_wps_session_auth_UCS2(job_data->session, job_data->auth_username, job_data->auth_password);
    }
}

#endif


#define AUTO_RESUME

#ifdef __MMI_DA_RESUME__

/*****************************************************************************
 * FUNCTION
 *  srv_da_http_auto_resume_failed
 * DESCRIPTION
 *  Procedure for auto-resume failed.
 * PARAMETERS
 *  job     [IN] Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_auto_resume_failed(srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    if (job_data->session != SRV_DA_WPS_INVALID_SESSION)
    {
        srv_da_wps_close_session(job_data->session, NULL);
        job_data->session = SRV_DA_WPS_INVALID_SESSION;
    }

    srv_da_adp_popup_error_for_job(job, SRV_DA_POPUP_TYPE_ERROR, 0, SRV_DA_ERROR_CONNECT_CLOSED, MMI_FALSE);

#ifdef __MMI_DOWNLOAD_AGENT_MULTI_DL__
    if (job->setting_info.can_minimize)
    {
        job->state = SRV_DA_JOB_STATE_PAUSED;
    }
    else
#endif /* __MMI_DOWNLOAD_AGENT_MULTI_DL__ */
    {
        job->state = SRV_DA_JOB_STATE_ABORTED;
    }

    srv_da_update_job_status(job);
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_auto_resume_wps_created_callback
 * DESCRIPTION
 *  Auto-resume
 *  When WPS session is created successfully, send HTTP request.
 * PARAMETERS
 *  success     [IN] Session is created successfully
 *  arg         [IN] srv_da_job_struct*
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_auto_resume_wps_created_callback(MMI_BOOL success, U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    S8                          *header;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    MMI_EXT_ASSERT(job->state == SRV_DA_JOB_STATE_PAUSED, job->state, 0, 0);

    if (!success)
    {
        srv_da_http_auto_resume_failed(job);
    }
    else
    {
        header = (S8 *)srv_da_adp_mem_allocate(128);
        
        if (!srv_da_wps_http_req(
            job_data->session,
            WPS_HTTP_METHOD_GET,
            job_data->url_ptr,
            srv_da_util_gen_http_header_to_resume(header, job_data->etag, job_data->curr_size),
            NULL,
            job_data->filepath,
            WPS_DATA_TYPE_FILE))
        {
            MMI_ASSERT(0);
        }

        OslMfree(header);
    }

}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_auto_resume_wps_http_response_callback
 * DESCRIPTION
 *  For auto-resume.
 *  Check the HTTP response, to determine whether we successfully resumed.
 *  If not, prompt error message to the user eventually.
 * PARAMETERS
 *  arg             [IN] (mmi_da_oma_send_report_session_struct*)Session
 *  result          [IN] Result
 *  status          [IN] Status code which server responded
 *  header          [IN] HTTP header
 *  content_type    [IN] Content-Type
 *  content_len     [IN] Content-Length
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_auto_resume_wps_http_response_callback(
    U32 arg,
    U8 result,
    U16 status,
    S8 *header,
    S8 *content_type,
    U32 content_len,
    const wps_http_rsp_struct *rsp)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    const applib_mime_type_struct *mime_type;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (job->state == SRV_DA_JOB_STATE_ABORTING)
    {
        return;
    }

    MMI_EXT_ASSERT(job->state == SRV_DA_JOB_STATE_PAUSED, job->state, 0, 0);

    MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_AUTO_RESUME_HTTP_RSP,
            DA_MAKE_UNIQUE_ID(job, job_data->unique_id), result, status,
            job_data->curr_size, content_len, job_data->size);

    /* check result */
    if(result != WPS_OK)
    {
        goto auto_resume_failed;
    }
    else
    {
        if (status != 206)
        {
            goto auto_resume_failed;
        }
        else
        {
            if (content_len == 0)
            {
                /* We can not guarantee the content is the same to before */
                goto auto_resume_failed;
            }
            else if (job_data->curr_size + content_len != job_data->size)
            {
                goto auto_resume_failed;
            }
        }
    }
    
    /* check mimetype */
    mime_type = srv_da_util_lookup_mime_type((U8*)content_type, NULL, MIME_TYPE_NONE, MIME_SUBTYPE_NONE);

    /* Suppose their pointers will be the same (the same entry of our MIME type table) */
    if(job->mime_type != mime_type)
    {
        goto auto_resume_failed;
    }
    job->state = SRV_DA_JOB_STATE_DOWNLOADING;
	if(job->setting_info.filepath_hdlr)
	{
			S32 job_id = DA_MAKE_UNIQUE_ID(job, srv_da_http_get_job_id(job));
    
			MMI_ASSERT(job->mime_type);

			MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_FILEPATH_HDLR, job_id);
        
			job->setting_info.filepath_hdlr(
				job_id,
				job->mime_type->mime_type,
				job->mime_type->mime_subtype,
				job_data->filepath);
			job->reporting = MMI_TRUE;
	}
    srv_da_update_job_status(job);
    return;
    
auto_resume_failed:

    srv_da_http_auto_resume_failed(job);
    
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_auto_resume_auth_ind_callback
 * DESCRIPTION
 *  Treat as resume failed if need authentication again.
 * PARAMETERS
 *  arg         [IN] (srv_da_job_struct*)Job
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_auto_resume_auth_ind_callback(U32 arg)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct     *job_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    job = (srv_da_job_struct*)arg;
    MMI_ASSERT(job && (job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD));
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    /* if auth info not valid yet, it means user need re-input */
    if(!job_data->auth_password || !job_data->auth_username || !job_data->auth_is_info_valid)
    {
#if defined(__MMI_DOWNLOAD_AGENT_MULTI_DL__) && defined(__MMI_DA_RESUME__)
        srv_da_adp_show_user_auth_screen((U32) job, (srv_da_auth_callback_type)srv_da_http_user_auth_callback);
#endif
    }
    else
    {
        srv_da_wps_session_auth_UCS2(job_data->session, job_data->auth_username, job_data->auth_password);
    }
}


/*****************************************************************************
 * FUNCTION
 *  srv_da_http_auto_resume_try_to_resume
 * DESCRIPTION
 *  For auto-resume.
 *  Try to resume. If the job is not in DOWNLOADING state, the resumption
 *  will not be triggered.
 * PARAMETERS
 *  arg         [IN] (srv_da_job_struct*)Job
 *  unique_id   [IN] This ID should match the job's
 * RETURNS
 *  void
 *****************************************************************************/
static void srv_da_http_auto_resume_try_to_resume(void *arg, S32 unique_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_job_struct           *job;
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    job = (srv_da_job_struct*)arg;
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (!srv_da_is_job_valid(job) ||
        job->type != SRV_DA_JOB_TYPE_NORMAL ||
        job_data->unique_id != unique_id)
    {
        return;
    }

    /* To auto resume, the state should be still DOWNLOADING */
    if (job->state != SRV_DA_JOB_STATE_DOWNLOADING)
    {
        return;
    }
    job->state = SRV_DA_JOB_STATE_PAUSED;
	srv_da_update_job_status(job);
    MMI_ASSERT(job_data->session == SRV_DA_WPS_INVALID_SESSION);

    if (srv_da_is_allowed_to_trigger_connection())
    {
        MMI_TRACE(MMI_DA_TRACE_GROUP, MMI_DA_TRC_AUTO_RESUME_TRY,
            DA_MAKE_UNIQUE_ID(job, job_data->unique_id), job_data->curr_size);
    
        job_data->session = srv_da_wps_create_session((U32)job,
                              SRV_DA_WPS_SETTING_DEFAULT,
                              srv_da_http_auto_resume_wps_created_callback,
                              srv_da_http_auto_resume_wps_http_response_callback,
                              srv_da_http_auto_resume_auth_ind_callback,
                              srv_da_http_wps_dl_progress_callback);
    }
    else
    {
        srv_da_http_auto_resume_failed(job);
    }
}
#endif /* __MMI_DA_RESUME__ */

#ifdef __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__
MMI_BOOL srv_da_http_is_browser_job (srv_da_job_struct *job)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    srv_da_normal_dl_job_struct *job_data;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (job == NULL)
    {
        return MMI_FALSE;
    }
    MMI_ASSERT(job->type == SRV_DA_JOB_TYPE_NORMAL || job->type == SRV_DA_JOB_TYPE_YT_DOWNLOAD);    
    job_data = (srv_da_normal_dl_job_struct*)job->data_ptr;

    if (job_data->session == SRV_DA_WPS_INVALID_SESSION)
		return MMI_TRUE;
	else
		return MMI_FALSE;
}
#endif /* __MMI_DA_DOWNLOAD_AUTO_RESUME_WHEN_BROWSER_EXIT__ */

#endif /* defined(__MMI_DOWNLOAD_AGENT__) && defined(BROWSER_SUPPORT) */


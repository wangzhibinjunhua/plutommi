/*****************************************************************************
*  Copyright Statement:
*  --------------------
*  This software is protected by Copyright and the information contained
*  herein is confidential. The software may not be copied and the information
*  contained herein may not be used or disclosed except with the written
*  permission of MediaTek Inc. (C) 2005
*
*  BY OPENING THIS FILE, BUYER HEREBY UNEQUIVOCALLY ACKNOWLEDGES AND AGREES
*  THAT THE SOFTWARE/FIRMWARE AND ITS DOCUMENTATIONS ("MEDIATEK SOFTWARE")
*  RECEIVED FROM MEDIATEK AND/OR ITS REPRESENTATIVES ARE PROVIDED TO BUYER ON
*  AN "AS-IS" BASIS ONLY. MEDIATEK EXPRESSLY DISCLAIMS ANY AND ALL WARRANTIES,
*  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF
*  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE OR NONINFRINGEMENT.
*  NEITHER DOES MEDIATEK PROVIDE ANY WARRANTY WHATSOEVER WITH RESPECT TO THE
*  SOFTWARE OF ANY THIRD PARTY WHICH MAY BE USED BY, INCORPORATED IN, OR
*  SUPPLIED WITH THE MEDIATEK SOFTWARE, AND BUYER AGREES TO LOOK ONLY TO SUCH
*  THIRD PARTY FOR ANY WARRANTY CLAIM RELATING THERETO. MEDIATEK SHALL ALSO
*  NOT BE RESPONSIBLE FOR ANY MEDIATEK SOFTWARE RELEASES MADE TO BUYER'S
*  SPECIFICATION OR TO CONFORM TO A PARTICULAR STANDARD OR OPEN FORUM.
*
*  BUYER'S SOLE AND EXCLUSIVE REMEDY AND MEDIATEK'S ENTIRE AND CUMULATIVE
*  LIABILITY WITH RESPECT TO THE MEDIATEK SOFTWARE RELEASED HEREUNDER WILL BE,
*  AT MEDIATEK'S OPTION, TO REVISE OR REPLACE THE MEDIATEK SOFTWARE AT ISSUE,
*  OR REFUND ANY SOFTWARE LICENSE FEES OR SERVICE CHARGE PAID BY BUYER TO
*  MEDIATEK FOR SUCH MEDIATEK SOFTWARE AT ISSUE. 
*
*  THE TRANSACTION CONTEMPLATED HEREUNDER SHALL BE CONSTRUED IN ACCORDANCE
*  WITH THE LAWS OF THE STATE OF CALIFORNIA, USA, EXCLUDING ITS CONFLICT OF
*  LAWS PRINCIPLES.  ANY DISPUTES, CONTROVERSIES OR CLAIMS ARISING THEREOF AND
*  RELATED THERETO SHALL BE SETTLED BY ARBITRATION IN SAN FRANCISCO, CA, UNDER
*  THE RULES OF THE INTERNATIONAL CHAMBER OF COMMERCE (ICC).
*
*****************************************************************************/
/*****************************************************************************
 *
 * Filename:
 * ---------
 *  Swatch.c
 *
 * Project:
 * --------
 *  MAUI
 *
 * Description:
 * ------------
 *  Swatch
 *
 * Author:
 * -------
 * -------
 *                      
 *============================================================================
 *             HISTORY
 * Below this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *------------------------------------------------------------------------------
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 * removed!
 * removed!
 * removed!
 *
 *------------------------------------------------------------------------------
 * Upper this line, this part is controlled by PVCS VM. DO NOT MODIFY!!
 *============================================================================
 ****************************************************************************/

/****************************************************************************
* Include Files                                                                
*****************************************************************************/
#include "mmi_features.h"

#ifdef __MMI_WEARABLE_DEVICE__
#include "globalresdef.h"
#include "gdi_include.h"
#include "wgui.h"
#include "gui_typedef.h"
#include "gui_effect_oem.h"
#include "Wgui_categories_util.h"
#include "MiscFunctions.h"
#include "app_datetime.h"
#include "mmi_common_app_trc.h"
#include "mmi_trc_int.h"
#include "mmi_frm_input_gprot.h"
#include "idlememcfg.h"
#include "gpiosrvgprot.h"
#include "Swatch.h"
#include "SwatchGprot.h"
#include "mmi_rp_app_idle_swatch_def.h"
#include "mmi_rp_app_scr_locker_def.h"
#ifdef __MMI_BT_NOTI_SRV__
#include "mmi_rp_srv_bt_noti_def.h"
#endif

#ifdef MMI_DOWNLOADABLE_CLOCK
#include "AppMgrSrvGprot.h"
#include "MREAppMgrSrvGprot.h"
#endif

#ifdef __MMI_MAINLCD_128X32__
#include "BootupSrvGprot.h"
#endif

#ifdef __MTK_TARGET__
#define __MAUI_SOFTWARE_LA__
#endif

#ifdef __MAUI_SOFTWARE_LA__
#include "SST_sla.h"
#endif

#ifdef __MMI_BT_SUPPORT__
#include "BtcmSrvGprot.h"
#endif

#include "PhbSrvGprot.h"

/*
SWLA labels:
DB -- Draw Background
UC -- Update Clock
UAP  -- Update AP
UAPE  -- Update AP ext
*/

#if defined(__TINY_SYS__)
#include "ts_swatch.h"
#include "csci.h"
#include "AP_BtSS.h"
#include "ts_display_config.h"

#if defined(__MMI_MAINLCD_320X320__)
#define MMI_SWATCH_ANALOG_BEGIN_ADDRESS 3800
#else
#define MMI_SWATCH_ANALOG_BEGIN_ADDRESS 3800
#endif

#if defined (__UPDATE_BINARY_FILE__)
CSCI_EXTERN_VAR(ts_mmi_idle_swatch_config_table,ts_tiny_skin_data);/*defined in hal\system\AP_BtSS\src\AP_UBin_CSCI.c*/
CSCI_EXTERN_VAR(ts_mmi_idle_swatch_resource_buffer,ts_resource_buf);/*defined in hal\system\AP_BtSS\src\AP_UBin_CSCI.c*/
#else
CSCI_DEFINE_VAR(ts_mmi_idle_swatch_config_table, ts_tiny_skin_data);
CSCI_DEFINE_VAR(ts_mmi_idle_swatch_resource_buffer, ts_resource_buf);
#endif /*defined (__UPDATE_BINARY_FILE__)*/
CSCI_DEFINE_ARR(kal_uint8,g_ts_bl_pbar_buff,TINY_FB_SIZE);
#endif


static mmi_idle_swatch_context_struct g_mmi_idle_swatch_cntx;
mmi_idle_swatch_context_struct *g_idle_swatch_p = &g_mmi_idle_swatch_cntx;
static void mmi_idle_swatch_update(void);
static void mmi_idle_swatch_draw_bg(void);

#ifdef G2D_SUPPORT
static void mmi_idle_swatch_set_traslation(mmi_idle_swatch_matrix_struct *matrix, float tx, float ty);
static void mmi_idle_swatch_rotate_z(mmi_idle_swatch_matrix_struct *matrix, U8 angle);
static void mmi_idle_swatch_set_identity(mmi_idle_swatch_matrix_struct *matrix);
static void mmi_idle_swatch_matrix_multiply(mmi_idle_swatch_matrix_struct *matrix_a, mmi_idle_swatch_matrix_struct *matrix_b, mmi_idle_swatch_matrix_struct *matrix_out);
#endif

#ifdef MMI_DOWNLOADABLE_CLOCK
#define MMI_SWATCH_CLOCK_APP_NUM 10
#if defined(__MMI_MAINLCD_240X240__)
#define MMI_NATIVE_CLOCK_NUM 4
#else
#define MMI_NATIVE_CLOCK_NUM 2
#endif
#define MMI_SWATCH_PREVIEW_IMAGE    "preview.png"
#define MMI_SWATCH_STRUCT_RESOURCE    "Structtable.bin"

static MMI_BOOL mmi_idle_swatch_need_launch_vxp();

static MMI_BOOL mmi_idle_swatch_get_download_image_info(S32 index,
                                                             S32 *width,
                                                             S32 *height,
                                                             MMI_BOOL is_tiny);

static void mmi_idle_swatch_draw_download_image(S32 index,
                                                             S32 x,
                                                             S32 y,
                                                             MMI_BOOL is_tiny);

static void mmi_idle_swatch_draw_resized_download_image(S32 index,
                                                                      S32 x,
                                                                      S32 y,
                                                                      S32 width,
                                                                      S32 height,
                                                                      MMI_BOOL is_tiny);
#else
#if defined(__MMI_MAINLCD_240X240__)
#define MMI_SWATCH_CLOCK_APP_NUM 4
#else
#define MMI_SWATCH_CLOCK_APP_NUM 2
#endif
#endif

static mmi_idle_swatch_config_table g_swatch_config_table[MMI_SWATCH_CLOCK_APP_NUM] =
{
/* Swatch 1 -- Analog */
#if defined(__MMI_MAINLCD_128X128__)
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT}, //MMI_IDLE_SWATCH_HEIGHT-21/*AP area height*/},  //area
        {
            0, 0,  //bg_x, bg_y
            64, 64,  //center_x, center_y
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            MMI_TRUE,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_BG,  //bg_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_BG,  //Tiny_analog_bg
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_HOUR_HAND,  //hour_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_HOUR_HAND,  //Tiny_analog_bg
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_MINUTE_HAND,  //minute_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_MINUTE_HAND,  //Tiny_analog_bg
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_SECOND_HAND  //second_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_KEY_SECOND_HAND,  //Tiny_analog_bg
            #endif
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            0
            #endif
        }  //data
    }    
},
#elif defined(__MMI_MAINLCD_128X32__)
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT},  //area
        {
            0, MMI_IDLE_SWATCH_HEIGHT,  //bg_x, bg_y
			39, 8,  //hour_x, hour_y 50
            67, 8,  //minute_x, minute_y  55
            0, 0,  //ampm_x, ampm_y  99
            1, 1,  //hour_num_gap, minute__num_gap
            NULL,  //bg_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            NULL,
        #endif
            IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_N0,  //hour_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_N0,
        #endif
            IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_N0,  //minute_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_N0,
        #endif
            NULL,  //am_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            NULL,
        #endif
            NULL,  //pm_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            NULL,
        #endif
            MMI_TRUE  //add_zero
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
	{
		MMI_IMAGE_SRC_TYPE_RES_ID,
		NULL,
		0,
		NULL,
		0
    }
#endif
}
#elif defined(__MMI_MAINLCD_320X320__)
/* Swatch 1 -- Analog */
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT/*AP area height*/},  //area
        {
            69, 69,  //bg_x, bg_y
            159, 159,  //center_x, center_y
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            MMI_TRUE,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_CLOCK_BG,  //bg_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_BG_IMAGE,  //Tiny_analog_bg
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_HOUR_HAND,  //hour_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_1_HOUR_HAND,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_MINUTE_HAND,  //minute_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_1_MINUTE_HAND,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_SECOND_HAND,  //second_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_ANALOG_SECOND_HAND_IMAGE,
            #endif
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            0,
            #endif
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
      {
        MMI_IMAGE_SRC_TYPE_RES_ID,
        NULL,
        0,
        IMG_ID_IDLE_SWATCH_PREVIEW_1,
        0
    }
#endif
},
/* Swatch 2 -- Digital */
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT},  //area
        {
            0, 0,  //bg_x, bg_y
            103, 89,  //hour_x, hour_y
            103, 163,  //minute_x, minute_y
            217, 163,  //ampm_x, ampm_y
            2, 2,  //hour_num_gap, minute__num_gap
            NULL,  //bg_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            NULL,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_NUM_0,  //hour_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_NUM_0,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_NUM_0,  //minute_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_NUM_0,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_AM,  //am_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_AM,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_PM,  //pm_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_PM,
        #endif
            MMI_TRUE  //add_zero
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
    {
        MMI_IMAGE_SRC_TYPE_RES_ID,
        NULL,
        0,
        IMG_ID_IDLE_SWATCH_PREVIEW_2,
        0
    }
#endif
},
#else
/* Swatch 1 -- Analog */
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT-21/*AP area height*/},  //area
        {
            29, 29,  //bg_x, bg_y
            119, 119,  //center_x, center_y
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            MMI_TRUE,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_CLOCK_BG,  //bg_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_BG_IMAGE,  //Tiny_analog_bg
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_HOUR_HAND,  //hour_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_1_HOUR_HAND,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_MINUTE_HAND,  //minute_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_1_MINUTE_HAND,
            #endif
            IMG_ID_IDLE_SWATCH_ANALOG_1_SECOND_HAND,  //second_hand_img_id
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_ANALOG_SECOND_HAND_IMAGE,
            #endif
            0,
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            0,
            #endif
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
	  {
		MMI_IMAGE_SRC_TYPE_RES_ID,
		NULL,
		0,
		IMG_ID_IDLE_SWATCH_PREVIEW_1,
		0
    }
#endif
},
/* Swatch 2 -- Digital */
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL,  //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT},  //area
        {
            0, 0,  //bg_x, bg_y
			63, 49,  //hour_x, hour_y
            63, 123,  //minute_x, minute_y
            177, 123,  //ampm_x, ampm_y
            2, 2,  //hour_num_gap, minute__num_gap
            NULL,  //bg_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            NULL,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_NUM_0,  //hour_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_NUM_0,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_NUM_0,  //minute_num_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_NUM_0,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_AM,  //am_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_AM,
        #endif
            IMG_ID_IDLE_SWATCH_DIGITAL_1_PM,  //pm_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_TINY_DIGIT1_PM,
        #endif
            MMI_TRUE  //add_zero
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
	{
		MMI_IMAGE_SRC_TYPE_RES_ID,
		NULL,
		0,
		IMG_ID_IDLE_SWATCH_PREVIEW_2,
        0
    }
#endif
},
/*Analog 3*/
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG,    //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT-21/*AP area height*/},  //area
        {
            0, 0,  //bg_x, bg_y
            119, 119,  //center_x, center_y
            0,
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            MMI_FALSE,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_2_CLOCK_BG,  //bg_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_2_CLOCK_BG_TINY,  //Tiny_analog_bg
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_2_HOUR_HAND,    //hour_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_2_HOUR_HAND_TINY,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_2_MINUTE_HAND,  //minute_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_2_MINUTE_HAND_TINY,
        #endif
            0,  //second_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            0,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_2_NAIL,
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_2_NAIL_TINY,
        #endif
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
    {
        MMI_IMAGE_SRC_TYPE_RES_ID,
        NULL,
        0,
        IMG_ID_IDLE_SWATCH_ANALOG_2_PREVIEW,
        0
    }
#endif
},
/*Analog 4*/
{
    /* Clock */
    {
        MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG,    //type
        {0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT-21/*AP area height*/},  //area
        {
            0, 0,  //bg_x, bg_y
            119, 119,  //center_x, center_y
            0,
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            MMI_TRUE,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_3_CLOCK_BG,  //bg_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_3_CLOCK_BG_TINY,    //Tiny_analog_bg
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_3_HOUR_HAND,    //hour_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_3_HOUR_HAND_TINY,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_3_MINUTE_HAND,  //minute_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_3_MINUTE_HAND_TINY,
        #endif
            0,    //second_hand_img_id
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            0,
        #endif
            IMG_ID_IDLE_SWATCH_ANALOG_3_NAIL,
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            IMG_ID_IDLE_SWATCH_ANALOG_3_NAIL_TINY,
        #endif
        }  //data
    },
#ifdef MMI_DOWNLOADABLE_CLOCK
    {
        MMI_IMAGE_SRC_TYPE_RES_ID,
        NULL,
        0,
        IMG_ID_IDLE_SWATCH_ANALOG_3_PREVIEW,
        0
    }
#endif
},
#endif
};
#ifdef __MMI_MAINLCD_128X128__
static void mmi_idle_swatch_enter_digit_screen(void);
#endif

#ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
mmi_swatch_language_mapping_table_struct g_mmi_swatch_language_mapping_table[] =
{
    {MMI_SWATCH_LANGUAGEEN,"English", "*#0044#"},
    {MMI_SWATCH_LANGUAGECH,"Chinese", "*#0086#"},
    {MMI_SWATCH_LANGUAGECHTR,"TRChinese","*#0886#"},
    {MMI_SWATCH_LANGUAGE_TATAL,"",""}
};

extern U16 gCurrLangIndex;
extern const sLanguageDetails mtk_gLanguageArray[];

/*****************************************************************************
 * FUNCTION
 *  ColorBall_Get_Current_Language_Index
 * DESCRIPTION
 *  get current language index
 * PARAMETERS
 *  void
 * RETURNS
 * BOOL
 *****************************************************************************/
U16 mmi_swatch_get_current_language_index()
{
    U8 i = 0;
    
    for (i = MMI_SWATCH_LANGUAGEEN ; i < MMI_SWATCH_LANGUAGE_TATAL ; i++)
    {
        if(strcmp((PS8)mtk_gLanguageArray[gCurrLangIndex].aLangSSC, (PS8)g_mmi_swatch_language_mapping_table[i].aLangSSC) == 0)
            return i;
    }

    kal_prompt_trace(MOD_MMI_COMMON_APP,"mmi_swatch_get_current_language_index i = %d");
    return 0;
}


#endif


#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
static void mmi_idle_swatch_blt_previous(void);
static void mmi_idle_swatch_enter_bw_screen(void);

#ifdef MTK_INTERNAL_TEST
swatch_btss_string_struct swatch_btss_ind_string[2]={"SUSM",
                                                     "HERM"};
#endif


void mmi_idle_watch_transform_apply_point(mmi_idle_swatch_matrix_struct *matrix, 
	                                          mmi_idle_watch_position *point)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    float px, py, u, v, w;
    const float *m = matrix->m;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    px = point->x;
    py = point->y;

    u = px * m[0] + py * m[1] + m[2];
    v = px * m[3] + py * m[4] + m[5];
    w = px * m[6] + py * m[7] + m[8];

    /* get rid of divided by zero */
    // TODO: maybe assert...
    if (w == 0)
    {
        w = 1;
    }

    point->x = u / w;
    point->y = v / w;
}


void mmi_swatch_idle_get_output_rect(mmi_idle_swatch_matrix_struct *matrix, 
                                             S32 in_width, 
                                             S32 in_height, 
                                             mmi_idle_watch_rect_struct *rect)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32     i;
    float   x1, y1, x2, y2;
    float   x, y;

    mmi_idle_watch_position vertex[4];

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* top-left point */
    vertex[0].x = 0;
    vertex[0].y = 0;
    /* top-right point */
    vertex[1].x = (float)(in_width - 1);
    vertex[1].y = 0;
    /* bottom-left point */
    vertex[2].x = 0;
    vertex[2].y = (float)(in_height - 1);
    /* bottom-right point */
    vertex[3].x = (float)(in_width - 1);
    vertex[3].y = (float)(in_height - 1);

    x1 = 1000000;
    y1 = 1000000;
    x2 = -1000000;
    y2 = -1000000;

    /* get the output rect */
    for (i = 0; i < 4; i++)
    {
        mmi_idle_watch_transform_apply_point(matrix, &vertex[i]);

        x = vertex[i].x;
        y = vertex[i].y;

        if (x < x1)
        {
            x1 = x;
        }

        if (x > x2)
        {
            x2 = x;
        }

        if (y < y1)
        {
            y1 = y;
        }

        if (y > y2)
        {
            y2 = y;
        }
    }

    /* enlarge the output rect a little to be safer from errors */
    // TODO: These are experiment values...
    x1 -= 1;
    y1 -= 1;
    x2 += 1;
    y2 += 1;

    rect->x1 = x1;
    rect->x2 = x2;
    rect->y1 = y1;
    rect->y2 = y2;
}

void mmi_tiny_encode_image_to_buffer(MMI_ID img_id,
                                     S8 index,
                                     S8 img_index,
                                     MMI_BOOL is_download,
                                     MMI_BOOL is_rotate)
{
    S32 width, height, i, count, j;
	PU8 temp_buffer, temp_encode_buffer,rotate_buf;
	gdi_handle handler, handler1, rotate_handle;
	S32 encode_size;
	PU8 dst_ptr;
	int ret;
	PU8 index_buf;
	S32 temp_count, temp_height, temp_width, temp_offsety, rotate_w, rotate_h;
	mmi_idle_swatch_matrix_struct matrix_translation, matrix_rotate_z, matrix_result;
	mmi_idle_watch_rect_struct rect;
    mmi_idle_swatch_analog_clock *maui_analog_clock;

	index_buf = ts_resource_buf.data_buf;

    if(is_rotate == MMI_TRUE)
    {
        #ifdef MMI_DOWNLOADABLE_CLOCK
        if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            if(mmi_idle_swatch_get_download_image_info(img_id, &width, &height, MMI_TRUE) == MMI_FALSE)
            {
                return;
            }
        }
		else
		#endif
		{
            gdi_image_get_dimension_id(img_id, &width, &height);
		}
        maui_analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);

        if(img_index == 3)
        {
            if(g_idle_swatch_p->swatch_index == 0)
            {
                temp_height = 64;
                temp_offsety = -44;
                temp_width = 7;
            }
            else if(g_idle_swatch_p->swatch_index == 2)
            {
                temp_height = 64;
                temp_offsety = -44;
                temp_width = 7;
            }
            else if(g_idle_swatch_p->swatch_index == 3)
            {
                temp_height = 64;
                temp_offsety = -44;
                temp_width = 7;
            }
        }
        else
        {
            if(g_idle_swatch_p->swatch_index == 0)
            {
                temp_height = 88;  //90
                temp_offsety = -23;
                temp_width = 4;
            }
            else if(g_idle_swatch_p->swatch_index == 2)
            {
                temp_height = 88;
                temp_offsety = -68;
                temp_width = 4;
            }
            else if(g_idle_swatch_p->swatch_index == 3)
            {
                temp_height = 88;
                temp_offsety = -68;
                temp_width = 4;
            }
        }

        temp_buffer = mmi_frm_asm_alloc_anonymous_nc(temp_height * temp_width * 2);  //100  7
        gdi_layer_create_cf_using_outside_memory(GDI_COLOR_FORMAT_16,
                                             0,
                                             0,
                                             temp_width,
                                             temp_height,
                                             &handler,
                                             temp_buffer,
                                             temp_width * temp_height * 2);

        gdi_layer_push_and_set_active(handler);
        if(maui_analog_clock->black)
        {
            gdi_layer_clear(GDI_COLOR_BLACK);
        }
        else
        {
            gdi_layer_clear(GDI_COLOR_WHITE);
        }
        #ifdef MMI_DOWNLOADABLE_CLOCK
        if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_draw_resized_download_image(img_id, 0, 0,temp_width,height,MMI_TRUE);
        }
        else
        #endif
        {
            //gdi_image_draw_resized_id(0,temp_offsety,temp_width,height,img_id);  //-17
        }
	    gdi_layer_pop_and_restore_active();

		for(j = 0; j < 15; j++)
		{
            if(g_idle_swatch_p->swatch_index == 0)
            {
                mmi_idle_swatch_set_traslation(&matrix_translation, -temp_width * 0.5, -(182 + 2*temp_offsety) * 0.5);
            }
            else
            {
                mmi_idle_swatch_set_traslation(&matrix_translation, -temp_width * 0.5, temp_offsety);
            }
            
            mmi_idle_swatch_rotate_z(&matrix_rotate_z, (j+15)%60); 
            mmi_idle_swatch_matrix_multiply(&matrix_translation, &matrix_rotate_z, &matrix_result);
            matrix_result.m[2] += 119;
            matrix_result.m[5] += 119;
            mmi_swatch_idle_get_output_rect(&matrix_result, temp_width, temp_height, &rect);

            rotate_w = (rect.x2 - rect.x1 + 1);
            rotate_h = (rect.y2 - rect.y1 + 1);
            
            rotate_buf = mmi_frm_asm_alloc_anonymous_nc(rotate_w * rotate_h * 2);  //100  7
            gdi_layer_create_cf_using_outside_memory(GDI_COLOR_FORMAT_16,
                                             0,
                                             0,
                                             rotate_w, //rotate_w,
                                             rotate_h,//rotate_h,
                                             &rotate_handle,
                                             rotate_buf,
                                             rotate_w * rotate_h * 2);

            gdi_layer_push_and_set_active(rotate_handle);
            if(maui_analog_clock->black)
            {
                gdi_layer_clear(GDI_COLOR_WHITE);
            }
            else
            {
                gdi_layer_clear(GDI_COLOR_BLACK);
            }
            //gdi_layer_clear(GDI_COLOR_WHITE);
            matrix_result.m[2] -= rect.x1;
            matrix_result.m[5] -= rect.y1;
            gdi_2d_linear_transfrom(
                matrix_result.m,
                handler,
                0,
                0,
                temp_width,
                temp_height,
                0,
                0,
                rotate_w,
                rotate_h,
                GDI_LT_SRC_KEY_EDGE_FILTER_DULPLICATE,
                GDI_COLOR_TRANSPARENT,
                GDI_LT_SAMPLE_MODE_BILINEAR_WITH_EDGE_FILTER_DULPLICATE,
                0);
            gdi_layer_pop_and_restore_active();

            temp_encode_buffer = mmi_frm_asm_alloc_anonymous_nc(rotate_w * rotate_h * 2);
            encode_size = mmi_tiny_image_encode(rotate_buf,
                                             temp_encode_buffer,
                                             rotate_w,
                                             rotate_h);

            count = 0;
            for(i = 0; i < index * 15 + j; i++)
            {
                temp_count = (index_buf[2*i] << 8) + index_buf[2*i+1];
                count += temp_count;
            }
            temp_count = encode_size >> 8;
            index_buf[2 * (index * 15 + j)] = temp_count;
            kal_prompt_trace(MOD_MMI_MEDIA_APP, "temp_count = %d, encode_size = %d", temp_count, encode_size);
            index_buf[2 * (index * 15 + j) + 1] = encode_size - (temp_count << 8);
            kal_prompt_trace(MOD_MMI_MEDIA_APP, "Encode image to buffer index = %d, encode_size = %d index buffer 1= %d, 2 = %d", index, encode_size, index_buf[2*index], index_buf[2*index + 1]);
            dst_ptr = ts_resource_buf.data_buf + count + 60;
            memcpy(dst_ptr, temp_encode_buffer, encode_size);

            index_buf[MMI_SWATCH_ANALOG_BEGIN_ADDRESS + index * 60 + j * 4 ] = rect.x1;
            index_buf[MMI_SWATCH_ANALOG_BEGIN_ADDRESS + index * 60 + j * 4 + 1] = rect.x2;
            index_buf[MMI_SWATCH_ANALOG_BEGIN_ADDRESS + index * 60 + j * 4 + 2] = rect.y1;
            index_buf[MMI_SWATCH_ANALOG_BEGIN_ADDRESS + index * 60 + j * 4 + 3] = rect.y2;
            
            mmi_frm_asm_free_anonymous(rotate_buf);
            gdi_layer_free(rotate_handle);
            mmi_frm_asm_free_anonymous(temp_encode_buffer); 
        }
        gdi_layer_free(handler);
        mmi_frm_asm_free_anonymous(temp_buffer);    
        return;
    }

    if(is_download == MMI_FALSE)
    {
        gdi_image_get_dimension_id(img_id, &width, &height);
        temp_buffer = mmi_frm_asm_alloc_anonymous_nc(width * height * 2);
        gdi_layer_create_cf_using_outside_memory(GDI_COLOR_FORMAT_16,
                                             0,
                                             0,
                                             width,
                                             height,
                                             &handler,
                                             temp_buffer,
                                             width * height * 2);

        gdi_layer_push_and_set_active(handler);
	    gdi_image_draw_id(0,0,img_id);
	    gdi_layer_pop_and_restore_active();
	}
	#ifdef MMI_DOWNLOADABLE_CLOCK
	else
	{
	    if(mmi_idle_swatch_get_download_image_info(img_index, &width, &height, MMI_TRUE) == MMI_FALSE)
	    {
	        index_buf[2*index] = 0;
			index_buf[2*index + 1] = 0;
	        return;
	    }
		temp_buffer = mmi_frm_asm_alloc_anonymous_nc(width * height * 2);
	    gdi_layer_create_cf_using_outside_memory(GDI_COLOR_FORMAT_16,
		                                     0,
		                                     0,
		                                     width,
		                                     height,
		                                     &handler,
		                                     temp_buffer,
		                                     width * height * 2);

        gdi_layer_push_and_set_active(handler);
	    mmi_idle_swatch_draw_download_image(img_index,0,0,MMI_TRUE);
	    gdi_layer_pop_and_restore_active();
	}
    #endif
	
	temp_encode_buffer = mmi_frm_asm_alloc_anonymous_nc(width * height * 2);
	encode_size = mmi_tiny_image_encode(temp_buffer,
		 	                            temp_encode_buffer,
		 	                            width,
		 	                            height);

    if(index < 34 || is_download == MMI_TRUE)
    {
        count = 0;
	    for(i = 0; i < index; i++)
	    {
	        temp_count = (index_buf[2*i] << 8) + index_buf[2*i+1];
	        count += temp_count;
	    }
		temp_count = encode_size >> 8;
        index_buf[2*index] = temp_count;
	    kal_prompt_trace(MOD_MMI_MEDIA_APP, "Encode image to buffer index = %d, encode_size = %d", index, encode_size);
		index_buf[2*index + 1] = encode_size - (temp_count << 8);
	    dst_ptr = ts_resource_buf.data_buf + count + 30;
    }
	else
	{
	    #ifdef MTK_INTERNAL_TEST
	    ret = csci_alloc(encode_size,
                   swatch_btss_ind_string[index-34].app,
                   &dst_ptr);
                   
        if(ret < 0)
        {
            ASSERT(0);
        }
		#endif
	}
	
	memcpy(dst_ptr, temp_encode_buffer, encode_size);

	mmi_frm_asm_free_anonymous(temp_buffer);
	gdi_layer_free(handler);
	mmi_frm_asm_free_anonymous(temp_encode_buffer);  
}


#ifdef __MMI_TINY_ENCODE_1BIT__
U16 color_inde[2] = {0x0000, 0xFFFF};
#else
U16 color_inde[4] = {0x0000, 0x52aa, 0xad55, 0xFFFF};
#endif

U8 mmi_tiny_get_color_index(U16 color_data)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i = 0;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __MMI_TINY_ENCODE_1BIT__
	for(i = 0; i < 2; i++)
	{
		if(color_data == color_inde[i])
		{
		    break;
		}
	}
	#else
	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
	if(color_data >= color_inde[0] && color_data < color_inde[1]/2)
	{
	    return 0;
	}
	else if(color_data >= color_inde[1]/2 && color_data < color_inde[2]/2)
	{
	    return 1;
	}
	if(color_data >= color_inde[2]/2 && color_data < color_inde[3]/2)
	{
	    return 2;
	}
	if(color_data >= color_inde[3]/2 && color_data <= color_inde[3])
	{
	    return 3;
	}
	#endif
	//MMI_ASSERT(i != 4);
	return i;
}

S32 mmi_tiny_image_encode(PU8 encode_buffer, 
	                              PU8 output_buffer, 
	                              S32 width,
	                              S32 height)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i,j;
	U16 data, pre_data;
	S32 output_size;	
	PU16 src = (PU16)encode_buffer;
	PU8 dst_data;
	U8 temp_count;
	PU8 dst = output_buffer;
	S32 orign_size = width * height;
	PU16 Color_index_ptr;
	U16 Count = 0;
	S8 index_count = 0;
	MMI_BOOL saved = MMI_FALSE;
	MMI_BOOL found = MMI_FALSE;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    output_size = 0;
	
	/*Save width and height to first two bytes*/
	*dst = (U8)width;
	*(dst+1) = (U8)height;
    output_size += 2;

    /*The first 2 bytes is width and height, and then following 8 bytes are 4 color RGB*/
    dst_data = (PU8)(dst + 2);
	//output_size += 8;

	//Color_index_ptr = (PU16)(dst+2);
		
    for(i = 0; i < orign_size; i++)
   	{
   	    if(i == 0)
   	    {
   	        //data = *src;
			Count = 1;
   	    }
		else
		{
		    data = *(src + i);
			pre_data = *(src + i - 1);

			if(data == pre_data)
			{
			    Count++;
				if(Count >= ((1<<6) - 1))
				{
				    index_count = mmi_tiny_get_color_index(pre_data);
					temp_count = (Count<<2)|index_count;
					*dst_data = temp_count;
					dst_data++;
					output_size += 1;
					Count = 0;
				}
			}
			else
			{
			    index_count = mmi_tiny_get_color_index(pre_data);
				temp_count = (Count<<2)|index_count;
				*dst_data = temp_count;
				dst_data++;
				output_size += 1;
				Count = 1;
			}
		}

		if(i == orign_size - 1) //The Last pixel
		{
		    index_count = mmi_tiny_get_color_index(data);  //pre_data
			temp_count = (Count<<2)|index_count;
			*dst_data = temp_count;
			dst_data++;
			output_size += 1;
			Count = 1;
		}
    }

	return output_size;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_encode_tiny_image
 * DESCRIPTION
 *  
 * PARAMETERS
 *  group_id
 * RETURNS
 *  void
 *****************************************************************************/
 void mmi_idle_encode_tiny_image_test()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    ts_mmi_idle_swatch_analog_clock *analog_clock;
	mmi_idle_swatch_analog_clock *maui_analog_clock;
	ts_mmi_idle_swatch_digital_clock *digit_clock;
	mmi_idle_swatch_digital_clock *maui_digit_clock;

	mmi_idle_swatch_ap_image_info *maui_hint_data;
	ts_mmi_idle_swatch_ap_image_info *hint_data;
	S32 width, height;
	PU8 temp_buffer, temp_encode_buffer;
	gdi_handle handler;
	S32 encode_size;
	S32 i;
	PU8 temp_ptr;
	void *addr;
	PU16 index_buf;
	S32 watch_clock_index;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //StopTimer(IDLE_SWATCH_TINY_ENCODE_TIMER);
    if (!g_idle_swatch_p->is_active)
    {
        return;
    }

#ifndef __KEEP_LCD_ENGINE_ON__
	#if defined(__TINY_SYS__)  
      AP_BtSS_mode_unblock(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK);
      AP_BtSS_mode_unblock(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK);
    #endif
	return;
#endif
	
    #ifdef MTK_INTERNAL_TEST
	for(i = 0; i < 2; i++)
	{
	    addr = (void *)csci_addr(swatch_btss_ind_string[i].app);
	    if(addr != NULL)
		{
		     csci_free(addr);
		}
	}
	#endif

    #ifdef MMI_DOWNLOADABLE_CLOCK
    if(mmi_idle_swatch_need_launch_vxp() == MMI_TRUE)
    {
	    watch_clock_index = 1; //Default to digital tiny clock
    }
	else
	#endif
	{
	    watch_clock_index = g_idle_swatch_p->swatch_index;
	}
	
	
    memset(ts_resource_buf.data_buf, 0, sizeof(ts_mmi_idle_swatch_resource_buffer));
    if(g_swatch_config_table[watch_clock_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
	{
	     analog_clock = (ts_mmi_idle_swatch_analog_clock*)&(ts_tiny_skin_data.clock.data);
		 maui_analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[watch_clock_index].clock.data);
		 ts_tiny_skin_data.clock.type = g_swatch_config_table[watch_clock_index].clock.type;
		 //memcpy(&ts_tiny_skin_data.clock.area, &g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area,sizeof(mmi_idle_swatch_area));
		 analog_clock->bg_x = maui_analog_clock->bg_x;
		 analog_clock->bg_y = maui_analog_clock->bg_y;
		 analog_clock->center_x = maui_analog_clock->center_x;
		 analog_clock->center_y = maui_analog_clock->center_y;
		 analog_clock->black = maui_analog_clock->black;

		 /*Encode tiny bg img*/
		 #ifdef MMI_DOWNLOADABLE_CLOCK
		 if(watch_clock_index >= MMI_NATIVE_CLOCK_NUM)
		 {
		     mmi_tiny_encode_image_to_buffer(1,
		                                     0,
		                                     3,
		                                     MMI_FALSE,
		                                     MMI_TRUE);
		     mmi_tiny_encode_image_to_buffer(2,
		                                     1,
		                                     2,
		                                     MMI_FALSE,
		                                     MMI_TRUE);
		 }
		 else
		 #endif
		 {
		     mmi_tiny_encode_image_to_buffer(maui_analog_clock->tiny_hour_hand_img_id,
		                                     0,
		                                     3,
		                                     MMI_FALSE,
		                                     MMI_TRUE);
		     mmi_tiny_encode_image_to_buffer(maui_analog_clock->tiny_minute_hand_img_id,
		                                     1,
		                                     2,
		                                     MMI_FALSE,
		                                     MMI_TRUE);
		 }
	}
	else
	{
	     digit_clock = (ts_mmi_idle_swatch_digital_clock*)&(ts_tiny_skin_data.clock.data);
		 maui_digit_clock = (mmi_idle_swatch_digital_clock*)&(g_swatch_config_table[watch_clock_index].clock.data);
		 ts_tiny_skin_data.clock.type = g_swatch_config_table[watch_clock_index].clock.type;

		 //memcpy(&ts_tiny_skin_data.clock.area, &g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area,sizeof(mmi_idle_swatch_area));
		 digit_clock->bg_x = maui_digit_clock->bg_x;
		 digit_clock->bg_y = maui_digit_clock->bg_y;
		 digit_clock->hour_x = maui_digit_clock->hour_x;
		 digit_clock->hour_y = maui_digit_clock->hour_y;
         digit_clock->minute_x = maui_digit_clock->minute_x;
		 digit_clock->minute_y = maui_digit_clock->minute_y;
		 digit_clock->ampm_x = maui_digit_clock->ampm_x;
		 digit_clock->ampm_y = maui_digit_clock->ampm_y;
		 digit_clock->hour_num_gap = maui_digit_clock->hour_num_gap;
		 digit_clock->minute_num_gap = maui_digit_clock->minute_num_gap;
		 digit_clock->add_zero = maui_digit_clock->add_zero;

         #ifdef MMI_DOWNLOADABLE_CLOCK
		 if(watch_clock_index >= MMI_NATIVE_CLOCK_NUM)
		 {
		     for(i = 0; i < 10; i++)
		     {
		         mmi_tiny_encode_image_to_buffer(0,
		                                     i,
		                                     i,
		                                     MMI_TRUE,
		                                     MMI_FALSE);
		     }
             #ifdef TS_MMI_IDLE_SWATCH_SHOW_AMPM
             if(PhnsetGetTimeFormat() == 0) //12 hours
             {
			 #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
			 if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
				mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
			 {
			     // To do: add AM, PM image
			     mmi_tiny_encode_image_to_buffer(0,
		                                     10,
		                                     12,
		                                     MMI_TRUE,
		                                     MMI_FALSE);
				 mmi_tiny_encode_image_to_buffer(0,
		                                     11,
		                                     13,
		                                     MMI_TRUE,
		                                     MMI_FALSE);
			 }
			 else
			 #endif
			 {
			     mmi_tiny_encode_image_to_buffer(0,
				 	                         10,
		                                     10,
		                                     MMI_TRUE,
		                                     MMI_FALSE);
				 mmi_tiny_encode_image_to_buffer(0,
				 	                         11,
		                                     11,
		                                     MMI_TRUE,
		                                     MMI_FALSE);
			 }
             }
			 #endif
		 }
		 else
		 #endif
		 {
		     for(i = 0; i < 10; i++)
		     {
		         mmi_tiny_encode_image_to_buffer(maui_digit_clock->tiny_hour_num_0_img_id + i,
		                                     i,
		                                     0,
		                                     MMI_FALSE,
		                                     MMI_FALSE);
		     }
             
             #ifdef TS_MMI_IDLE_SWATCH_SHOW_AMPM
			 if(PhnsetGetTimeFormat() == 0) //12 hours
			 {
			 #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
			 if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
				mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
			 {
			     mmi_tiny_encode_image_to_buffer(maui_digit_clock->tiny_am_img_id+1,
		                                         10,
		                                         0,
		                                         MMI_FALSE,
		                                         MMI_FALSE);
				 mmi_tiny_encode_image_to_buffer(maui_digit_clock->tiny_pm_img_id+1,
		                                         11,
		                                         0,
		                                         MMI_FALSE,
		                                         MMI_FALSE);
			 }
			 else
			 #endif
			 {
			     mmi_tiny_encode_image_to_buffer(maui_digit_clock->tiny_am_img_id,
		                                         10,
		                                         0,
		                                         MMI_FALSE,
		                                         MMI_FALSE);
				 mmi_tiny_encode_image_to_buffer(maui_digit_clock->tiny_pm_img_id,
		                                         11,
		                                         0,
		                                         MMI_FALSE,
		                                         MMI_FALSE);
			 }
			 }
			 #endif
		 }
	}

	/////////put indication data
	#ifdef MTK_INTERNAL_TEST
	for(i = 0; i < 2; i++)
	{
	     mmi_tiny_encode_image_to_buffer(IMG_ID_IDLE_SWATCH_TINY_INDICATION_H+i, 34+i, 0, MMI_FALSE, MMI_FALSE);
	}
	#endif

	#ifdef __MMI_MAINLCD_128X32__
	#ifdef __MMI_BT_SUPPORT__
	if(srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_ON || srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_SWITCHING_ON)
	{
		mmi_tiny_encode_image_to_buffer(IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_BT_ON,
		                                10,
		                                0,
		                                MMI_FALSE,
		                                MMI_FALSE);
	}

	if(srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_OFF || srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_SWITCHING_OFF)
	{
		mmi_tiny_encode_image_to_buffer(IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_BT_OFF,
		                                10,
		                                0,
		                                MMI_FALSE,
		                                MMI_FALSE);
	}
	#endif

    mmi_tiny_encode_image_to_buffer(IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_CO,
		                            11,
		                            0,
		                            MMI_FALSE,
		                            MMI_FALSE);
	#endif

#if defined(__TINY_SYS__)  
      AP_BtSS_mode_unblock(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK);
      AP_BtSS_mode_unblock(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK);
#endif 
			
}


int  AP_watch_suspend(AP_BtSS_mode mode)
{
    return 1;
}

void mmi_idle_swatch_resume_callback()
{
     if (g_idle_swatch_p->is_active)
     {
         mmi_idle_swatch_draw_bg();
         mmi_idle_swatch_update();
     }
}

void  AP_watch_resume(void *local_param, int mod_id, void *ilm)
{
    gui_start_timer(5, mmi_idle_swatch_resume_callback);
}

#endif





static stack_timer_struct g_swatch_base_stack_timer;
static stack_timer_struct g_swatch_encode_stack_timer;
static mmi_idle_swatch_timer g_swatch_timer;

#if defined(__TINY_SYS__)
extern void stack_start_timer_ts(stack_timer_struct *stack_timer, kal_uint16 timer_indx, kal_uint32 init_time, kal_bool ignore_by_ts);
#endif  //defined(__TINY_SYS__)

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_init_base_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void *mmi_idle_swatch_init_base_timer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    stack_init_timer((stack_timer_struct *)&g_swatch_base_stack_timer, "SwatchTimer", MOD_MMI);
    return (void*)&g_swatch_base_stack_timer;
}


#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_init_base_timer_ex
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void *mmi_idle_swatch_init_base_timer_ex(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    stack_init_timer((stack_timer_struct *)&g_swatch_encode_stack_timer, "EncodeTimer", MOD_MMI);
    return (void*)&g_swatch_encode_stack_timer;
}
#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_start_base_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pBaseTimer
 *  init_time
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_start_base_timer(void *pBaseTimer, U32 init_time)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pBaseTimer)
    {
        #if defined(__TINY_SYS__)
        stack_start_timer_ts(pBaseTimer, 0, kal_milli_secs_to_ticks(init_time), KAL_TRUE);
		#else  //defined(__TINY_SYS__)
        stack_start_timer(pBaseTimer, 0, kal_milli_secs_to_ticks(init_time));
		#endif  //defined(__TINY_SYS__)
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_stop_base_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pBaseTimer
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_stop_base_timer(void *pBaseTimer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(pBaseTimer)
    {
        stack_stop_timer(pBaseTimer);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_base_timer_expire_process
 * DESCRIPTION
 *  
 * PARAMETERS
 *  basetimer
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_base_timer_expire_process(void *basetimer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if(basetimer == (void*)&g_swatch_base_stack_timer)
	{
	    if(stack_is_time_out_valid(&g_swatch_base_stack_timer))
	    {
	        if (g_swatch_timer.is_valid && g_swatch_timer.callback_func)
            {
                g_swatch_timer.is_valid = MMI_FALSE;
                g_swatch_timer.callback_func();
            }
        }
	    stack_process_time_out(&g_swatch_base_stack_timer);
	}

#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
	if(basetimer == (void*)&g_swatch_encode_stack_timer)
	{
	    if(stack_is_time_out_valid(&g_swatch_encode_stack_timer))
	    {
	        mmi_idle_encode_tiny_image_test();
			stack_stop_timer(g_idle_swatch_p->encode_timer_id);
        }
	    stack_process_time_out(&g_swatch_encode_stack_timer);
	}
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_is_base_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  basetimer
 * RETURNS
 *  MMI_BOOL
 *****************************************************************************/
MMI_BOOL mmi_idle_swatch_is_base_timer(void *basetimer)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return (MMI_BOOL)((void*)g_idle_swatch_p->timer_id == basetimer);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_timer_base_id
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  U32
 *****************************************************************************/
static U32 mmi_idle_swatch_get_timer_base_id(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_start_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  timerid
 *  delay
 *  funcPtr
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_start_timer(U16 timerid, U32 delay, FuncPtr funcPtr)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_ASSERT(funcPtr);

    if (g_idle_swatch_p->timer_id)
    {
        g_swatch_timer.timer_id = timerid;
        g_swatch_timer.callback_func = funcPtr;
        g_swatch_timer.is_valid = MMI_TRUE;

        mmi_idle_swatch_stop_base_timer(g_idle_swatch_p->timer_id);
        mmi_idle_swatch_start_base_timer(g_idle_swatch_p->timer_id, delay);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_stop_timer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  timerid
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_stop_timer(U16 timerid)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (g_idle_swatch_p->timer_id)
    {
        memset(&g_swatch_timer, 0, sizeof(mmi_idle_swatch_timer));

        mmi_idle_swatch_stop_base_timer(g_idle_swatch_p->timer_id);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_pedometer_data
 * DESCRIPTION
 *  
 * PARAMETERS
 *  app
 *  count
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_get_pedometer_data(MMI_IDLE_SWATCH_AP_ENUM app, U32* count)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_pedometer_data pedometer_data;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#ifdef __MMI_MAINLCD_128X128__
	return;
#endif
    if (g_idle_swatch_p->pedometer_cb != NULL)
    {
        g_idle_swatch_p->pedometer_cb(&pedometer_data);
        if (app == MMI_IDLE_SWATCH_AP_STEP)
        {
            *count = pedometer_data.steps;
        }
        else if (app == MMI_IDLE_SWATCH_AP_CALORIE)
        {
            *count = pedometer_data.calories;
        }

//        MMI_TRACE(MOD_MMI_COMMON_APP, TRC_IDLE_SWATCH_TEST, 0, *count);
        if (*count >= MMI_IDLE_SWATCH_AP_COUNT_MAX_NUM)
        {
            *count = (U32)MMI_IDLE_SWATCH_AP_COUNT_MAX_NUM - 1;
        }
    }
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_pedometer_resgiter_callback
 * DESCRIPTION
 *  
 * PARAMETERS
 *  data 
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_pedometer_resgiter_callback(mmi_idle_swatch_pedometer_cb cb)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_idle_swatch_p->pedometer_cb = cb;
}

#ifndef __MMI_MAINLCD_128X32__
/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_draw_ok
 * DESCRIPTION
 *  This function is used to draw the ok button.
 * PARAMETERS
 *  is_press [IN]
 *  need_blt [IN]
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_draw_ok(MMI_BOOL is_press, MMI_BOOL need_blt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 x1, y1, x2, y2;
    S32 name_w, name_h, offset_x, offset_y;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #if 1
    x1 = 0;
    y1 = 180;
    x2 = LCD_WIDTH - 1;
    y2 = LCD_HEIGHT - 1;
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    //gdi_draw_solid_rect(x1, y1, x2, y2, gdi_act_color_from_rgb(255,255,155,0));

    if (is_press)
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, gdi_act_color_from_rgb(255,127,75,0));  //(255,127,75,0)
    }
    else
    {
        gdi_draw_solid_rect(x1, y1, x2, y2, gdi_act_color_from_rgb(255,255,155,0));
    }

    gui_set_font(&MMI_large_font);
    gui_measure_string((UI_string_type)GetString(STR_GLOBAL_OK), &name_w, &name_h);        
    gui_set_text_color(gui_color(255, 255, 255));
    gui_set_text_border_color(gui_color(255, 255, 255));

    offset_x = (LCD_WIDTH - name_w) / 2;
    offset_y = 180 + (60 - name_h) / 2;

    gui_move_text_cursor(offset_x, offset_y);
    gui_print_text((UI_string_type)GetString(STR_GLOBAL_OK));
    
    gdi_layer_pop_clip();
    
    #else
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #endif

    if (need_blt)
    {
        gdi_layer_blt_previous(x1, y1, x2, y2);
    }
}
#endif


#ifdef MMI_DOWNLOADABLE_CLOCK

mmi_idle_swatch_download_img_struct ana_image_string[4]={"clock_bg.png",
	                                                     "hand.png",
                                                         "minute.png",
                                                         "second.png"};

mmi_idle_swatch_download_img_struct ana_image_tiny_string[4]={"clock_bg_tiny.png",
                                                              "hand_tiny.png",
                                                              "minute_tiny.png",
                                                              "second_tiny.png"};


mmi_idle_swatch_download_img_struct digit_img_string[16] = {"am.png",
	                                                        "am_cn.png",
                                                            "pm.png",
                                                            "pm_cn.png",
                                                            "clock_bg.png",
                                                            "num_0.png",
                                                            "num_1.png",
                                                            "num_2.png",
                                                            "num_3.png",
                                                            "num_4.png",
                                                            "num_5.png",
                                                            "num_6.png",
                                                            "num_7.png",
                                                            "num_8.png",
                                                            "num_9.png",
                                                            "colon.png"};

mmi_idle_swatch_download_img_struct digit_imgtiny_string[16] = {"h0_tiny.png",
                                                                "h1_tiny.png",
                                                                "h2_tiny.png",
                                                                "h3_tiny.png",
                                                                "h4_tiny.png",
                                                                "h5_tiny.png",
                                                                "h6_tiny.png",
                                                                "h7_tiny.png",
                                                                "h8_tiny.png",
                                                                "h9_tiny.png",
                                                                "tiny_am.png",
                                                                "tiny_pm.png",
                                                                "tiny_am_cn.png",
                                                                "tiny_pm_cn.png",
                                                                "clock_bg_tiny.png",
                                                                "colon_tiny.png"};


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_clock_package_list
 * DESCRIPTION
 *  mmi_idle_swatch_get_clock_package_list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_get_clock_package_list(MMI_BOOL Save_buf)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 fixed_n_items, i;
	mmi_app_package_name_struct * array = NULL;
	MMI_RET result;
	srv_app_info_struct info;
	U32 package_id;
	S32 icon_index = 0;
	MMI_ID icon_image;
	S16 result_icon;
	U16 filepath[260];
	U8 *res_buffer;
	U8 *cache_buf;
	S32 res_size;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	/*Get App Info*/
	fixed_n_items = srv_mre_appmgr_get_app_num(SRV_APPMGR_INSTALLED_CLOCK_APP_FLAG_TYPE);

	array = mmi_frm_asm_alloc_anonymous(fixed_n_items * sizeof(mmi_app_package_name_struct));

	result = srv_mre_appmgr_get_app_list(SRV_APPMGR_INSTALLED_CLOCK_APP_FLAG_TYPE,
									     array,
										 fixed_n_items);
	MMI_ASSERT(result != MMI_RET_ERR);

	if(fixed_n_items > MMI_SWATCH_CLOCK_APP_NUM - MMI_NATIVE_CLOCK_NUM)
	{
	    fixed_n_items = MMI_SWATCH_CLOCK_APP_NUM - MMI_NATIVE_CLOCK_NUM;
	}

	g_idle_swatch_p->download_count = fixed_n_items;

	for(i = 0; i < fixed_n_items ; i++)
	{
		srv_mre_appmgr_get_file_path(array[i], filepath);

		package_id = srv_appmgr_get_id_by_app_package_name(array[i]);

        g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.app_id = package_id;

		if(Save_buf == MMI_TRUE)
		{

		    res_buffer = (U8 *)vm_load_resource_from_file(filepath, MMI_SWATCH_PREVIEW_IMAGE, &res_size);

		    if(res_buffer)
		    {
		        g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_type = MMI_IMAGE_SRC_TYPE_MEM;
			    g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_len = res_size;
			    cache_buf = mmi_frm_asm_alloc_anonymous(res_size);
			    memcpy(cache_buf, res_buffer, res_size);
			    g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_ptr = cache_buf;
		    }
		    else
		    {
		        g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_ptr = NULL;
		    }
		    vm_free(res_buffer);
		}
	}
	mmi_frm_asm_free_anonymous(array);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_clock_package_list
 * DESCRIPTION
 *  mmi_idle_swatch_get_clock_package_list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_download_image(S32 index,
                                                             S32 x,
                                                             S32 y,
                                                             MMI_BOOL is_tiny)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_app_package_name_struct appname;
	U16 filepath[260];
	U8 *res_buffer;
	S32 res_size, image_len;
	PU8 img_ptr;
	U8 icon_type;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
	srv_mre_appmgr_get_file_path(appname, filepath);

    if(is_tiny == MMI_TRUE)
    {
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_tiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
			}
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_imgtiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
			}
	    }
    }
	else
	{
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
	    }
	}
		
    if(res_buffer == NULL)
    {
        vm_free(res_buffer);
		return;
    }
	
    img_ptr = res_buffer;
	
	image_len = res_size;
	
    icon_type = gdi_image_get_type_from_mem(img_ptr);
    if (icon_type == GDI_IMAGE_TYPE_INVALID)
    {
        if( img_ptr[0] == 0x28 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_ABM;
        }
		else if( img_ptr[0] == 0x34 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_AB2;
        }
		else
		{
		    return;
		}
    }

	if (icon_type == GDI_IMAGE_TYPE_AB2  || icon_type == GDI_IMAGE_TYPE_ABM)
	{
        img_ptr += 8;
        image_len -= 8;
	}

    gdi_image_draw_mem(x,
                       y, 
                       img_ptr,
                       icon_type,//gdi_image_get_type_from_mem(g_swatch_config_table[index].image_info.image_ptr),
                       image_len);

	vm_free(res_buffer);
	
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_clock_package_list
 * DESCRIPTION
 *  mmi_idle_swatch_get_clock_package_list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_resized_download_image(S32 index,
                                                                      S32 x,
                                                                      S32 y,
                                                                      S32 width,
                                                                      S32 height,
                                                                      MMI_BOOL is_tiny)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_app_package_name_struct appname;
	U16 filepath[260];
	U8 *res_buffer;
	S32 res_size, image_len;
	PU8 img_ptr;
	U8 icon_type;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
	srv_mre_appmgr_get_file_path(appname, filepath);

    if(is_tiny == MMI_TRUE)
    {
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_tiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
			}
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_imgtiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
			}
	    }
    }
	else
	{
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
	    }
	}
		
    if(res_buffer == NULL)
    {
        vm_free(res_buffer);
		return;
    }
	
    img_ptr = res_buffer;
	
	image_len = res_size;
	
    icon_type = gdi_image_get_type_from_mem(img_ptr);
    if (icon_type == GDI_IMAGE_TYPE_INVALID)
    {
        if( img_ptr[0] == 0x28 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_ABM;
        }
		else if( img_ptr[0] == 0x34 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_AB2;
        }
		else
		{
		    return;
		}
    }

	if (icon_type == GDI_IMAGE_TYPE_AB2  || icon_type == GDI_IMAGE_TYPE_ABM)
	{
        img_ptr += 8;
        image_len -= 8;
	}

    gdi_image_draw_resized_mem(x,
                               y, 
                               width,
                               height,
                               img_ptr,
                               icon_type,//gdi_image_get_type_from_mem(g_swatch_config_table[index].image_info.image_ptr),
                               image_len);

	vm_free(res_buffer);
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_clock_package_list
 * DESCRIPTION
 *  mmi_idle_swatch_get_clock_package_list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_idle_swatch_get_download_image_info(S32 index,
                                                             S32 *width,
                                                             S32 *height,
                                                             MMI_BOOL is_tiny)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_app_package_name_struct appname;
	U16 filepath[260];
	U8 *res_buffer;
	S32 res_size, image_len;
	PU8 img_ptr;
	U8 icon_type;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
	srv_mre_appmgr_get_file_path(appname, filepath);

    if(is_tiny == MMI_TRUE)
    {
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_tiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
			}
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_imgtiny_string[index].str, &res_size);
			if(res_buffer == NULL)  //If not tiny image for download, only show normal image for backlight off
			{
			    res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
			}
	    }
    }
	else
	{
        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
        {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, ana_image_string[index].str, &res_size);
        }
	    else
	    {
	        res_buffer = (U8 *)vm_load_resource_from_file(filepath, digit_img_string[index].str, &res_size);
	    }
	}

    if(res_buffer == NULL)
    {
        //vm_free(res_buffer);
		return MMI_FALSE;
    }
	
    img_ptr = res_buffer;
	
	image_len = res_size;
	
    icon_type = gdi_image_get_type_from_mem(img_ptr);
    if (icon_type == GDI_IMAGE_TYPE_INVALID)
    {
        if( img_ptr[0] == 0x28 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_ABM;
        }
		else if( img_ptr[0] == 0x34 && img_ptr[1] == 0x1)
        {
            icon_type = GDI_IMAGE_TYPE_AB2;
        }
		else
		{
		    return MMI_FALSE;
		}
    }

	if (icon_type == GDI_IMAGE_TYPE_AB2  || icon_type == GDI_IMAGE_TYPE_ABM)
	{
        img_ptr += 8;
        image_len -= 8;
	}

    gdi_image_get_dimension_mem(icon_type,
		                        img_ptr,
		                        image_len,
		                        width,
		                        height);

	vm_free(res_buffer);

	return MMI_TRUE;
}

#ifndef __MMI_MAINLCD_128X32__

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_clock_package_list
 * DESCRIPTION
 *  mmi_idle_swatch_get_clock_package_list
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_free_preview_buffer()
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 i;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	for(i = 0; i < g_idle_swatch_p->download_count ; i++)
	{
	    if(g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_ptr)
	    {
	        mmi_frm_asm_free_anonymous(g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_ptr);
			g_swatch_config_table[i+MMI_NATIVE_CLOCK_NUM].image_info.image_ptr = NULL;
	    }
	}
}
#endif

#define DOWNLOAD_CLOCK_CONFIG_TABLE    "Configtbl.bin"

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_need_launch_vxp
 * DESCRIPTION
 *  mmi_idle_swatch_need_launch_vxp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static MMI_BOOL mmi_idle_swatch_need_launch_vxp()
{
    U8 *res_buffer;
	S32 res_size;
	mmi_app_package_name_struct appname;
	U16 filepath[260];
	
    if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
	    srv_mre_appmgr_get_file_path(appname, filepath);
        res_buffer = (U8 *)vm_load_resource_from_file(filepath, DOWNLOAD_CLOCK_CONFIG_TABLE, &res_size);
		if(res_buffer == NULL)
        {
            vm_free(res_buffer);
		    return MMI_TRUE;
        }

		vm_free(res_buffer);
		return MMI_FALSE;
    }

	return MMI_FALSE;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_need_launch_vxp
 * DESCRIPTION
 *  mmi_idle_swatch_need_launch_vxp
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_launch_clock_vxp()
{
	mmi_app_package_name_struct appname;
	MMI_ID ret;
	
    if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
		
		ret = srv_appmgr_launch(appname);

		kal_prompt_trace(MOD_MMI_COMMON_APP, "ret = %d", ret);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_save_download_clock_param
 * DESCRIPTION
 *  mmi_idle_swatch_save_download_clock_param
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_save_download_clock_param()
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	mmi_idle_swatch_digital_clock* maui_digit_clock;
     mmi_idle_swatch_analog_clock *maui_analog_clock;
	mmi_idle_swatch_ap *ap_data;
	mmi_idle_swatch_ap_image_info *maui_hint_data;
	U8 *res_buffer;
	S32 res_size;
	mmi_app_package_name_struct appname;
	U16 filepath[260];
	S32 Count = 0;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    srv_appmgr_get_app_package_name_by_id(g_swatch_config_table[g_idle_swatch_p->swatch_index].image_info.app_id,
	                                      appname);
	    srv_mre_appmgr_get_file_path(appname, filepath);
        res_buffer = (U8 *)vm_load_resource_from_file(filepath, DOWNLOAD_CLOCK_CONFIG_TABLE, &res_size);
		if(res_buffer == NULL)
        {
            vm_free(res_buffer);
		    return;
        }
		
		g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x1 = 0;
		g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x2 = MMI_IDLE_SWATCH_WIDTH;
		g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y1 = 0;
		g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y2 = MMI_IDLE_SWATCH_HEIGHT;

        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type = res_buffer[10];

        if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type  == MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL)
        {
		maui_digit_clock = (mmi_idle_swatch_digital_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);

        maui_digit_clock->bg_x = res_buffer[Count];
		Count++;

        maui_digit_clock->bg_y = res_buffer[Count];
		Count++;

		maui_digit_clock->hour_x = res_buffer[Count];
		Count++;

		maui_digit_clock->hour_y = res_buffer[Count];
		Count++;

		maui_digit_clock->minute_x = res_buffer[Count];
		Count++;

		maui_digit_clock->minute_y = res_buffer[Count];
		Count++;

		maui_digit_clock->ampm_x = res_buffer[Count];
		Count++;

		maui_digit_clock->ampm_y = res_buffer[Count];
		Count++;

		maui_digit_clock->hour_num_gap = res_buffer[Count];
		Count++;

		maui_digit_clock->minute_num_gap = res_buffer[Count];
		Count++;

        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type = res_buffer[Count];
		Count++;

        maui_digit_clock->add_zero = MMI_TRUE;
            vm_free(res_buffer);
        }
        else
        {
            maui_analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
            maui_analog_clock->bg_x = res_buffer[Count];
		    Count++;

            maui_analog_clock->bg_y = res_buffer[Count];
		    Count++;

		    maui_analog_clock->center_x = res_buffer[Count];
		    Count++;

		    maui_analog_clock->center_y = res_buffer[Count];
		    Count++;

			#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
			maui_analog_clock->black = res_buffer[Count];
		    Count++;
			#endif

            vm_free(res_buffer);
        }

	}
}

#endif

#ifndef __MMI_MAINLCD_128X32__

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_preview_image
 * DESCRIPTION
 *  mmi_idle_swatch_draw_preview_image
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_preview_image(U8 index,
                                                          S32 left_x)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	S32 image_width, image_height;
	U16 icon_type;
	PU8 image_ptr;
	S32 image_len;
	S32 offset_temp = 0;
	/*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if(index == 1)
	{
        offset_temp = 0;
	}
	
#ifdef MMI_DOWNLOADABLE_CLOCK
    if(index >= MMI_NATIVE_CLOCK_NUM)
    {
        image_ptr = g_swatch_config_table[index].image_info.image_ptr;
	    image_len = g_swatch_config_table[index].image_info.image_len;
        icon_type = gdi_image_get_type_from_mem(image_ptr);
        if (icon_type == GDI_IMAGE_TYPE_INVALID)
        {
            icon_type = GDI_IMAGE_TYPE_AB2;
        }

	    if (icon_type == GDI_IMAGE_TYPE_AB2  || icon_type == GDI_IMAGE_TYPE_ABM)
	    {
            image_ptr += 8;
            image_len -= 8;
	    }
        gdi_image_get_dimension_mem(icon_type, 
		                            image_ptr, 
		                            image_len, 
		                            &image_width, 
		                            &image_height);
	//gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_PREVIEW_1, &image_width, &image_height);

	    switch(g_swatch_config_table[index].image_info.image_type)
	    {
		    case MMI_IMAGE_SRC_TYPE_RES_ID:
			    gdi_image_draw_id(left_x+(MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH-image_width)/2 + offset_temp,  //MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE
                                  MMI_IDLE_SWATCH_PREVIEW_CENTER_Y-image_height/2-(image_height%2 > 0 ? 1 : 0), 
                                  g_swatch_config_table[index].image_info.res_id);
			    break;
		    case MMI_IMAGE_SRC_TYPE_MEM:
			    gdi_image_draw_mem(left_x+(MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH-image_width)/2 + offset_temp,  //MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE
                                   MMI_IDLE_SWATCH_PREVIEW_CENTER_Y-image_height/2-(image_height%2 > 0 ? 1 : 0), 
                                   image_ptr,
                                   icon_type,//gdi_image_get_type_from_mem(g_swatch_config_table[index].image_info.image_ptr),
                                   image_len);
			    break;
		    default:
			    break;
	    }
    }
	else
	{
        gdi_image_get_dimension_id(g_swatch_config_table[index].image_info.res_id, &image_width, &image_height);
		gdi_image_draw_id(left_x+(MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH-image_width)/2 + offset_temp,  //MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE
                          MMI_IDLE_SWATCH_PREVIEW_CENTER_Y-image_height/2-(image_height%2 > 0 ? 1 : 0), 
                          g_swatch_config_table[index].image_info.res_id);
	}
#else
    gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_PREVIEW_1+index, &image_width, &image_height);
    gdi_image_draw_id(left_x+(MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH-image_width)/2 + offset_temp,
                      MMI_IDLE_SWATCH_PREVIEW_CENTER_Y-image_height/2-(image_height%2 > 0 ? 1 : 0), 
                      IMG_ID_IDLE_SWATCH_PREVIEW_1+index);
#endif

}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_draw_preview
 * DESCRIPTION
 *  This function is used to draw preview
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_draw_preview(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 image_width, image_height;
    S32 x1, y1, x2, y2;
	U8 i, swatch_num;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #ifdef __MMI_TOUCH_SCREEN__
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_setting_draw_preview,moving_x=%d,ssp_state:%d\n", g_idle_swatch_p->moving_x, g_idle_swatch_p->ssp_state);
    #endif  //__MMI_TOUCH_SCREEN__
    x1 = 0;
    y1 = 0;  //MMI_STATUS_ICON_BAR_HEIGHT
    x2 = MMI_IDLE_SWATCH_WIDTH;
    y2 = MMI_IDLE_SWATCH_HEIGHT;
    
    if (mmi_frm_scrn_get_active_id() != SCR_ID_SWATCH_SETTING)
    {
        return;
    }
    
    gdi_layer_push_and_set_clip(x1, y1, x2, y2);
    gdi_draw_solid_rect(x1, y1, x2, y2, GDI_COLOR_TRANSPARENT);

    #ifdef __MMI_TOUCH_SCREEN__
    if (g_idle_swatch_p->ssp_state != MMI_IDLE_SWATCH_SETTING_SSP_STATE_NONE)
    {
        mmi_idle_swatch_setting_draw_ok(MMI_FALSE, MMI_FALSE);
        #ifdef MMI_DOWNLOADABLE_CLOCK
		swatch_num = MMI_NATIVE_CLOCK_NUM + g_idle_swatch_p->download_count;
		#else
		swatch_num = MMI_SWATCH_CLOCK_APP_NUM; //sizeof(g_swatch_config_table) / sizeof(mmi_idle_swatch_config_table);
		#endif

        //preview
        for (i = 0; i < swatch_num; i++)
        {
            S32 left_x = (i-g_idle_swatch_p->setting_swatch_index)*MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
            S32 right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
            if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
            {
                //draw bg
                //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);
                
                mmi_idle_swatch_draw_preview_image(i, left_x);
				
                /*gdi_image_draw_id(left_x+(MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE-image_width)/2,
                    MMI_IDLE_SWATCH_PREVIEW_CENTER_Y-image_height/2-(image_height%2 > 0 ? 1 : 0), 
                    IMG_ID_IDLE_SWATCH_PREVIEW_1+i);*/
            }
            //loop
            else if (MMI_IDLE_SWATCH_ABS(i-g_idle_swatch_p->setting_swatch_index) == swatch_num-1)
            {
                if (g_idle_swatch_p->setting_swatch_index == 0)
                {
                    //show the last
                    left_x = -MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                    right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                    if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                        (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                    {
                        //draw bg
                        //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);
                        
                        mmi_idle_swatch_draw_preview_image(i, left_x);
                    }
                }
                else
                {
                    //show the first
                    left_x = MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                    right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                    if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                        (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                    {
                        //draw bg
                        //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);
                        
                        gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_PREVIEW_1, &image_width, &image_height);

						mmi_idle_swatch_draw_preview_image(i, left_x);
                    }
                }
            }
        }
        
        //there are three previews
        if (MMI_IDLE_SWATCH_ABS(g_idle_swatch_p->moving_x) >= MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE)
        {
            S32 left_x, right_x;
            
            if (g_idle_swatch_p->setting_swatch_index == 0)
            {
                left_x = -2 * MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                    (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                {
                    //draw bg
                    //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);
                    
                    mmi_idle_swatch_draw_preview_image(swatch_num-2, left_x);				
                }
            }
            else if (g_idle_swatch_p->setting_swatch_index == swatch_num-1)
            {
                left_x = 2 * MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                    (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                {
                    //draw bg
                    //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);

					mmi_idle_swatch_draw_preview_image(1, left_x);
                }
            }
            else
            {
                if (g_idle_swatch_p->setting_swatch_index - 1 == 0)
                {
                    left_x = -2 * MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                    right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                    if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                        (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                    {
                        //draw bg
                        //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);

						mmi_idle_swatch_draw_preview_image(swatch_num-1, left_x);
                    }
                }
                if (g_idle_swatch_p->setting_swatch_index + 1 == swatch_num-1)
                {
                    left_x = 2 * MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE+g_idle_swatch_p->moving_x+MMI_IDLE_SWATCH_SETTING_START_X_IN_MOVE;
                    right_x = left_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
                    if ((left_x > 0 && left_x < MMI_IDLE_SWATCH_WIDTH) ||
                        (right_x > 0 && right_x < MMI_IDLE_SWATCH_WIDTH))
                    {
                        //draw bg
                        //gdi_image_draw_resized_id(left_x, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);

						mmi_idle_swatch_draw_preview_image(0, left_x);
                    }
                }
            }
        }
        
        gdi_layer_pop_clip();
        gdi_layer_blt_previous(x1, y1, x2, y2);
    }
    else
    #endif  //__MMI_TOUCH_SCREEN__
    {
        //draw bg
        //gdi_image_draw_resized_id(MMI_IDLE_SWATCH_PREVIEW_BG_X, MMI_IDLE_SWATCH_PREVIEW_BG_Y, MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH, MMI_IDLE_SWATCH_PREVIEW_BG_HEIGHT, IMG_ID_IDLE_SWATCH_PREVIEW_BG);
        
        //left arrow
        gdi_image_draw_id(MMI_IDLE_SWATCH_PREVIEW_ARROW_X_OFFSET, MMI_IDLE_SWATCH_PREVIEW_ARROW_Y_OFFSET, IMG_ID_IDLE_SWATCH_PREVIEW_LEFT);
        //right arrow
        gdi_image_draw_id(MMI_IDLE_SWATCH_WIDTH-MMI_IDLE_SWATCH_PREVIEW_ARROW_X_OFFSET-MMI_IDLE_SWATCH_PREVIEW_ARROW_WIDTH, 
            MMI_IDLE_SWATCH_PREVIEW_ARROW_Y_OFFSET, IMG_ID_IDLE_SWATCH_PREVIEW_RIGHT);
        //ok button
        mmi_idle_swatch_setting_draw_ok(MMI_FALSE, MMI_FALSE);

        //preview
        mmi_idle_swatch_draw_preview_image(g_idle_swatch_p->setting_swatch_index, (MMI_IDLE_SWATCH_WIDTH - MMI_IDLE_SWATCH_PREVIEW_BG_WIDTH)/2);
		
        gdi_layer_pop_clip();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_show_preview
 * DESCRIPTION
 *  This function is used to draw the category controlled area of category9100 screen.
 * PARAMETERS
 *  coordinate      [IN/OUT]        Coordinates of category controlled area.
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_show_preview(dm_coordinates *coordinate)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_setting_draw_preview();
}


#if defined(__MMI_TOUCH_SCREEN__)

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_ssp_free_run
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void 
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_ssp_free_run(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_setting_ssp_free_run,moving_x:%d\n", g_idle_swatch_p->moving_x);
    gui_cancel_timer(mmi_idle_swatch_setting_ssp_free_run);
    
    if (mmi_frm_scrn_get_active_id() != SCR_ID_SWATCH_SETTING)
    {
        return;
    }
    
    if (MMI_IDLE_SWATCH_ABS(g_idle_swatch_p->moving_x) > 0)
    {
        g_idle_swatch_p->ssp_state = MMI_IDLE_SWATCH_SETTING_SSP_STATE_FREE_RUN;
        if (g_idle_swatch_p->moving_x > 0)
        {
            g_idle_swatch_p->moving_x -= MMI_IDLE_SWATCH_SETTING_FREE_RUN_SPEED;
            g_idle_swatch_p->moving_x = g_idle_swatch_p->moving_x < 0 ? 0 : g_idle_swatch_p->moving_x;
        }
        else
        {
            g_idle_swatch_p->moving_x += MMI_IDLE_SWATCH_SETTING_FREE_RUN_SPEED;
            g_idle_swatch_p->moving_x = g_idle_swatch_p->moving_x > 0 ? 0 : g_idle_swatch_p->moving_x;
        }
        mmi_idle_swatch_setting_draw_preview();
        gui_start_timer(MMI_IDLE_SWATCH_SETTING_FREE_RUN_DELAY, mmi_idle_swatch_setting_ssp_free_run);
    }
    else
    {
        g_idle_swatch_p->ssp_state = MMI_IDLE_SWATCH_SETTING_SSP_STATE_NONE;
        dm_redraw_category_screen();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_pen_down_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_idle_swatch_p->setting_pre_point.x = pos.x;
    g_idle_swatch_p->setting_pre_point.y = pos.y;
    if (g_idle_swatch_p->ssp_state == MMI_IDLE_SWATCH_SETTING_SSP_STATE_NONE &&
        pos.x > (MMI_IDLE_SWATCH_PREVIEW_OK_X_OFFSET-MMI_IDLE_SWATCH_PREVIEW_OK_THRESHOLD) &&
        pos.x < (MMI_IDLE_SWATCH_PREVIEW_OK_X_OFFSET+MMI_IDLE_SWATCH_PREVIEW_OK_WIDTH+MMI_IDLE_SWATCH_PREVIEW_OK_THRESHOLD) &&
        pos.y > (MMI_IDLE_SWATCH_PREVIEW_OK_Y_OFFSET-MMI_IDLE_SWATCH_PREVIEW_OK_THRESHOLD) &&
        pos.y < (MMI_IDLE_SWATCH_PREVIEW_OK_Y_OFFSET+MMI_IDLE_SWATCH_PREVIEW_OK_HEIGHT+MMI_IDLE_SWATCH_PREVIEW_OK_THRESHOLD))
    {
        g_idle_swatch_p->is_selected = MMI_TRUE;
        mmi_idle_swatch_setting_draw_ok(MMI_TRUE, MMI_TRUE);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_pen_move_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 x_diff = pos.x - g_idle_swatch_p->setting_pre_point.x;
    S16 y_diff = pos.y - g_idle_swatch_p->setting_pre_point.y;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_setting_pen_move_hdlr,pos.x:%d,pre_point.x:%d,moving_x:%d\n", pos.x, g_idle_swatch_p->setting_pre_point.x, g_idle_swatch_p->moving_x);
    if (MMI_IDLE_SWATCH_ABS(x_diff) > MMI_IDLE_SWATCH_SETTING_MOVE_THRESHOLD || MMI_IDLE_SWATCH_ABS(y_diff) > MMI_IDLE_SWATCH_SETTING_MOVE_THRESHOLD
        || !g_idle_swatch_p->is_selected)
    {
        g_idle_swatch_p->is_selected = MMI_FALSE;
        g_idle_swatch_p->ssp_state = MMI_IDLE_SWATCH_SETTING_SSP_STATE_MOVE;
        g_idle_swatch_p->moving_x += x_diff;
        g_idle_swatch_p->setting_pre_point.x = pos.x;
        g_idle_swatch_p->setting_pre_point.y = pos.y;
        mmi_idle_swatch_setting_draw_preview();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_pen_up_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 swatch_num;
	S8 swatch_offset;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_setting_pen_up_hdlr,moving_x:%d\n", g_idle_swatch_p->moving_x);
    if (g_idle_swatch_p->is_selected)
    {
        S16 error;
		g_idle_swatch_p->pre_swatch_index = g_idle_swatch_p->swatch_index;
        g_idle_swatch_p->swatch_index = g_idle_swatch_p->setting_swatch_index;
        //write swatch index record
        WriteValue(NVRAM_IDLE_SWATCH_INDEX, &(g_idle_swatch_p->swatch_index), DS_BYTE, &error);
        mmi_frm_group_close(GRP_ID_SWATCH_SETTING);

		#ifdef MMI_DOWNLOADABLE_CLOCK
		mmi_idle_swatch_save_download_clock_param();
		#endif
    }
    else
    {
        #ifdef MMI_DOWNLOADABLE_CLOCK
		swatch_num = MMI_NATIVE_CLOCK_NUM + g_idle_swatch_p->download_count;
		#else
		swatch_num = MMI_SWATCH_CLOCK_APP_NUM; //sizeof(g_swatch_config_table) / sizeof(mmi_idle_swatch_config_table);
		#endif
        swatch_offset = MMI_IDLE_SWATCH_ABS(g_idle_swatch_p->moving_x / MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE);

        if (swatch_offset > 0)
        {
            if (g_idle_swatch_p->moving_x > 0)
            {
                if (g_idle_swatch_p->setting_swatch_index >= swatch_offset)
                {
                    g_idle_swatch_p->setting_swatch_index -= swatch_offset;
                }
                else
                {
                    g_idle_swatch_p->setting_swatch_index = swatch_num - (swatch_offset - g_idle_swatch_p->setting_swatch_index);
                }
            }
            else
            {
                if (g_idle_swatch_p->setting_swatch_index + swatch_offset < swatch_num)
                {
                    g_idle_swatch_p->setting_swatch_index += swatch_offset;
                }
                else
                {
                    g_idle_swatch_p->setting_swatch_index = swatch_offset - (swatch_num - g_idle_swatch_p->setting_swatch_index);
                }
            }
            g_idle_swatch_p->moving_x = g_idle_swatch_p->moving_x % MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
        }
        if (MMI_IDLE_SWATCH_ABS(g_idle_swatch_p->moving_x) > MMI_IDLE_SWATCH_SETTING_MOVE_SWITCH_THRESHOLD)
        {
            if (g_idle_swatch_p->moving_x < 0)
            {
                if (g_idle_swatch_p->setting_swatch_index < (swatch_num-1))
                {
                    g_idle_swatch_p->setting_swatch_index++;
                }
                else
                {
                    g_idle_swatch_p->setting_swatch_index = 0;
                }
            }
            else
            {
                if (g_idle_swatch_p->setting_swatch_index > 0)
                {
                    g_idle_swatch_p->setting_swatch_index--;
                }
                else
                {
                    g_idle_swatch_p->setting_swatch_index = swatch_num - 1;
                }
            }
            
            if (g_idle_swatch_p->moving_x > 0)
            {
                g_idle_swatch_p->moving_x = g_idle_swatch_p->moving_x - MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
            }
            else
            {
                g_idle_swatch_p->moving_x = g_idle_swatch_p->moving_x + MMI_IDLE_SWATCH_SETTING_WIDTH_IN_MOVE;
            }
        }
        
        mmi_idle_swatch_setting_ssp_free_run();;
    }
    
    g_idle_swatch_p->is_selected = MMI_FALSE;
}

#endif  //defined(__MMI_TOUCH_SCREEN__)


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_entry
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_setting_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 fixed_n_items = 0;
	S16 error;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //g_idle_swatch_p->setting_swatch_index = g_idle_swatch_p->swatch_index;
    #ifdef __MMI_TOUCH_SCREEN__
    g_idle_swatch_p->moving_x = 0;
    g_idle_swatch_p->ssp_state = MMI_IDLE_SWATCH_SETTING_SSP_STATE_NONE;
    #endif  //__MMI_TOUCH_SCREEN__    
    
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_ENTER_MAINMENU);

	#ifdef MMI_DOWNLOADABLE_CLOCK
	if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM || g_idle_swatch_p->setting_swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    fixed_n_items = srv_mre_appmgr_get_app_num(SRV_APPMGR_INSTALLED_CLOCK_APP_FLAG_TYPE);

		if(fixed_n_items > 0)
		{
		    mmi_idle_swatch_get_clock_package_list(MMI_FALSE);
	        mmi_idle_swatch_save_download_clock_param();
		}
		else
		{
		    g_idle_swatch_p->swatch_index = 1;
			g_idle_swatch_p->setting_swatch_index = 1;
		    WriteValue(NVRAM_IDLE_SWATCH_INDEX, &(g_idle_swatch_p->swatch_index), DS_BYTE, &error);
		}
	}
	#endif

	#ifdef MMI_DOWNLOADABLE_CLOCK
	mmi_idle_swatch_get_clock_package_list(MMI_TRUE);
	#endif
    
    entry_full_screen();
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    
    dm_register_category_controlled_callback(mmi_idle_swatch_setting_show_preview);
    wgui_cat_setup_category_default_history(MMI_CAT9100_ID, NULL, NULL);
    dm_redraw_category_screen();
    
    clear_key_handlers();
#if defined(__MMI_TOUCH_SCREEN__)
    wgui_clear_pen_handlers();
    wgui_register_pen_down_handler(mmi_idle_swatch_setting_pen_down_hdlr);
    wgui_register_pen_move_handler(mmi_idle_swatch_setting_pen_move_hdlr);
    wgui_register_pen_up_handler(mmi_idle_swatch_setting_pen_up_hdlr);
#endif /* __MMI_TOUCH_SCREEN__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_setting_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param      :[IN]   event      
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
static mmi_ret mmi_idle_swatch_setting_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_TOUCHSCREEN_MOVE_RIGHT:
        {
            return MMI_RET_DONT_CARE;
            break;
        }
        case EVT_ID_GROUP_DEINIT:
        {
            break;
        }
        case EVT_ID_SCRN_INIT:
        {
            g_idle_swatch_p->setting_swatch_index = g_idle_swatch_p->swatch_index;
            break;
        }
        case EVT_ID_SCRN_ACTIVE:
        {
            mmi_idle_swatch_setting_entry();
            break;
        }
        case EVT_ID_SCRN_INACTIVE:
        case EVT_ID_SCRN_DEINIT:
        {
            #ifdef __MMI_TOUCH_SCREEN__
            gui_cancel_timer(mmi_idle_swatch_setting_ssp_free_run);
            #endif  //__MMI_TOUCH_SCREEN__
			//No need to clear pen handler in deinit stage because app maybe background closed
			//clear_key_handlers();
            //#if defined(__MMI_TOUCH_SCREEN__)
            //wgui_clear_pen_handlers();
            //#endif  //defined(__MMI_TOUCH_SCREEN__)

			#ifdef MMI_DOWNLOADABLE_CLOCK
			mmi_idle_swatch_free_preview_buffer();
			#endif
            break;
        }
    }
    
    return MMI_RET_OK;
}


void mmi_idle_swatch_setting(MMI_ID parent_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    group_id = mmi_frm_group_create_ex(
        parent_id, 
        GRP_ID_SWATCH_SETTING, 
        mmi_idle_swatch_setting_proc, 
        NULL, 
        MMI_FRM_NODE_SMART_CLOSE_FLAG);
    
    MMI_ASSERT(group_id != GRP_ID_INVALID);
    //StopTimer(IDLE_SWATCH_UPDATE_TIMER);
    mmi_idle_swatch_stop_timer(IDLE_SWATCH_UPDATE_TIMER);

    mmi_frm_scrn_create(
         GRP_ID_SWATCH_SETTING, 
         SCR_ID_SWATCH_SETTING, 
         mmi_idle_swatch_setting_proc,   
        NULL);
}

#endif

#if defined(__MMI_TOUCH_SCREEN__)

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_pen_down_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_pen_down_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    g_idle_swatch_p->moving_x = pos.x;
    g_idle_swatch_p->moving_y = pos.y;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_pen_up_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_pen_up_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
    #else
    if(pos.x - g_idle_swatch_p->moving_x < -MMI_IDLE_SWATCH_PEN_MOVE_ENTER_MAINMENU_THREADSHOLD &&
       MMI_IDLE_SWATCH_ABS(pos.y - g_idle_swatch_p->moving_y) <= 30)
    {
        EntryMainMenuFromIdleScreen();
    }
    #endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_pen_move_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_pen_move_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_long_tap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_long_tap_hdlr(mmi_pen_point_struct pos)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_setting(g_idle_swatch_p->group_id);
}

#endif  //defined(__MMI_TOUCH_SCREEN__)


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_register_event_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_register_event_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    //SetKeyHandler(EntryMainMenuFromIdleScreen, KEY_POWER, KEY_EVENT_UP);     
    //SetKeyHandler(EntryMainMenuFromIdleScreen, KEY_END, KEY_EVENT_UP); 
    
#if defined(__MMI_TOUCH_SCREEN__)
    wgui_register_pen_down_handler(mmi_idle_swatch_pen_down_hdlr);
    wgui_register_pen_move_handler(mmi_idle_swatch_pen_move_hdlr);
   // wgui_register_pen_long_tap_handler(mmi_idle_swatch_long_tap_hdlr);
    wgui_register_pen_up_handler(mmi_idle_swatch_pen_up_hdlr);
#endif /* __MMI_TOUCH_SCREEN__ */
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_create_adm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_create_adm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Create MemoryPool */
    if (g_idle_swatch_p->app_mem_pool != NULL && g_idle_swatch_p->adm_pool_id == NULL)
    {
        g_idle_swatch_p->adm_pool_id = kal_adm_create((void*)g_idle_swatch_p->app_mem_pool,
                                                    MMI_IDLE_SWATCH_MEM_SIZE,
                                                    NULL,
                                                    KAL_FALSE);
        ASSERT(g_idle_swatch_p->adm_pool_id != NULL);
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_delete_adm
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_delete_adm(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    kal_status ret;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Delete ADM */
    if (g_idle_swatch_p->adm_pool_id != NULL)
    {
        ret = kal_adm_delete(g_idle_swatch_p->adm_pool_id);

        ASSERT(ret == KAL_SUCCESS);
        g_idle_swatch_p->adm_pool_id = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_alloc_adm_layer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_alloc_adm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    GDI_RESULT result;
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif 
    
    /* Update layer */
    g_idle_swatch_p->update_layer_buf_ptr =
        (PU8) MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_idle_swatch_p->adm_pool_id, MMI_IDLE_SWATCH_UPDATE_LAYER_BUFFER_SIZE);
    MMI_ASSERT(g_idle_swatch_p->update_layer_buf_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        MMI_IDLE_SWATCH_WIDTH,
        MMI_IDLE_SWATCH_HEIGHT,
        &g_idle_swatch_p->update_layer_handle,
        g_idle_swatch_p->update_layer_buf_ptr,
        MMI_IDLE_SWATCH_UPDATE_LAYER_BUFFER_SIZE);
    MMI_ASSERT(g_idle_swatch_p->update_layer_handle != NULL);
	gdi_layer_push_and_set_active(g_idle_swatch_p->update_layer_handle);
	gdi_layer_clear(GDI_COLOR_TRANSPARENT);
	gdi_layer_pop_and_restore_active();
    
    /* Status bar layer */
    g_idle_swatch_p->status_icon_bar_layer_buf_ptr =
        (PU8) MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_idle_swatch_p->adm_pool_id, MMI_IDLE_SWATCH_STATUS_BAR_BUFFER_SIZE);
    MMI_ASSERT(g_idle_swatch_p->status_icon_bar_layer_buf_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        MMI_IDLE_SWATCH_WIDTH,
        MMI_STATUS_ICON_BAR_HEIGHT,
        &g_idle_swatch_p->status_icon_bar_layer_handle,
        g_idle_swatch_p->status_icon_bar_layer_buf_ptr,
        MMI_IDLE_SWATCH_STATUS_BAR_BUFFER_SIZE);    
    MMI_ASSERT(g_idle_swatch_p->status_icon_bar_layer_handle != NULL); 
    
    gdi_layer_push_and_set_active(g_idle_swatch_p->status_icon_bar_layer_handle);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();

    wgui_status_icon_bar_set_target_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, g_idle_swatch_p->status_icon_bar_layer_handle);

    /* Set status bar's blending layer */
    wgui_status_icon_bar_set_alpha_blend_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, g_idle_swatch_p->update_layer_handle);

    /* Register draw-background callback */
    wgui_status_icon_bar_register_hide_callback(
        WGUI_STATUS_ICON_BAR_H_BAR,
        hide_status_icons_bar0_by_transparent);

    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);

    /* Temp layer */
    g_idle_swatch_p->temp_layer_buf_ptr =
        (PU8) MMI_FRM_ADM_ALLOC_FRAMEBUFFER(g_idle_swatch_p->adm_pool_id, MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE);
    MMI_ASSERT(g_idle_swatch_p->temp_layer_buf_ptr != NULL);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_free_adm_layer
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_free_adm_layer(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

    /* Free update layer */ 
    if (g_idle_swatch_p->update_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        gdi_layer_free(g_idle_swatch_p->update_layer_handle);
        g_idle_swatch_p->update_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

#ifndef __MMI_MAINLCD_128X32__ 
    if (g_idle_swatch_p->update_layer_buf_ptr != NULL)
    {
        kal_adm_free(g_idle_swatch_p->adm_pool_id, (void*)g_idle_swatch_p->update_layer_buf_ptr);
        g_idle_swatch_p->update_layer_buf_ptr = NULL;
    }
#endif

    /* Free status bar layer */  
    wgui_status_icon_bar_reset_alpha_blend_layer(WGUI_STATUS_ICON_BAR_H_BAR);

    if (g_idle_swatch_p->status_icon_bar_layer_handle != GDI_LAYER_EMPTY_HANDLE)
    {
        /* Reset status bar layer config */
        wgui_status_icon_bar_set_target_layer(
            WGUI_STATUS_ICON_BAR_H_BAR, GDI_ERROR_HANDLE);

        gdi_layer_free(g_idle_swatch_p->status_icon_bar_layer_handle);
        g_idle_swatch_p->status_icon_bar_layer_handle = GDI_LAYER_EMPTY_HANDLE;
    }

    if (g_idle_swatch_p->status_icon_bar_layer_buf_ptr != NULL)
    {
        #ifndef __MMI_MAINLCD_128X32__ 
        kal_adm_free(g_idle_swatch_p->adm_pool_id, (void*)g_idle_swatch_p->status_icon_bar_layer_buf_ptr);
		#else
		mmi_frm_asm_free_anonymous(g_idle_swatch_p->status_icon_bar_layer_buf_ptr);
		#endif
        g_idle_swatch_p->status_icon_bar_layer_buf_ptr = NULL;
    }

#ifndef __MMI_MAINLCD_128X32__ 
    /* Free temp layer */ 
    if (g_idle_swatch_p->temp_layer_buf_ptr != NULL)
    {
        kal_adm_free(g_idle_swatch_p->adm_pool_id, (void*)g_idle_swatch_p->temp_layer_buf_ptr);
        g_idle_swatch_p->temp_layer_buf_ptr = NULL;
    }
#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_alloc_pool
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_alloc_pool()
{    
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]total memory need:%d\n", MMI_IDLE_SWATCH_MEM_SIZE);
    
    /* allocate memory from App-Based ASM */
    if (g_idle_swatch_p->app_mem_pool == NULL)
    {
        g_idle_swatch_p->app_mem_pool = mmi_frm_asm_alloc_r(
            g_idle_swatch_p->group_id, MMI_IDLE_SWATCH_MEM_SIZE);
        
        ASSERT(g_idle_swatch_p->app_mem_pool != NULL);
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_free_pool
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_free_pool()
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* allocate memory from App-Based ASM */
    if (g_idle_swatch_p->app_mem_pool != NULL)
    {
        mmi_frm_asm_free_r(g_idle_swatch_p->group_id, g_idle_swatch_p->app_mem_pool);
        g_idle_swatch_p->app_mem_pool = NULL;
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_enable_clock_draw_secound
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_enable_clock_draw_secound(void)
{
    g_idle_swatch_p->draw_second = MMI_TRUE;
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_init
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_init(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S16 error;
	S32 fixed_n_items = 0;
    U8 swatch_num = sizeof(g_swatch_config_table) / sizeof(mmi_idle_swatch_config_table);

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_layer_get_base_handle(&g_idle_swatch_p->base_layer_handle);
    
    /* Allocate pool & create ADM */
	#ifndef __MMI_MAINLCD_128X32__
    mmi_idle_swatch_alloc_pool();
    mmi_idle_swatch_create_adm();
    mmi_idle_swatch_alloc_adm_layer();
	#else
	gdi_layer_create(0,0,LCD_WIDTH-20,LCD_HEIGHT,&g_idle_swatch_p->update_layer_handle);
	g_idle_swatch_p->status_icon_bar_layer_buf_ptr = mmi_frm_asm_alloc_anonymous_nc(LCD_WIDTH*14*2);
	gdi_layer_create_cf_using_outside_memory(GDI_COLOR_FORMAT_16,
		                                  0,
		                                  0,
		                                  LCD_WIDTH,
		                                  14,
		                                  &g_idle_swatch_p->status_icon_bar_layer_handle,
		                                  g_idle_swatch_p->status_icon_bar_layer_buf_ptr,
		                                  LCD_WIDTH*14*2);

	  gdi_layer_push_and_set_active(g_idle_swatch_p->status_icon_bar_layer_handle);
    gdi_layer_clear(GDI_COLOR_BLACK);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
	//gdi_layer_set_position(0,2);
    gdi_layer_pop_and_restore_active();

    wgui_status_icon_bar_set_target_layer(
        WGUI_STATUS_ICON_BAR_H_BAR, g_idle_swatch_p->status_icon_bar_layer_handle);

	
	/* Set status bar's blending layer */
    wgui_status_icon_bar_set_alpha_blend_layer(
			WGUI_STATUS_ICON_BAR_H_BAR, g_idle_swatch_p->update_layer_handle);
	
	/* Register draw-background callback */
	wgui_status_icon_bar_register_hide_callback(
			WGUI_STATUS_ICON_BAR_H_BAR,
			hide_status_icons_bar0_by_transparent);

    wgui_status_icon_bar_set_display(WGUI_STATUS_ICON_BAR_H_BAR);	
	#endif

    mmi_idle_swatch_register_event_handler();

    //read swatch index record
    ReadValue(NVRAM_IDLE_SWATCH_INDEX, &(g_idle_swatch_p->swatch_index), DS_BYTE, &error);
    if (g_idle_swatch_p->swatch_index > swatch_num)
    {
        g_idle_swatch_p->swatch_index = 0;
    }

    #ifdef MMI_DOWNLOADABLE_CLOCK
	if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    fixed_n_items = srv_mre_appmgr_get_app_num(SRV_APPMGR_INSTALLED_CLOCK_APP_FLAG_TYPE);

		if(fixed_n_items > 0)
		{
		    mmi_idle_swatch_get_clock_package_list(MMI_FALSE);
	        mmi_idle_swatch_save_download_clock_param();
		}
		else
		{
		    g_idle_swatch_p->swatch_index = 1;
			g_idle_swatch_p->setting_swatch_index = 1;
			WriteValue(NVRAM_IDLE_SWATCH_INDEX, &(g_idle_swatch_p->swatch_index), DS_BYTE, &error);
		}
	}
	#endif
	
    #ifdef __MMI_MAINLCD_128X128__
	g_idle_swatch_p->swatch_index = 0;
	#endif

	#ifdef __MMI_MAINLCD_128X32__
	g_idle_swatch_p->swatch_index = 0;
	#endif
	
    g_idle_swatch_p->is_active = MMI_TRUE;
    g_idle_swatch_p->update_type = MMI_IDLE_SWATCH_UPDATE_ALL;
    if (g_idle_swatch_p->timer_id == NULL)
    {
        g_idle_swatch_p->timer_id = mmi_idle_swatch_init_base_timer();
    }

    #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
	if(g_idle_swatch_p->encode_timer_id == NULL)
    {
        g_idle_swatch_p->encode_timer_id = mmi_idle_swatch_init_base_timer_ex();
    }
	#endif

	#if defined(__TINY_SYS__) 
    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
    { 
		g_idle_swatch_p->draw_second = MMI_TRUE;
    }
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_blt_previous
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_blt_previous(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	#ifndef __MMI_MAINLCD_128X32__
    if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        gdi_layer_blt(g_idle_swatch_p->base_layer_handle,
            g_idle_swatch_p->update_layer_handle,
            g_idle_swatch_p->nail_layer_handle,   //g_idle_swatch_p->nail_layer_handle
            g_idle_swatch_p->status_icon_bar_layer_handle,
            0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT);
    }
    else
    {
        gdi_layer_blt(g_idle_swatch_p->base_layer_handle,
            g_idle_swatch_p->update_layer_handle,
            g_idle_swatch_p->status_icon_bar_layer_handle,   //g_idle_swatch_p->nail_layer_handle
            NULL,
            0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT);
    }
    #else
	gdi_layer_blt(g_idle_swatch_p->base_layer_handle,
        g_idle_swatch_p->status_icon_bar_layer_handle,
        g_idle_swatch_p->update_layer_handle,
        NULL,
        0, 0, MMI_IDLE_SWATCH_WIDTH, MMI_IDLE_SWATCH_HEIGHT);
	#endif

}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_print_text
 * DESCRIPTION
 *  
 * PARAMETERS
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_print_text(S32 x, S32 y, U8 font_size, color font_color, UI_string_type text, MMI_BOOL count_is_left_of_hint)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    stFontAttribute font = {0};
    S32 str_width, str_height;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/        
    font.type = 1;
    font.bold = 1;
    font.italic = 0;
    font.underline = 0;
    font.type = 1;
    font.oblique = 0;
    font.size = 
    font.size = (font_size | 0x80);
    gui_set_font(&font);    

    if (count_is_left_of_hint)
    {
        gui_measure_string(text, &str_width, &str_height);
        gui_move_text_cursor(x - str_width, y);
    }
    else
    {
        gui_move_text_cursor(x, y);
    }
    
    gui_set_text_color(font_color);
    gui_print_text(text);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_nail
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_nail(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 width, height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //gdi_layer_create(0, 0, LCD_WIDTH, LCD_HEIGHT, &g_idle_swatch_p->nail_layer_handle);

    if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type != MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        return;
    }
    
    gdi_layer_push_and_set_active(g_idle_swatch_p->nail_layer_handle);
    gdi_layer_clear_background(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);

    if(g_idle_swatch_p->is_tiny == MMI_FALSE)
    {
        gdi_layer_pop_and_restore_active();
        return;
    }

    if (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        mmi_idle_swatch_analog_clock *analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
        if(analog_clock->nail_img_id)
        {
            gdi_image_get_dimension_id(analog_clock->nail_img_id,&width,&height);
            gdi_push_and_set_alpha_blending_source_layer(g_idle_swatch_p->base_layer_handle);
            gdi_layer_set_position((LCD_WIDTH - width) / 2, (LCD_HEIGHT - height) / 2);
            gdi_image_draw_id(0, 0, analog_clock->nail_img_id);
            gdi_pop_and_restore_alpha_blending_source_layer();
        }
    }

    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_bg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_draw_bg start\n");
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("DB", SA_start);
#endif

    gdi_layer_push_and_set_active(g_idle_swatch_p->base_layer_handle);
    gdi_layer_clear_background(GDI_COLOR_BLACK);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);

    //Clock bg
    if (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        mmi_idle_swatch_analog_clock *analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
	#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
		{
		    mmi_idle_swatch_draw_download_image(0, analog_clock->bg_x, analog_clock->bg_y, !g_idle_swatch_p->is_tiny);
		}
	    else
		{
	#endif
        	if (analog_clock->bg_img_id)
        	{
        	#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            	if(g_idle_swatch_p->is_tiny == MMI_TRUE)
            	{
                	gdi_image_draw_id(analog_clock->bg_x, analog_clock->bg_y, analog_clock->bg_img_id);
            	}
            	else
            	{
                	gdi_image_draw_id(analog_clock->bg_x, analog_clock->bg_y, analog_clock->tiny_bg_img_id);
            	}
			#else
		    	gdi_image_draw_id(analog_clock->bg_x, analog_clock->bg_y, analog_clock->bg_img_id);
			#endif
        	}
	#ifdef MMI_DOWNLOADABLE_CLOCK
		}
	#endif
    }
    else
    {
        mmi_idle_swatch_digital_clock *digital_clock = (mmi_idle_swatch_digital_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
	#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
		{
		    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
		    {
		        mmi_idle_swatch_draw_download_image(4, digital_clock->bg_x, digital_clock->bg_y, MMI_FALSE);
                mmi_idle_swatch_draw_download_image(15, 118, 95, MMI_FALSE);
		    }
			else
			{
			    mmi_idle_swatch_draw_download_image(14, digital_clock->bg_x, digital_clock->bg_y, MMI_TRUE);
                mmi_idle_swatch_draw_download_image(15, 118, 95, MMI_TRUE);
			}
		}
	#endif
    }

#ifdef __MMI_MAINLCD_128X32__
#ifdef __MMI_BT_SUPPORT__
	if(srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_ON || srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_SWITCHING_ON)
	{
		gdi_image_draw_id(113,15,IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_BT_ON);
	}

	if(srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_OFF || srv_bt_cm_get_power_status() == SRV_BT_CM_POWER_SWITCHING_OFF)
	{
		gdi_image_draw_id(113,15,IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_BT_OFF);
	}
#endif
#endif

    gdi_layer_pop_and_restore_active();
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("DB", SA_stop);
#endif
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_draw_bg end\n");
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_analog_clock_minute_tick
 * DESCRIPTION
 *  update when minute tick
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_get_analog_clock_minute_tick(U8 *hour_hand_counter, U8 *minute_hand_counter, U8 *second_hand_counter)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MYTIME t;
    U8 h, m, s;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //GetDateTime(&t);
    DTGetRTCTime(&t);
    m = t.nMin;
    s = t.nSec;
    *minute_hand_counter = m;
    *second_hand_counter = s;
    h = t.nHour;
    h++;
    if (h > 12)
    {
        h -= 12;
    }
    *hour_hand_counter = (h - 1) * 5;
    *hour_hand_counter += m / 12;
    if (*minute_hand_counter >= 60)
    {
        *minute_hand_counter = 0;
    }
    if (*second_hand_counter >= 60)
    {
        *second_hand_counter = 0;
    }
    if ((*minute_hand_counter % 12) == 0)
    {
        if (*hour_hand_counter >= 60)
        {
            *hour_hand_counter = 0;
        }
    }
}


static const FLOAT g_idle_swatch_clock_sin_table[] = 
{
    (FLOAT) - 0.99999820, (FLOAT) - 0.99431727, (FLOAT) - 0.97773360, (FLOAT) - 0.95042917,
        (FLOAT) - 0.91270313,
        (FLOAT)-0.86496924, (FLOAT)-0.80775119, (FLOAT)-0.74167587,
    (FLOAT) - 0.66746803, (FLOAT) - 0.58594175, (FLOAT) - 0.49799022, (FLOAT) - 0.40457821,
        (FLOAT) - 0.30673042,
        (FLOAT)-0.20551889, (FLOAT)-0.10205382, (FLOAT)0.00000000,
    (FLOAT) 0.10457040, (FLOAT) 0.20799418, (FLOAT) 0.30913729, (FLOAT) 0.40689072, (FLOAT) 0.50018258,
        (FLOAT) 0.58798990,
        (FLOAT)0.66934994, (FLOAT)0.74337050,
    (FLOAT) 0.80923998, (FLOAT) 0.86623616, (FLOAT) 0.91373403, (FLOAT) 0.95121274, (FLOAT) 0.97826142,
        (FLOAT) 0.99458343,
        (FLOAT)0.99999980, (FLOAT)0.99445115,
    (FLOAT) 0.97799831, (FLOAT) 0.95082172, (FLOAT) 0.91321931, (FLOAT) 0.86560342, (FLOAT) 0.80849624,
        (FLOAT) 0.74252372,
        (FLOAT)0.66840956, (FLOAT)0.58696629,
    (FLOAT) 0.49908672, (FLOAT) 0.40573486, (FLOAT) 0.30793410, (FLOAT) 0.20675662, (FLOAT) 0.10331227,
    
        (FLOAT) - 0.00126490,
        (FLOAT)-0.10582843, (FLOAT)-0.20923132,
    (FLOAT) - 0.31033998, (FLOAT) - 0.40804598, (FLOAT) - 0.50127753, (FLOAT) - 0.58901256,
        (FLOAT) - 0.67028925,
        (FLOAT)-0.74421601, (FLOAT)-0.80998244, (FLOAT)-0.86686752,
    (FLOAT)-0.91424734, (FLOAT)-0.95160225, (FLOAT)-0.97852297, (FLOAT)-0.99471414,
};


static const FLOAT g_idle_swatch_clock_cos_table[] = 
{
    (FLOAT) 0.00189735, (FLOAT) 0.10645731, (FLOAT) 0.20984996, (FLOAT) 0.31094114, (FLOAT) 0.40862330,
        (FLOAT) 0.50182489,
        (FLOAT)0.58952354, (FLOAT)0.67075845,
    (FLOAT) 0.74463846, (FLOAT) 0.81035318, (FLOAT) 0.86718264, (FLOAT) 0.91450340, (FLOAT) 0.95179643,
        (FLOAT) 0.97865315,
        (FLOAT)0.99477888, (FLOAT)1.00000000,
    (FLOAT) 0.99451749, (FLOAT) 0.97813006, (FLOAT) 0.95101742, (FLOAT) 0.91347684, (FLOAT) 0.86591997,
        (FLOAT) 0.80886827,
        (FLOAT)0.74294728, (FLOAT)0.66887989,
    (FLOAT) 0.58747821, (FLOAT) 0.49963478, (FLOAT) 0.40631283, (FLOAT) 0.30853576, (FLOAT) 0.20737548,
        (FLOAT) 0.10394131,
        (FLOAT)-0.00063245, (FLOAT)-0.10519940,
    (FLOAT) - 0.20861283, (FLOAT) - 0.30973870, (FLOAT) - 0.40746839, (FLOAT) - 0.50073018,
        (FLOAT) - 0.58850135,
        (FLOAT)-0.66981977, (FLOAT)-0.74379342, (FLOAT)-0.80961137,
    (FLOAT) - 0.86655204, (FLOAT) - 0.91399082, (FLOAT) - 0.95140769, (FLOAT) - 0.97839241,
        (FLOAT) - 0.99464897,
        (FLOAT)-0.99999920, (FLOAT)-0.99438440, (FLOAT)-0.97786617,
    (FLOAT) - 0.95062563, (FLOAT) - 0.91296138, (FLOAT) - 0.86528656, (FLOAT) - 0.80812388,
        (FLOAT) - 0.74209994,
        (FLOAT)-0.66793902, (FLOAT)-0.58645414, (FLOAT)-0.49853857,
    (FLOAT)-0.40515651, (FLOAT)-0.30733233, (FLOAT)-0.20613779, (FLOAT)-0.10268295,
};


#ifdef G2D_SUPPORT

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_set_identity
 * DESCRIPTION
 *  
 * PARAMETERS
 *  matrix
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_set_identity(mmi_idle_swatch_matrix_struct *matrix)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    matrix->m[0] = 1;
    matrix->m[1] = 0;
    matrix->m[2] = 0;
    matrix->m[3] = 0;
    matrix->m[4] = 1;
    matrix->m[5] = 0;
    matrix->m[6] = 0;
    matrix->m[7] = 0;
    matrix->m[8] = 1;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_set_traslation
 * DESCRIPTION
 *  
 * PARAMETERS
 *  matrix
 *  tx
 *  ty
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_set_traslation(mmi_idle_swatch_matrix_struct *matrix, float tx, float ty)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_set_identity(matrix);
    matrix->m[2] = tx;
    matrix->m[5] = ty;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_rotate_z
 * DESCRIPTION
 *             | cos(a)  -sin(a)  0  |
 * Rz(a) = | sin(a)  cos(a)    0  |
 *             | 0          0          1 |
 *
 *  VfxMatrix3x3Ex::setRotateByZ
 * PARAMETERS
 *  matrix
 *  angle
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_rotate_z(mmi_idle_swatch_matrix_struct *matrix, U8 angle)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_set_identity(matrix);
    matrix->m[0] = matrix->m[4] = g_idle_swatch_clock_cos_table[angle];
    matrix->m[3] = g_idle_swatch_clock_sin_table[angle];
    matrix->m[1] = -matrix->m[3];
    //matrix->m[1] = g_idle_swatch_clock_sin_table[angle];
    //matrix->m[3] = -matrix->m[1];
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_matrix_multiply
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_matrix_multiply(mmi_idle_swatch_matrix_struct *matrix_a, mmi_idle_swatch_matrix_struct *matrix_b, mmi_idle_swatch_matrix_struct *matrix_out)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/

    /* Column major matrix multiplication */
    matrix_out->m[0] = matrix_a->m[0] * matrix_b->m[0] + matrix_a->m[3] * matrix_b->m[1] + matrix_a->m[6] * matrix_b->m[2];
    matrix_out->m[3] = matrix_a->m[0] * matrix_b->m[3] + matrix_a->m[3] * matrix_b->m[4] + matrix_a->m[6] * matrix_b->m[5];
    matrix_out->m[6] = matrix_a->m[0] * matrix_b->m[6] + matrix_a->m[3] * matrix_b->m[7] + matrix_a->m[6] * matrix_b->m[8];

    matrix_out->m[1] = matrix_a->m[1] * matrix_b->m[0] + matrix_a->m[4] * matrix_b->m[1] + matrix_a->m[7] * matrix_b->m[2];
    matrix_out->m[4] = matrix_a->m[1] * matrix_b->m[3] + matrix_a->m[4] * matrix_b->m[4] + matrix_a->m[7] * matrix_b->m[5];
    matrix_out->m[7] = matrix_a->m[1] * matrix_b->m[6] + matrix_a->m[4] * matrix_b->m[7] + matrix_a->m[7] * matrix_b->m[8];

    matrix_out->m[2] = matrix_a->m[2] * matrix_b->m[0] + matrix_a->m[5] * matrix_b->m[1] + matrix_a->m[8] * matrix_b->m[2];
    matrix_out->m[5] = matrix_a->m[2] * matrix_b->m[3] + matrix_a->m[5] * matrix_b->m[4] + matrix_a->m[8] * matrix_b->m[5];
    matrix_out->m[8] = matrix_a->m[2] * matrix_b->m[6] + matrix_a->m[5] * matrix_b->m[7] + matrix_a->m[8] * matrix_b->m[8];

}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_image_rotate_with_g2d
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_image_rotate_with_g2d(U16 center_x, U16 center_y, U16 image_id, S32 image_width, S32 image_height, U8 angle, S8 indexnum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j, image_layer_buff_size;
    PU8 image_layer_buff_ptr;
    gdi_handle image_layer_handle;
    mmi_idle_swatch_matrix_struct matrix_translation, matrix_rotate_z, matrix_result;
    S32 rwidth, rheight, roffset, cheight;
    S32 offset;
    mmi_idle_swatch_analog_clock *analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    {
        rwidth = image_width; 
        rheight = image_height;
        cheight = rheight;
        roffset = 0;
        if(g_idle_swatch_p->is_tiny == MMI_TRUE)
        {
            offset = analog_clock->offset;
        }
        else
        {
            if(g_idle_swatch_p->swatch_index != 0)
            {
                if(indexnum == 1)
                {
                    offset = -44;
                    rheight = 64;
                    rwidth = 7;
                }
                else
                {
                    offset = -68;
                    rheight = 88;
                    rwidth = 4;
                }
            }
            else
            {
                offset = 0;
            }
        }
    }
 
    
    image_layer_buff_size = (rwidth*rheight*GDI_MAINLCD_BIT_PER_PIXEL*2) >> 3;
    //if it assert, you have to check the configure of MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE in IdleMemCfg.h
    MMI_ASSERT(image_layer_buff_size <= MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE);
    image_layer_buff_ptr = g_idle_swatch_p->temp_layer_buf_ptr;
    MMI_ASSERT(image_layer_buff_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        rwidth,
        rheight,
        &image_layer_handle,
        (PU8)image_layer_buff_ptr,
        image_layer_buff_size);
    MMI_ASSERT(image_layer_handle != NULL);
    gdi_layer_push_and_set_active(image_layer_handle);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    if(g_idle_swatch_p->swatch_index == 0)
    {
        gdi_image_draw_id(0, roffset, image_id);
    }
    else
    {
        if(g_idle_swatch_p->is_tiny == MMI_TRUE)
        {
            #ifdef MMI_DOWNLOADABLE_CLOCK
            if(g_idle_swatch_p->swatch_index < MMI_NATIVE_CLOCK_NUM)
            {
                gdi_image_draw_id(0, roffset, image_id);
            }
            else
	        {
	            mmi_idle_swatch_draw_download_image(image_id, 0, roffset, MMI_TRUE);
            } 
            #else
                gdi_image_draw_id(0, roffset, image_id);
	        #endif
        }
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        else
        {
            if(analog_clock->black)
            {
                gdi_layer_clear(GDI_COLOR_BLACK);
            }
            else
            {
                gdi_layer_clear(GDI_COLOR_WHITE);
            }
        }
        #else
        else
        {
            #ifdef MMI_DOWNLOADABLE_CLOCK
            if(g_idle_swatch_p->swatch_index < MMI_NATIVE_CLOCK_NUM)
            {
                gdi_image_draw_id(0, roffset, image_id);
            }
            else
	        {
	            mmi_idle_swatch_draw_download_image(image_id, 0, roffset, MMI_TRUE);
            }
            #else
                gdi_image_draw_id(0, roffset, image_id);
	        #endif
        }
        #endif
    }
    gdi_layer_pop_and_restore_active();    

#ifdef __MMI_MAINLCD_128X128__
    mmi_idle_swatch_set_traslation(&matrix_translation, 0, 7);
#else
    if(g_idle_swatch_p->swatch_index != 0 && g_idle_swatch_p->is_tiny != MMI_TRUE)
    {
        mmi_idle_swatch_set_traslation(&matrix_translation, -rwidth * 0.5, offset);
    }
    else
    {
        mmi_idle_swatch_set_traslation(&matrix_translation, -rwidth * 0.5, -cheight * 0.5 - offset);
    }
#endif
    mmi_idle_swatch_rotate_z(&matrix_rotate_z, (angle+15)%60); 
    mmi_idle_swatch_matrix_multiply(&matrix_translation, &matrix_rotate_z, &matrix_result);
    matrix_result.m[2] += center_x;
    matrix_result.m[5] += center_y;
    
    gdi_2d_linear_transfrom(
        matrix_result.m,
        image_layer_handle,
        0,
        0,
        rwidth,
        rheight,
        0,
        0,
        MMI_IDLE_SWATCH_WIDTH,
        MMI_IDLE_SWATCH_HEIGHT,
        GDI_LT_SRC_KEY_EDGE_FILTER_DULPLICATE,
        GDI_COLOR_TRANSPARENT,
        GDI_LT_SAMPLE_MODE_BILINEAR_WITH_EDGE_FILTER_DULPLICATE,
        0);

    gdi_layer_free(image_layer_handle);
}

#endif  //G2D_SUPPORT


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_image_rotate
 * DESCRIPTION
 *
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_image_rotate(U16 center_x, U16 center_y, U16 image_id, S32 image_width, S32 image_height, U8 angle, U16 clock_x, U16 clock_y, S32 clock_width, S32 clock_height, S8 indexnum)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
#ifdef G2D_SUPPORT
    mmi_idle_swatch_image_rotate_with_g2d(center_x, center_y, image_id, image_width, image_height, angle, indexnum);
#else  //G2D_SUPPORT
    S32 i, j, image_layer_buff_size, clock_layer_buff_size;
    PU8 image_layer_buff_ptr, clock_layer_buff_ptr;
    gdi_handle image_layer_handle, clock_layer_handle;
    S32 radius;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    gdi_push_and_set_alpha_blending_source_layer(g_idle_swatch_p->update_layer_handle);
    
    image_layer_buff_size = (image_width*image_height*GDI_MAINLCD_BIT_PER_PIXEL*2) >> 3;
    //if it assert, you have to check the configure of MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE in IdleMemCfg.h
    MMI_ASSERT(image_layer_buff_size <= MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE);
    image_layer_buff_ptr = g_idle_swatch_p->temp_layer_buf_ptr;
    MMI_ASSERT(image_layer_buff_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        image_width,
        image_height,
        &image_layer_handle,
        (PU8)image_layer_buff_ptr,
        image_layer_buff_size);
    MMI_ASSERT(image_layer_handle != NULL);
    gdi_layer_push_and_set_active(image_layer_handle);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_image_draw_id(0, 0, image_id);
    gdi_layer_pop_and_restore_active();

    clock_layer_buff_size = (clock_width*clock_height*GDI_MAINLCD_BIT_PER_PIXEL*2) >> 3;
    //if it assert, you have to check the configure of MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE in IdleMemCfg.h
    MMI_ASSERT((image_layer_buff_size+clock_layer_buff_size) <= MMI_IDLE_SWATCH_TEMP_LAYER_BUFFER_SIZE);
    clock_layer_buff_ptr = g_idle_swatch_p->temp_layer_buf_ptr + image_layer_buff_size;
    MMI_ASSERT(clock_layer_buff_ptr != NULL);
    gdi_layer_create_cf_using_outside_memory(
        GDI_COLOR_FORMAT_32_PARGB,
        0,
        0,
        clock_width,
        clock_height,
        &clock_layer_handle,
        clock_layer_buff_ptr,
        clock_layer_buff_size);
    MMI_ASSERT(clock_layer_handle != NULL);
    gdi_layer_push_and_set_active(clock_layer_handle);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_pop_and_restore_active();
    
    radius = image_height / 2;
    center_x -= clock_x;
    center_y -= clock_y;
    angle = (angle+15)%60;
    for(i = 0; i < image_height; i++)
    {
        for(j = 0; j < image_width; j++)
        {
            float x0, y0;
            S32 x1, y1, x_offset_from_center, y_offset_from_center;

            x_offset_from_center = j - image_width / 2;
            y_offset_from_center = i - radius;
            
            x0 = x_offset_from_center * g_idle_swatch_clock_cos_table[angle] - y_offset_from_center * g_idle_swatch_clock_sin_table[angle];
            y0 = x_offset_from_center * g_idle_swatch_clock_sin_table[angle] + y_offset_from_center * g_idle_swatch_clock_cos_table[angle];
            
            x1 = (S32)x0;
            y1 = (S32)y0;
            #if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
            #endif
            //memcpy((g_idle_swatch_p->update_layer_buf_ptr + (center_y + y1) * MMI_IDLE_SWATCH_WIDTH * 4 + (center_x + x1) * 4), (image_layer_buff_ptr + i * image_width * 4 + j * 4), 4);
            memcpy((clock_layer_buff_ptr + (center_y + y1) * clock_width * 4 + (center_x + x1) * 4), (image_layer_buff_ptr + i * image_width * 4 + j * 4), 4);
       }
    }

    gdi_layer_push_and_set_active(clock_layer_handle);
    gdi_layer_set_position(clock_x, clock_y);
    gdi_layer_pop_and_restore_active();
    gdi_layer_set_background(0);
    gdi_layer_flatten_with_clipping((gdi_handle)gdi_act_layer, clock_layer_handle, NULL, NULL);

    gdi_layer_free(image_layer_handle);
    gdi_layer_free(clock_layer_handle);
    
    gdi_pop_and_restore_alpha_blending_source_layer();
#endif  //G2D_SUPPORT
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_get_number_bit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  number [IN] U32
 * RETURNS
 *  U8
 *****************************************************************************/
static U8 mmi_idle_swatch_get_number_bit(U32 number)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U8 i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if (number < 10)
    {
        return 1;
    }
    
    for (i = MMI_IDLE_SWATCH_AP_COUNT_MAX_BIT; i > 0; i--)
    {
        U32 divisor = 1;
        for (j = 0; j < i; j++)
        {
            divisor *= 10;
        }
        if ((number / divisor) > 0)
        {
            return (i+1);
        }
    }

    return 0;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_number_image
 * DESCRIPTION
 *  Draw Number Image
 * PARAMETERS
 *  number [IN] U32
 *  num_0_img_id [IN] MMI_ID
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_number_image(U16 x, 
                                                          U16 y, 
                                                          U32 number, 
                                                          MMI_ID num_0_img_id, 
                                                          U8 bit, 
                                                          S16 gap, 
                                                          MMI_BOOL count_is_left_of_hint
                                                      #ifdef MMI_DOWNLOADABLE_CLOCK
													      ,U8 index_num
													  #endif
													  )
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j, num_width, num_height;
    U16 current_x, current_y;
    U8 draw_bit;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(number < MMI_IDLE_SWATCH_AP_COUNT_MAX_NUM);

#ifdef MMI_DOWNLOADABLE_CLOCK
    if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
    {
        if(mmi_idle_swatch_get_download_image_info(index_num,&num_width,&num_height,MMI_FALSE) == MMI_FALSE)
		{
		    return;
		}
    }
	else
	{
#endif		
        gdi_image_get_dimension_id(num_0_img_id, &num_width, &num_height);
#ifdef MMI_DOWNLOADABLE_CLOCK
    }
#endif


   // MMI_ASSERT(num_width > 0 && num_height > 0);

    if (bit == 0)
    {
        draw_bit = mmi_idle_swatch_get_number_bit(number);
    }
    else
    {
        draw_bit = bit;
    }
    
    MMI_ASSERT(draw_bit > 0 && draw_bit <= MMI_IDLE_SWATCH_AP_COUNT_MAX_NUM);
    
    //Draw Number
    if (count_is_left_of_hint)
    {
        current_x = x - num_width * draw_bit;
    }
    else
    {
        current_x = x;
    }
    current_y = y;
    
    for (i = 0; i < draw_bit - 1; i++)
    {
        U16 divisor = 1, num_to_draw = 0;
        for (j = 0; j < draw_bit-i-1; j++)
        {
            divisor *= 10;
        }
        num_to_draw = number / divisor;
        number -= num_to_draw * divisor;

	#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
		{
		    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
		    {
		        mmi_idle_swatch_draw_download_image(index_num + num_to_draw, current_x, current_y, MMI_FALSE);
		    }
			else
			{
			    mmi_idle_swatch_draw_download_image(num_to_draw, current_x, current_y, MMI_TRUE);
			}
		}
	    else
		{
	#endif
            gdi_image_draw_id(current_x, current_y, num_0_img_id + num_to_draw);
	#ifdef MMI_DOWNLOADABLE_CLOCK
	    }
	#endif
        current_x += num_width + gap;
    }

#ifdef MMI_DOWNLOADABLE_CLOCK
	if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
	{
	    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
	    {
		    mmi_idle_swatch_draw_download_image(index_num + number, current_x, current_y, MMI_FALSE);
	    }
		else
		{
		    mmi_idle_swatch_draw_download_image(number, current_x, current_y, MMI_TRUE);
		}
	}
	else
	{
#endif
        gdi_image_draw_id(current_x, current_y, num_0_img_id + number);
#ifdef MMI_DOWNLOADABLE_CLOCK
	}
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_update_clock_by_minute
 * DESCRIPTION
 *  it will be called in DateTimerProc, use for update digital clock
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_update_clock_by_minute(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    if ((g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL ||
		(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG && !g_idle_swatch_p->draw_second))&&
        g_idle_swatch_p->is_active)
    {
        mmi_idle_swatch_update_clock();
    }
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_update_clock_by_second
 * DESCRIPTION
 *  it will be called in DateTimerProc, use for update analog clock
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_update_clock_by_second(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_update_clock
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_update_clock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_update_clock start,is_active:%d,is_lcd_sleep:%d\n", g_idle_swatch_p->is_active, srv_backlight_is_lcd_sleep());
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("UC", SA_start);
#endif

    if (!g_idle_swatch_p->is_active)
    {
        return;
    }

    mmi_idle_swatch_draw_bg();
    
    gdi_layer_push_and_set_active(g_idle_swatch_p->update_layer_handle);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    gdi_layer_push_and_set_clip(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x2,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y2);

#ifdef __MMI_MAINLCD_128X32__
    gdi_draw_solid_rect(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x2,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y2,
        GDI_COLOR_BLACK);
#else
    gdi_draw_solid_rect(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y1,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.x2,
        g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.area.y2,
        GDI_COLOR_TRANSPARENT);
#endif

    if (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        U8 hour_hand_counter, minute_hand_counter, second_hand_counter;
        S32 image_width, image_height, clock_width, clock_height;
        U16 image_id;
        S32 width, height;
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        ts_mmi_idle_swatch_analog_clock *analogtiny_clock;
        #endif
        
        mmi_idle_swatch_analog_clock *analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        analogtiny_clock = (ts_mmi_idle_swatch_analog_clock*)&(ts_tiny_skin_data.clock.data);
        #endif
        
        mmi_idle_swatch_get_analog_clock_minute_tick(&hour_hand_counter, &minute_hand_counter, &second_hand_counter);
        RANFOW_TRACE("[SWATCH]hour_hand_counter=%d,minute_hand_counter=%d,second_hand_counter=%d\n", hour_hand_counter, minute_hand_counter, second_hand_counter);

        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        analogtiny_clock->hc = hour_hand_counter;
        analogtiny_clock->mc = minute_hand_counter;
        #endif
        
        //Draw hour hand
        #ifdef MMI_DOWNLOADABLE_CLOCK
        if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_get_download_image_info(0, &clock_width, &clock_height, !g_idle_swatch_p->is_tiny);
            mmi_idle_swatch_get_download_image_info(1, &image_width, &image_height, !g_idle_swatch_p->is_tiny);
        }
		else
		#endif
		{
		    gdi_image_get_dimension_id(analog_clock->bg_img_id, &clock_width, &clock_height);
            gdi_image_get_dimension_id(analog_clock->hour_hand_img_id, &image_width, &image_height);
		}
		
		#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
		#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    1,
                    image_width,
                    image_height,
                    hour_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    1);
        }
		else
		#endif
		{
		    if(g_idle_swatch_p->is_tiny == MMI_TRUE)
		    {
		        image_id = analog_clock->hour_hand_img_id;
		    }
			else
			{
			    image_id = analog_clock->tiny_hour_hand_img_id;
			}

			mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    image_id,
                    image_width,
                    image_height,
                    hour_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    1);

		}
		#else
		#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    1,
                    image_width,
                    image_height,
                    hour_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    1);
        }
        else
		#endif
        {
            mmi_idle_swatch_image_rotate(
                analog_clock->center_x,
                analog_clock->center_y,
                analog_clock->hour_hand_img_id,
                image_width,
                image_height,
                hour_hand_counter,
                analog_clock->bg_x,
                analog_clock->bg_y,
                clock_width,
                clock_height,
                1);
        }
		#endif
        
        //Draw minute hand
        #ifdef MMI_DOWNLOADABLE_CLOCK
        if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_get_download_image_info(2, &image_width, &image_height, !g_idle_swatch_p->is_tiny);
        }
		else
		#endif
		{
            gdi_image_get_dimension_id(analog_clock->minute_hand_img_id, &image_width, &image_height);
		}
		
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
		#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    2,
                    image_width,
                    image_height,
                    minute_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    2);
        }
		else
		#endif
		{
		    if(g_idle_swatch_p->is_tiny == MMI_TRUE)
		    {
		        image_id = analog_clock->minute_hand_img_id;
		    }
			else
			{
			    image_id = analog_clock->tiny_minute_hand_img_id;
			}

			mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    image_id,
                    image_width,
                    image_height,
                    minute_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    2);
		}
		#else
		#ifdef MMI_DOWNLOADABLE_CLOCK
		if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
        {
            mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    2,
                    image_width,
                    image_height,
                    minute_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    2);
        }
        else
		#endif
        {
            mmi_idle_swatch_image_rotate(
                analog_clock->center_x,
                analog_clock->center_y,
                analog_clock->minute_hand_img_id,
                image_width,
                image_height,
                minute_hand_counter,
                analog_clock->bg_x,
                analog_clock->bg_y,
                clock_width,
                clock_height,
                2);
        }
		#endif
        
        
        //Draw second hand
        if(g_idle_swatch_p->draw_second)
        {
            #ifdef MMI_DOWNLOADABLE_CLOCK
            if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
            {
                mmi_idle_swatch_get_download_image_info(3, &image_width, &image_height, !g_idle_swatch_p->is_tiny);
            }
		    else
			#endif
		    {
                gdi_image_get_dimension_id(analog_clock->second_hand_img_id, &image_width, &image_height);
		    }

			#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
			#ifdef MMI_DOWNLOADABLE_CLOCK
		    if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
            {
                mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    3,
                    image_width,
                    image_height,
                    second_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    3);
            }
		    else
			#endif
		    {
		        if(g_idle_swatch_p->is_tiny == MMI_TRUE)
		        {
		            image_id = analog_clock->second_hand_img_id;
		        }
			    else
			    {
			        image_id = analog_clock->tiny_second_hand_img_id;
			    }

			    mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    image_id,
                    image_width,
                    image_height,
                    second_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    3);
		    }
		    #else
			#ifdef MMI_DOWNLOADABLE_CLOCK
		    if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
            {
                mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    3,
                    image_width,
                    image_height,
                    second_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    3);
            }
            else
			#endif
            {
                mmi_idle_swatch_image_rotate(
                    analog_clock->center_x,
                    analog_clock->center_y,
                    analog_clock->second_hand_img_id,
                    image_width,
                    image_height,
                    second_hand_counter,
                    analog_clock->bg_x,
                    analog_clock->bg_y,
                    clock_width,
                    clock_height,
                    3);
            }
		    #endif
        }
    }
    else
    {
        MYTIME t;
        U8 bit = 0;
        S16 offset = 0;  //for special clock to adjust x when hour is largger than 10
        S16 hour_offset = 0;  //for special clock to adjust hour offset when hour is largger than 10
        mmi_idle_swatch_digital_clock *digital_clock = (mmi_idle_swatch_digital_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);

        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        ts_mmi_idle_swatch_digital_clock *ts_digit_clock = (ts_mmi_idle_swatch_digital_clock*)&(ts_tiny_skin_data.clock.data);
        #endif
        
        //GetDateTime(&t);
        DTGetRTCTime(&t);

        if (digital_clock->add_zero)
        {
            bit = 2;
        }
        
        //Draw am/pm
        #ifndef __MMI_MAINLCD_128X32__
        if(PhnsetGetTimeFormat() == 0) //12 hours
        {
        if (t.nHour >= 12)
        {
            if (t.nHour > 12)
            {
                t.nHour -= 12;
            }

            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
                ts_digit_clock->ampm = 1;
            #endif
            
                #ifdef MMI_DOWNLOADABLE_CLOCK
				if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
				{
				    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
				    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
					   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
				    {
				        if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
				        {
                            mmi_idle_swatch_draw_download_image(3, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
				        }
						else
						{
						    mmi_idle_swatch_draw_download_image(13, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
				    }
					else
					{
					    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
					    {
					        mmi_idle_swatch_draw_download_image(2, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
					    }
						else
						{
						    mmi_idle_swatch_draw_download_image(11, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
					}
					#else
					    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
					    {
					        mmi_idle_swatch_draw_download_image(2, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
					    }
						else
						{
						    mmi_idle_swatch_draw_download_image(11, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
					#endif
				}
				else
		    {
	        #endif
			    #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
                if(g_idle_swatch_p->is_tiny == MMI_TRUE)
                {
                    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
					    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
						   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
					    {
					        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id+1);
					    }
						else
						{
						    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id);
						}
					#else
					    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id);
					#endif
                }
                else
                {
                    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
                    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
                       mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
                    {
                        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_pm_img_id+1);
                    }
                    else
                    {
                        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_pm_img_id);
                    }
                    #else
                    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_pm_img_id);
                    #endif
                    //gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_pm_img_id);
				}
				#else
				{
				    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
					    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
						   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
					    {
					        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id+1);
					    }
						else
						{
						    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id);
						}
					#else
					    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->pm_img_id);
					#endif
				}
				#endif
			#ifdef MMI_DOWNLOADABLE_CLOCK
			}
			#endif
        }
        else
        {
            if (t.nHour == 0)
            {
                t.nHour = 12;
            }

            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
                ts_digit_clock->ampm = 0;
            #endif
        
                #ifdef MMI_DOWNLOADABLE_CLOCK
				if(g_idle_swatch_p->swatch_index >= MMI_NATIVE_CLOCK_NUM)
				{
				    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
				    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
					   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
				    {
				        if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
				        {
				            mmi_idle_swatch_draw_download_image(1, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
				        }
						else
						{
						    mmi_idle_swatch_draw_download_image(12, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
				    }
					else
					{
					    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
					    {
				            mmi_idle_swatch_draw_download_image(0, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
					    }
						else
						{
						    mmi_idle_swatch_draw_download_image(10, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
					}
					#else
					    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
					    {
					        mmi_idle_swatch_draw_download_image(0, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_FALSE);
					    }
						else
						{
						    mmi_idle_swatch_draw_download_image(10, digital_clock->ampm_x+offset, digital_clock->ampm_y, MMI_TRUE);
						}
					#endif
				}
				else
		    {
            #endif
                #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
                if(g_idle_swatch_p->is_tiny == MMI_TRUE)
                {
                    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
					    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
						   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
					    {
					        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id+1);
					    }
						else
						{
						    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id);
						}
					#else
					    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id);
					#endif                
                }
                else
                {
                    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
                    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
                       mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
                    {
                        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_am_img_id+1);
                    }
                    else
                    {
                        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_am_img_id);
                    }
                    #else
                    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_am_img_id);
                    #endif
                    //gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->tiny_am_img_id);
                }
                #else
                {
                    #ifdef CLOCK_SUPPORT_SWITCH_IMG_BY_LANG
					    if(mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECH ||
						   mmi_swatch_get_current_language_index() == MMI_SWATCH_LANGUAGECHTR)
					    {
					        gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id+1);
					    }
						else
						{
						    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id);
						}
					#else
					    gdi_image_draw_id(digital_clock->ampm_x+offset, digital_clock->ampm_y, digital_clock->am_img_id);
					#endif 
				}
				#endif
			#ifdef MMI_DOWNLOADABLE_CLOCK
            }
			#endif
        }
        }
        else
        {
            #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
            ts_digit_clock->ampm = 2;
            #endif
        }
		#endif
        //Draw hour
        #ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
        if(g_idle_swatch_p->is_tiny == MMI_TRUE)
        {
            mmi_idle_swatch_draw_number_image(digital_clock->hour_x+offset, digital_clock->hour_y, t.nHour, digital_clock->hour_num_0_img_id, bit, digital_clock->hour_num_gap+hour_offset, MMI_FALSE
				                              #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
        }
        else
        {
            mmi_idle_swatch_draw_number_image(digital_clock->hour_x+offset, digital_clock->hour_y, t.nHour, digital_clock->tiny_hour_num_0_img_id, bit, digital_clock->hour_num_gap+hour_offset, MMI_FALSE
				                              #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
        }
        //Draw minute
        if(g_idle_swatch_p->is_tiny == MMI_TRUE)
        {
            mmi_idle_swatch_draw_number_image(digital_clock->minute_x+offset, digital_clock->minute_y, t.nMin, digital_clock->minute_num_0_img_id, bit, digital_clock->minute_num_gap, MMI_FALSE
				                              #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
        }
        else
        {
            mmi_idle_swatch_draw_number_image(digital_clock->minute_x+offset, digital_clock->minute_y, t.nMin, digital_clock->tiny_minute_num_0_img_id, bit, digital_clock->minute_num_gap, MMI_FALSE
				                              #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
        }
		#else
		    mmi_idle_swatch_draw_number_image(digital_clock->hour_x+offset, digital_clock->hour_y, t.nHour, digital_clock->hour_num_0_img_id, bit, digital_clock->hour_num_gap+hour_offset, MMI_FALSE
		                                      #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
		    mmi_idle_swatch_draw_number_image(digital_clock->minute_x+offset, digital_clock->minute_y, t.nMin, digital_clock->minute_num_0_img_id, bit, digital_clock->minute_num_gap, MMI_FALSE
		                                      #ifdef MMI_DOWNLOADABLE_CLOCK
											  ,5
											  #endif
											  );
		#endif
		
        #ifdef __MMI_MAINLCD_128X32__
		gdi_image_draw_id(63,8,IMG_ID_IDLE_SWATCH_DIGIT1_CLOCK_CO);
		#endif
		
    }
    
    gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    
    if (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_DIGITAL ||
	   (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG && !g_idle_swatch_p->draw_second))
    {
        mmi_idle_swatch_blt_previous();
    }
    
#ifdef __MAUI_SOFTWARE_LA__
    SLA_CustomLogging("UC", SA_stop);
#endif
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_update_clock end\n");
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_update
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_update(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	if (g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
	{
	    if(g_idle_swatch_p->draw_second)
	    {
            mmi_idle_swatch_start_timer(IDLE_SWATCH_UPDATE_TIMER, MMI_IDLE_SWATCH_ANALOG_UPDATE_DELAY, mmi_idle_swatch_update);
	    }
	}
    
    if (g_idle_swatch_p->update_type == MMI_IDLE_SWATCH_UPDATE_ALL)
    {
        mmi_idle_swatch_update_clock();
    }
    else if (g_idle_swatch_p->update_type == MMI_IDLE_SWATCH_UPDATE_AP)
    {
    
    }
    else if (g_idle_swatch_p->update_type == MMI_IDLE_SWATCH_UPDATE_CLOCK)
    {
        mmi_idle_swatch_update_clock();
    }

    mmi_idle_swatch_blt_previous();
}
  

void mmi_idle_swatch_event_callback()
{
    StopTimer(IDLE_SWATCH_TINY_REFESH_TIMER);
     if (g_idle_swatch_p->is_active)
     {
         mmi_idle_swatch_draw_bg();
         mmi_idle_swatch_draw_nail();
         mmi_idle_swatch_update();
     }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_event_handler
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_idle_swatch_event_handler(mmi_event_struct *evt)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    ASSERT(evt);
    RANFOW_TRACE("[SWATCH]mmi_idle_swatch_event_handler,evt_id=%d\n", evt->evt_id);

    switch (evt->evt_id)
    {
        case EVT_ID_GPIO_LCD_SLEEP_OUT:
        {
			#if defined(__TINY_SYS__)  
            AP_BtSS_mode_block(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
            AP_BtSS_mode_block(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
            #endif
			#ifdef __KEEP_LCD_ENGINE_ON__
            g_idle_swatch_p->draw_second = MMI_TRUE;
            g_idle_swatch_p->is_tiny = MMI_TRUE;
            if (g_idle_swatch_p->is_active)
            {
                StartTimer(IDLE_SWATCH_TINY_REFESH_TIMER, 1, mmi_idle_swatch_event_callback);
            }
			#endif
            break;
        }
        case EVT_ID_GPIO_LCD_SLEEP_IN:
        {
		    #ifdef __KEEP_LCD_ENGINE_ON__
            g_idle_swatch_p->draw_second = MMI_FALSE;
            g_idle_swatch_p->is_tiny = MMI_FALSE;
            if (g_idle_swatch_p->is_active)
            {
                //StartTimer(IDLE_SWATCH_TINY_REFESH_TIMER, 1, mmi_idle_swatch_event_callback);
                mmi_idle_swatch_draw_bg();
                mmi_idle_swatch_draw_nail();
                mmi_idle_swatch_update();
            }
			#endif
			#if defined(__TINY_SYS__)  
            AP_BtSS_mode_unblock(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
            AP_BtSS_mode_unblock(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
            #endif 
            break;
        }
        case EVT_ID_SCREEN_LOCK_KEY_PRE_LOCK_EVT_ROUTING:
        {
            mmi_frm_group_close(GRP_ID_SWATCH_SETTING);
            break;
        }
		#ifdef __MMI_MAINLCD_128X32__
		case EVT_ID_KEY_CLICK_DOUBLE:
		{
        if(srv_bootup_get_booting_mode() == SRV_BOOTUP_MODE_NORMAL)
        {
		        mmi_idle_display();
        }
        break;
		}
		#endif
    }
    
    return MMI_RET_OK;
}


#ifdef __MMI_MAINLCD_128X128__

void mmi_swatch_analog_key_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_sse_setup_scenario(GUI_SSE_SCENARIO_WEARABLE_CLOCK_SLIDE_DOWN);
	mmi_idle_swatch_enter_digit_screen();
}

void mmi_swatch_analog_key_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_sse_setup_scenario(GUI_SSE_SCENARIO_WEARABLE_CLOCK_SLIDE_UP);
	mmi_idle_swatch_enter_digit_screen();
}

void mmi_swatch_analog_enter_key_handler(void)
{
	/*----------------------------------------------------------------*/
	/* Local Variables												  */
	/*----------------------------------------------------------------*/

	/*----------------------------------------------------------------*/
	/* Code Body													  */
	/*----------------------------------------------------------------*/

	EntryMainMenuFromIdleScreen();
}

#endif


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_enter_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  group_id
 * RETURNS
 *  void
 *****************************************************************************/
mmi_ret mmi_idle_swatch_enter_proc(mmi_event_struct * evt)
{
	switch (evt->evt_id)
	{
		case EVT_ID_WEARABLE_DEVICE_MOVE_RIGHT:
			return MMI_RET_ERR;
			break;
		#ifdef __MMI_MAINLCD_128X32__
		case EVT_ID_KEY_CLICK_SINGLE:
			EntryMainMenuFromIdleScreen();
			break;
		#endif
		#ifdef __MMI_BT_NOTI_SRV__
		case EVT_ID_SRV_BT_NOTI_UPDATE_TIME_NOTIFY:
			if (g_idle_swatch_p->is_active)
			{
			    g_idle_swatch_p->update_type = MMI_IDLE_SWATCH_UPDATE_ALL;
			    mmi_idle_swatch_update();
			}
			break;
		#endif
        case EVT_ID_TIP_UPDATE_TIME:
        case EVT_ID_GATT_UPDATE_TF:
            if (g_idle_swatch_p->is_active)
            {
                g_idle_swatch_p->update_type = MMI_IDLE_SWATCH_UPDATE_ALL;
                mmi_idle_swatch_update();
            }
            break;
	    default:
			break;
	}
	return MMI_RET_OK;	

}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_enter
 * DESCRIPTION
 *  
 * PARAMETERS
 *  group_id
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_enter(MMI_ID group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    mmi_idle_swatch_analog_clock *analog_clock;
    S32 width, height;
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
//    MMI_TRACE(MOD_MMI_COMMON_APP, TRC_IDLE_SWATCH_ENTER, 100);
    //MMI_ASSERT(group_id != GRP_ID_INVALID);
    g_idle_swatch_p->is_tiny = MMI_TRUE;

#if 0
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
/* under construction !*/
#endif

#ifdef __FORCE_DISABLE_NOTIFICATION_POPUP__
            return;
#endif


	if(group_id != 0)
    g_idle_swatch_p->group_id = group_id;
    mmi_idle_swatch_init();
    
    entry_full_screen();
	#ifndef __MMI_MAINLCD_128X32__
    gdi_layer_multi_layer_enable();
	#endif
    //gdi_layer_set_blt_layer(g_idle_swatch_p->base_layer_handle, g_idle_swatch_p->update_layer_handle, 0, 0);

    if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        analog_clock = (mmi_idle_swatch_analog_clock*)&(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.data);
        gdi_image_get_dimension_id(analog_clock->nail_img_id,&width,&height);
        g_idle_swatch_p->nail_buffer = mmi_frm_asm_alloc_anonymous_nc(width * height * 4);
        gdi_layer_create_cf_using_outside_memory(
            GDI_COLOR_FORMAT_32_PARGB,
            0,
            0,
            width,
            height,
            &g_idle_swatch_p->nail_layer_handle,
            g_idle_swatch_p->nail_buffer,
            width * height * 4);
    }
    
    mmi_idle_swatch_draw_bg();    
    mmi_idle_swatch_update();
    mmi_idle_swatch_draw_nail();

#if !defined(__MMI_MAINLCD_128X128__)
    wgui_status_icon_bar_close_clock();
    wgui_status_icon_bar_update();
#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
    //StartNonAlignTimer(IDLE_SWATCH_TINY_ENCODE_TIMER,1,mmi_idle_encode_tiny_image_test);
	//mmi_idle_encode_tiny_image_test();
	stack_start_timer(g_idle_swatch_p->encode_timer_id, 0, kal_milli_secs_to_ticks(1));
#endif

#endif /*__MMI_MAINLCD_128X128__*/
#ifdef __MMI_MAINLCD_128X128__
	mmi_frm_set_key_handler(mmi_swatch_analog_key_down_handler,KEY_DOWN_ARROW,KEY_EVENT_UP);
    mmi_frm_set_key_handler(mmi_swatch_analog_key_up_handler,KEY_UP_ARROW,KEY_EVENT_UP);
	mmi_frm_set_key_handler(mmi_swatch_analog_enter_key_handler,KEY_LSK,KEY_EVENT_UP);
#endif 

#if defined(__TINY_SYS__)
    
    if(srv_backlight_is_on(SRV_BACKLIGHT_TYPE_MAINLCD) == MMI_TRUE)
    { 
        AP_BtSS_mode_block(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
        AP_BtSS_mode_block(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK_SLEEP);
    }

	mmi_frm_set_protocol_event_handler(MSG_ID_FRM_BTSS_MODE_CHANGED_IND,(PsIntFuncPtr)AP_watch_resume,MMI_TRUE);
#endif

    mmi_frm_cb_reg_event(EVT_ID_WEARABLE_DEVICE_MOVE_RIGHT, mmi_idle_swatch_enter_proc, NULL);
    //#ifdef __MMI_BT_NOTI_SRV__
	//mmi_frm_cb_reg_event(EVT_ID_SRV_BT_NOTI_UPDATE_TIME_NOTIFY, mmi_idle_swatch_enter_proc, NULL);
    //#endif
    #ifdef __MMI_MAINLCD_128X32__
	mmi_frm_set_key_handler(EntryMainMenuFromIdleScreen,KEY_POWER,KEY_LONG_PRESS);
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_exit
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_exit(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
   // MMI_TRACE(MOD_MMI_COMMON_APP, TRC_IDLE_SWATCH_EXIT, 100);
    //StopTimer(IDLE_SWATCH_UPDATE_TIMER);
    mmi_idle_swatch_stop_timer(IDLE_SWATCH_UPDATE_TIMER);

	#ifdef __MMI_MAINLCD_128X128__
	StopTimer(IDLE_SWATCH_UPDATE_TIMER);
	#endif
    mmi_idle_swatch_blt_previous();
    gdi_layer_flatten_previous_to_base();
    
    gdi_layer_multi_layer_disable();
    leave_full_screen();
    
    /* release ADM */
    mmi_idle_swatch_free_adm_layer();
    /* Free pool & delete ADM */
    mmi_idle_swatch_free_pool();
    mmi_idle_swatch_delete_adm();

    if(g_swatch_config_table[g_idle_swatch_p->swatch_index].clock.type == MMI_IDLE_SWATCH_CLOCK_TYPE_ANALOG)
    {
        gdi_layer_free(g_idle_swatch_p->nail_layer_handle);
        mmi_frm_asm_free_anonymous(g_idle_swatch_p->nail_buffer); 
    }
    
    g_idle_swatch_p->base_layer_handle = NULL;
    g_idle_swatch_p->update_layer_handle = NULL;
    g_idle_swatch_p->status_icon_bar_layer_handle = NULL;
    g_idle_swatch_p->status_icon_bar_layer_buf_ptr = NULL;
    g_idle_swatch_p->is_active = MMI_FALSE;

#ifdef __MMI_WATCH_SUPPORT_TINY_CLOCK__
	//mmi_idle_encode_free_image_test();
	//StopTimer(IDLE_SWATCH_TINY_ENCODE_TIMER);
    stack_stop_timer(g_idle_swatch_p->encode_timer_id);
#endif

#if defined(__TINY_SYS__) 
      AP_BtSS_mode_block(SUSPEND, AP_BTSS_MODE_BLOCKER_CLOCK);
      AP_BtSS_mode_block(HIBERNATION, AP_BTSS_MODE_BLOCKER_CLOCK);  	
	  mmi_frm_clear_protocol_event_handler(MSG_ID_FRM_BTSS_MODE_CHANGED_IND,(PsIntFuncPtr)AP_watch_resume);
#endif
    
    mmi_frm_cb_dereg_event(EVT_ID_WEARABLE_DEVICE_MOVE_RIGHT, mmi_idle_swatch_enter_proc, NULL);
    //#ifdef __MMI_BT_NOTI_SRV__
	//mmi_frm_cb_dereg_event(EVT_ID_SRV_BT_NOTI_UPDATE_TIME_NOTIFY, mmi_idle_swatch_enter_proc, NULL);
    //#endif

    #ifdef __MMI_MAINLCD_128X32__
	mmi_frm_cb_dereg_event(EVT_ID_KEY_CLICK_SINGLE, mmi_idle_swatch_enter_proc, NULL);
	#endif
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_bw_entry
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_bw_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //EntryNewScreen(SCR_ID_SWATCH_BW, NULL, NULL, NULL);
    if (!mmi_frm_scrn_enter(
            GRP_ID_SWATCH_BW,
            SCR_ID_SWATCH_BW,
            mmi_idle_swatch_exit,
            mmi_idle_swatch_bw_entry,
            MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }
    g_idle_swatch_p->is_tiny = MMI_FALSE;
    gui_sse_setup_scenario(GUI_SSE_SCENARIO_ENTER_MAINMENU); 
    mmi_idle_swatch_init();
    entry_full_screen();
    gdi_layer_multi_layer_enable();
    gui_screen_switch_effect_setup(0,0,0);

	//mmi_idle_swatch_encode_digit_image_buffer();
    //gdi_layer_set_blt_layer(g_idle_swatch_p->base_layer_handle, g_idle_swatch_p->update_layer_handle, 0, 0);

    mmi_idle_swatch_draw_bg();    
    mmi_idle_swatch_update();

    wgui_status_icon_bar_close_clock();
    wgui_status_icon_bar_update();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_bw_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param      :[IN]   event      
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
static mmi_ret mmi_idle_swatch_bw_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            break;
        }
        case EVT_ID_SCRN_ACTIVE:
        {
            mmi_idle_swatch_bw_entry();
            break;
        }
        case EVT_ID_SCRN_INACTIVE:
        {
            mmi_idle_swatch_exit();
            break;
        }
        case EVT_ID_SCRN_DEINIT:
        {            
            break;
        }
    }
    
    return MMI_RET_OK;
}



/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_long_tap_hdlr
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_enter_bw_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    group_id = mmi_frm_group_create_ex(
        g_idle_swatch_p->group_id, 
        GRP_ID_SWATCH_BW, 
        mmi_idle_swatch_bw_proc, 
        NULL, 
        MMI_FRM_NODE_SMART_CLOSE_FLAG);
    
    MMI_ASSERT(group_id != GRP_ID_INVALID);

    mmi_frm_scrn_create(
         GRP_ID_SWATCH_BW, 
         SCR_ID_SWATCH_BW, 
         mmi_idle_swatch_bw_proc,   
        NULL);

    /*if (!mmi_frm_scrn_enter(
            GRP_ID_SWATCH_BW,
            SCR_ID_SWATCH_BW,
            mmi_idle_swatch_exit,
            mmi_idle_swatch_bw_entry,
            MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }*/
}


#ifdef __MMI_MAINLCD_128X128__

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_digit_bg
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_digit_bg(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/    
    gdi_layer_push_and_set_active(g_idle_swatch_p->base_layer_handle);
    gdi_layer_clear_background(GDI_COLOR_BLACK);
    gdi_image_draw_id(0,0,IMG_ID_IDLE_SWATCH_DIGIT_BG);	
    gdi_layer_pop_and_restore_active();
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_hour
 * DESCRIPTION
 *  Draw Hour Image
 * PARAMETERS
 *  number [IN] U32
 *  num_0_img_id [IN] MMI_ID
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_hour(S16 hour)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j,width,height;
    U16 current_x, current_y;
    U8 draw_bit;
	S16 number = hour;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_DIGIT_HL0,&width,&height);
	draw_bit = mmi_idle_swatch_get_number_bit(number);
	current_x = 7;
	current_y = 7;
    
    for (i = 0; i < draw_bit - 1; i++)
    {
        U16 divisor = 1, num_to_draw = 0;
        for (j = 0; j < draw_bit-i-1; j++)
        {
            divisor *= 10;
        }
        num_to_draw = number / divisor;
        number -= num_to_draw * divisor;
        
        gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_HL0 + num_to_draw);
        current_x += width;
    }

	if(i == 0)
	{
	    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_HL0);
		current_x += width;
	}
	
    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_HR0 + number);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_minute
 * DESCRIPTION
 *  Draw Hour Image
 * PARAMETERS
 *  number [IN] U32
 *  num_0_img_id [IN] MMI_ID
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_minute(S16 minute)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j,width,height;
    U16 current_x, current_y;
    U8 draw_bit;
	S16 number = minute;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_DIGIT_S0,&width,&height);
	draw_bit = mmi_idle_swatch_get_number_bit(number);
	current_x = 7;
	current_y = 7 + 46;
    
    for (i = 0; i < draw_bit - 1; i++)
    {
        U16 divisor = 1, num_to_draw = 0;
        for (j = 0; j < draw_bit-i-1; j++)
        {
            divisor *= 10;
        }
        num_to_draw = number / divisor;
        number -= num_to_draw * divisor;
        
        gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_S0 + num_to_draw);
        current_x += width;
    }

    if(i == 0)
	{
	    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_S0);
		current_x += width;
	}
	
    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_S0 + number);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_second
 * DESCRIPTION
 *  Draw Hour Image
 * PARAMETERS
 *  number [IN] U32
 *  num_0_img_id [IN] MMI_ID
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_second(S16 second)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    S32 i, j,width,height;
    U16 current_x, current_y;
    U8 draw_bit;
	S16 number = second;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gdi_image_get_dimension_id(IMG_ID_IDLE_SWATCH_DIGIT_M0,&width,&height);
	draw_bit = mmi_idle_swatch_get_number_bit(number);
	current_x = 57;
	current_y = 7 + 46 + 11;
    
    for (i = 0; i < draw_bit - 1; i++)
    {
        U16 divisor = 1, num_to_draw = 0;
        for (j = 0; j < draw_bit-i-1; j++)
        {
            divisor *= 10;
        }
        num_to_draw = number / divisor;
        number -= num_to_draw * divisor;
        
        gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_M0 + num_to_draw);
        current_x += width;
    }

    if(i == 0)
	{
	    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_M0);
		current_x += width;
	}
	
    gdi_image_draw_id(current_x, current_y, IMG_ID_IDLE_SWATCH_DIGIT_M0 + number);
}

/*****************************************************************************
 * FUNCTION
 *  gui_swatch_sprintf_num
 * DESCRIPTION
 *  Sprintf num with bit
 * PARAMETERS
 *  str
 *  num
 *  bit
 * RETURNS
 *  void
 *****************************************************************************/
static void gui_swatch_sprintf_num(U16* str, U16 num, U8 bit)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    U16 i, j;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    MMI_ASSERT(str != NULL);
    
	memset(str, 0, bit*2+2);
    for (i = 0; i < bit; i++)
    {
        U16 divisor = 1, num_to_cat = 0;
        for (j = 0; j < bit-i-1; j++)
        {
            divisor *= 10;
        }
        num_to_cat = num / divisor;
        num -= num_to_cat * divisor;
        str[i] = 0x30 + num_to_cat;
    }
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_date
 * DESCRIPTION
 *  Draw Hour Image
 * PARAMETERS
 *  MYTIME [IN] MYTIME
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_date(S16 year, S16 month, S16 day)
{
	/*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 digital_month_str[12][4] = {"JAN", "FEB", "MAR", "APR", "MAY", "JUN", "JUL", "AUG",\
	"SEP", "OCT", "NOV", "DEC"}; 
	//const char * sss[12] = {"jan"};
	U16 current_x, current_y;
	U16 str[10]={0};
	U32 str_width, str_height;
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
	current_x = 7;
	current_y = 90;

	//draw year
	gui_move_text_cursor(current_x, current_y);
	gui_swatch_sprintf_num(str, year, 4);
	gui_set_text_color(gui_color(0, 0, 0));
	gui_set_font(&MMI_medium_font); 
    gui_print_text((UI_string_type)str);

	//draw month
	current_y += 18 + 3; //set month print pos
	gui_move_text_cursor(current_x, current_y);
	gui_sprintf(str, "%s", digital_month_str[month-1]);
	gui_set_text_color(gui_color(0, 0, 0));
	gui_set_font(&MMI_medium_bold_font); 
    gui_print_text((UI_string_type)str);

	//draw day
	//gui_set_font(&MMI_medium_bold_font); 
	gui_measure_string((UI_string_type)str, &str_width, &str_height);
	current_x += str_width + 10;
	gui_move_text_cursor(current_x, current_y);
	gui_swatch_sprintf_num(str, day, 2);
	gui_set_text_color(gui_color(0, 0, 0));
	gui_print_text((UI_string_type)str);	

} 

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_draw_week
 * DESCRIPTION
 *  Draw Hour Image
 * PARAMETERS
 *  MYTIME [IN] MYTIME
 *  
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_draw_week(S16 week)
{
	 /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	U8 digital_week_str[7][8] = {"Sun", "Mon", "Tue" , "Wed", "Thu", "Fri", "Sat"};
	U16 text_x, text_y, bound_x, bound_y;
	U16 str[8];
	U32 str_width, str_height;
	U16 bound_width, bound_height;
	U8 i = 0;
	stFontAttribute	MMI_swatch_s_font =	{1,0,0,SMALL_FONT,0,1};
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
	bound_x = 92;
	bound_y = 7;
	bound_width = 36;
	bound_height = 16;

	gui_set_font(&MMI_swatch_s_font); 
	for (i = 0; i < 7; i++)
	{		
		if (i == week) //show current week
		{
			gui_set_text_color(gui_color(0, 0, 0));
			gui_fill_rectangle(
            bound_x,
            bound_y,
			bound_x + bound_width,
            bound_y + bound_height,
            gui_color(255, 255, 255));
			
		}
		else
		{
			gui_set_text_color(gui_color(255, 255, 255));
		}
		memset(str, 0, sizeof(str));
		gui_sprintf(str, "%s", digital_week_str[i]);
		
		gui_measure_string((UI_string_type)str, &str_width, &str_height);
		text_x = bound_x + (bound_width - str_width) / 2;
		text_y = bound_y + (bound_height - str_height) / 2;
		gui_move_text_cursor(text_x, text_y);
    	gui_print_text((UI_string_type)str);
		bound_y = bound_y + bound_height;
	}

	
	
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_update_digital_clock
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void mmi_idle_swatch_update_digital_clock(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
	
    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/   
    gdi_layer_push_and_set_active(g_idle_swatch_p->update_layer_handle);
    gdi_layer_set_source_key(MMI_TRUE, GDI_COLOR_TRANSPARENT);
    //gdi_layer_push_and_set_clip(7,7,7+78-1,7+74-1);
    gdi_layer_clear(GDI_COLOR_TRANSPARENT);

    //gdi_draw_solid_rect(7,7,7+78-1,7+74-1,GDI_COLOR_TRANSPARENT);
	
    {
        MYTIME t;   
        //GetDateTime(&t);
        DTGetRTCTime(&t);
        
        //Draw hour
        mmi_idle_swatch_draw_hour(t.nHour);
        //Draw minute
        mmi_idle_swatch_draw_minute(t.nMin);

		mmi_idle_swatch_draw_second(t.nSec);
		//add by xl
		//Draw date
		mmi_idle_swatch_draw_date(t.nYear, t.nMonth, t.nDay);
		//Draw week
		mmi_idle_swatch_draw_week(t.DayIndex);
		
		gdi_image_draw_id(51, 64, IMG_ID_IDLE_SWATCH_DIGIT_PO);
    }
    
    //gdi_layer_pop_clip();
    gdi_layer_pop_and_restore_active();
    mmi_idle_swatch_blt_previous();

	StartTimer(IDLE_SWATCH_UPDATE_TIMER, MMI_IDLE_SWATCH_ANALOG_UPDATE_DELAY, mmi_idle_swatch_update_digital_clock);
}


void mmi_swatch_digital_key_down_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_sse_setup_scenario(GUI_SSE_SCENARIO_WEARABLE_CLOCK_SLIDE_DOWN);
	GoBackHistory();
}

void mmi_swatch_digital_key_up_handler(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	gui_sse_setup_scenario(GUI_SSE_SCENARIO_WEARABLE_CLOCK_SLIDE_UP);
	GoBackHistory();
}

void mmi_swatch_digital_enter_key_handler(void)
{
	EntryMainMenuFromIdleScreen();
}

/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_digit_entry
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_digit_entry(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //EntryNewScreen(SCR_ID_SWATCH_BW, NULL, NULL, NULL);
    if (!mmi_frm_scrn_enter(
            GRP_ID_SWATCH_DIGITAL,
            SCR_ID_SWATCH_DIGITAL,
            mmi_idle_swatch_exit,
            mmi_idle_swatch_digit_entry,
            MMI_FRM_UNKNOW_SCRN))
    {
        return;
    }
    //gui_sse_setup_scenario(GUI_SSE_SCENARIO_ENTER_MAINMENU); 
    mmi_idle_swatch_init();
    entry_full_screen();
    gdi_layer_multi_layer_enable();

    mmi_idle_swatch_draw_digit_bg();    
    mmi_idle_swatch_update_digital_clock();

#if !defined(__MMI_MAINLCD_128X128__)
    wgui_status_icon_bar_close_clock();
    wgui_status_icon_bar_update();
#endif /*__MMI_MAINLCD_128X128__*/

	mmi_frm_set_key_handler(mmi_swatch_digital_key_down_handler,KEY_DOWN_ARROW,KEY_EVENT_UP);
    mmi_frm_set_key_handler(mmi_swatch_digital_key_up_handler,KEY_UP_ARROW,KEY_EVENT_UP);
	mmi_frm_set_key_handler(mmi_swatch_digital_enter_key_handler,KEY_LSK,KEY_EVENT_UP);
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_digit_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  param      :[IN]   event      
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
static mmi_ret mmi_idle_swatch_digit_proc(mmi_event_struct *param)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    switch (param->evt_id)
    {
        case EVT_ID_GROUP_DEINIT:
        {
            break;
        }
        case EVT_ID_SCRN_ACTIVE:
        {
            mmi_idle_swatch_digit_entry();
            break;
        }
        case EVT_ID_SCRN_INACTIVE:
        {
            mmi_idle_swatch_exit();
            break;
        }
        case EVT_ID_SCRN_DEINIT:
        {            
            break;
        }
    }
    
    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  mmi_idle_swatch_enter_digit_screen
 * DESCRIPTION
 *  
 * PARAMETERS
 *  pos      :[IN]   coordinate of point      
 * RETURNS
 *  void
 *****************************************************************************/
static void mmi_idle_swatch_enter_digit_screen(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/
    MMI_ID group_id;

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    group_id = mmi_frm_group_create_ex(
        g_idle_swatch_p->group_id, 
        GRP_ID_SWATCH_DIGITAL, 
        mmi_idle_swatch_digit_proc, 
        NULL, 
        MMI_FRM_NODE_SMART_CLOSE_FLAG);
    
    MMI_ASSERT(group_id != GRP_ID_INVALID);

    mmi_frm_scrn_create(
         GRP_ID_SWATCH_DIGITAL, 
         SCR_ID_SWATCH_DIGITAL, 
         mmi_idle_swatch_digit_proc,   
        NULL);
}
#endif

#ifdef __CUI_SWATCH_SUPPORT__

/*****************************************************************************
 * FUNCTION
 *  cui_swatch_proc
 * DESCRIPTION
 *  
 * PARAMETERS
 *  event [IN] mmi_event_struct
 * RETURNS
 *  mmi_ret
 *****************************************************************************/
static mmi_ret cui_swatch_proc(mmi_event_struct *event)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
	MMI_TRACE(MOD_MMI_COMMON_APP, TRC_IDLE_SWATCH_PROC, event->evt_id);
    switch (event->evt_id)
    {
        case EVT_ID_SCRN_INACTIVE:
            mmi_idle_swatch_exit();
            break;
        case EVT_ID_SCRN_ACTIVE:
            mmi_idle_swatch_enter(g_idle_swatch_p->group_id);
            break;
    }

    return MMI_RET_OK;
}


/*****************************************************************************
 * FUNCTION
 *  cui_swatch_create
 * DESCRIPTION
 *  
 * PARAMETERS
 *  group_id
 * RETURNS
 *  void
 *****************************************************************************/
void cui_swatch_create(MMI_ID group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    //if (g_idle_swatch_p->is_active)
    //    return;
    
    MMI_ASSERT(group_id != GRP_ID_INVALID);
    g_idle_swatch_p->group_id = group_id;
    g_idle_swatch_p->group_id = mmi_frm_group_create(group_id, GRP_ID_CUI_SWATCH, cui_swatch_proc, NULL);  
    MMI_ASSERT(g_idle_swatch_p->group_id != GRP_ID_INVALID);
}


/*****************************************************************************
 * FUNCTION
 *  cui_swatch_run
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cui_swatch_run(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_enter(g_idle_swatch_p->group_id, MMI_FRM_NODE_SMART_CLOSE_FLAG);
    mmi_frm_scrn_create(g_idle_swatch_p->group_id, SCR_ID_CUI_SWATCH, (FuncPtr)cui_swatch_proc, NULL);
}


/*****************************************************************************
 * FUNCTION
 *  cui_swatch_create_and_run
 * DESCRIPTION
 *  
 * PARAMETERS
 *  group_id
 * RETURNS
 *  void
 *****************************************************************************/
void cui_swatch_create_and_run(MMI_ID group_id)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    cui_swatch_create(group_id);
    cui_swatch_run();
}


/*****************************************************************************
 * FUNCTION
 *  cui_swatch_close
 * DESCRIPTION
 *  
 * PARAMETERS
 *  void
 * RETURNS
 *  void
 *****************************************************************************/
void cui_swatch_close(void)
{
    /*----------------------------------------------------------------*/
    /* Local Variables                                                */
    /*----------------------------------------------------------------*/

    /*----------------------------------------------------------------*/
    /* Code Body                                                      */
    /*----------------------------------------------------------------*/
    mmi_frm_group_close(g_idle_swatch_p->group_id);
}

#endif  //__CUI_SWATCH_SUPPORT__

#endif /* __MMI_WEARABLE_DEVICE__ */ 

